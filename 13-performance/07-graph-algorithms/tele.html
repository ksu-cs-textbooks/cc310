




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Path Searches 1function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR) 2 STACK = empty array 3 DISCOVERED = empty set 4 PARENT_MAP = empty dictionary 5 append SRC to STACK 6 while STACK is not empty 7 CURR = top of the stack 8 if CURR not in DISCOVERED 9 if CURR is TAR 10 PATH = empty array 11 TRACE = TAR 12 while TRACE is not SRC 13 append TRACE to PATH 14 set TRACE equal to PARENT_MAP[TRACE] 15 reverse the order of PATH 16 return PATH 17 add CURR to DISCOVERED 18 NEIGHS = neighbors of CURR 19 for EDGE in NEIGHS 20 NODE = first entry in EDGE 21 append NODE to STACK 22 if PARENT_MAP does not have key NODE 23 in the PARENT_MAP dictionary set key NODE with value CURR 24 return nothing Time: The time analysis for the depth first search can be a bit complex.">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Graph Algorithms :: CC 310 Textbook">
    <meta name="twitter:description" content="Path Searches 1function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR) 2 STACK = empty array 3 DISCOVERED = empty set 4 PARENT_MAP = empty dictionary 5 append SRC to STACK 6 while STACK is not empty 7 CURR = top of the stack 8 if CURR not in DISCOVERED 9 if CURR is TAR 10 PATH = empty array 11 TRACE = TAR 12 while TRACE is not SRC 13 append TRACE to PATH 14 set TRACE equal to PARENT_MAP[TRACE] 15 reverse the order of PATH 16 return PATH 17 add CURR to DISCOVERED 18 NEIGHS = neighbors of CURR 19 for EDGE in NEIGHS 20 NODE = first entry in EDGE 21 append NODE to STACK 22 if PARENT_MAP does not have key NODE 23 in the PARENT_MAP dictionary set key NODE with value CURR 24 return nothing Time: The time analysis for the depth first search can be a bit complex.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/13-performance/07-graph-algorithms/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Graph Algorithms :: CC 310 Textbook">
    <meta property="og:description" content="Path Searches 1function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR) 2 STACK = empty array 3 DISCOVERED = empty set 4 PARENT_MAP = empty dictionary 5 append SRC to STACK 6 while STACK is not empty 7 CURR = top of the stack 8 if CURR not in DISCOVERED 9 if CURR is TAR 10 PATH = empty array 11 TRACE = TAR 12 while TRACE is not SRC 13 append TRACE to PATH 14 set TRACE equal to PARENT_MAP[TRACE] 15 reverse the order of PATH 16 return PATH 17 add CURR to DISCOVERED 18 NEIGHS = neighbors of CURR 19 for EDGE in NEIGHS 20 NODE = first entry in EDGE 21 append NODE to STACK 22 if PARENT_MAP does not have key NODE 23 in the PARENT_MAP dictionary set key NODE with value CURR 24 return nothing Time: The time analysis for the depth first search can be a bit complex.">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Performance">
    <meta property="article:modified_time" content="2024-07-11T17:36:42-05:00">
    <meta itemprop="name" content="Graph Algorithms :: CC 310 Textbook">
    <meta itemprop="description" content="Path Searches 1function DEPTHFIRSTSEARCH(GRAPH,SRC,TAR) 2 STACK = empty array 3 DISCOVERED = empty set 4 PARENT_MAP = empty dictionary 5 append SRC to STACK 6 while STACK is not empty 7 CURR = top of the stack 8 if CURR not in DISCOVERED 9 if CURR is TAR 10 PATH = empty array 11 TRACE = TAR 12 while TRACE is not SRC 13 append TRACE to PATH 14 set TRACE equal to PARENT_MAP[TRACE] 15 reverse the order of PATH 16 return PATH 17 add CURR to DISCOVERED 18 NEIGHS = neighbors of CURR 19 for EDGE in NEIGHS 20 NODE = first entry in EDGE 21 append NODE to STACK 22 if PARENT_MAP does not have key NODE 23 in the PARENT_MAP dictionary set key NODE with value CURR 24 return nothing Time: The time analysis for the depth first search can be a bit complex.">
    <meta itemprop="dateModified" content="2024-07-11T17:36:42-05:00">
    <meta itemprop="wordCount" content="1897">
    <title>Graph Algorithms :: CC 310 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc310/13-performance/07-graph-algorithms/" rel="canonical" type="text/html" title="Graph Algorithms :: CC 310 Textbook">
    <link href="/cc310/13-performance/07-graph-algorithms/index.xml" rel="alternate" type="application/rss+xml" title="Graph Algorithms :: CC 310 Textbook">
    <link href="/cc310/13-performance/07-graph-algorithms/index.print.html" rel="alternate" type="text/html" title="Graph Algorithms :: CC 310 Textbook">
    <link href="/cc310/13-performance/07-graph-algorithms/embed.html" rel="alternate" type="text/html" title="Graph Algorithms :: CC 310 Textbook">
    <link href="/cc310/css/fontawesome-all.min.css?1723740720" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1723740720" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1723740720" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1723740720" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1723740720" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1723740720" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1723740720" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1723740720" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1723740720" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1723740720" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1723740720" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1723740720" rel="stylesheet">
    <link href="/cc310/css/print.css?1723740720" rel="stylesheet" media="print">
    <script src="/cc310/js/variant.js?1723740720"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1723740720" rel="stylesheet">
  </head>
  <body class="mobile-support tele disableInlineCopyToClipboard" data-url="/cc310/13-performance/07-graph-algorithms/">
    
    <div id="tele" class="tele mirror">
    
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="graph-algorithms">Graph Algorithms</h1>

<h3 id="path-searches">Path Searches</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">DEPTHFIRSTSEARCH</span><span class="p">(</span><span class="n">GRAPH</span><span class="p">,</span><span class="n">SRC</span><span class="p">,</span><span class="n">TAR</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">STACK</span> <span class="o">=</span> <span class="n">empty</span> <span class="n">array</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">DISCOVERED</span> <span class="o">=</span> <span class="n">empty</span> <span class="nb">set</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">PARENT_MAP</span> <span class="o">=</span> <span class="n">empty</span> <span class="n">dictionary</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">append</span> <span class="n">SRC</span> <span class="n">to</span> <span class="n">STACK</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">while</span> <span class="n">STACK</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">CURR</span> <span class="o">=</span> <span class="n">top</span> <span class="n">of</span> <span class="n">the</span> <span class="n">stack</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="k">if</span> <span class="n">CURR</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">DISCOVERED</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="k">if</span> <span class="n">CURR</span> <span class="ow">is</span> <span class="n">TAR</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">                 <span class="n">PATH</span> <span class="o">=</span> <span class="n">empty</span> <span class="n">array</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">                 <span class="n">TRACE</span> <span class="o">=</span> <span class="n">TAR</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">                 <span class="k">while</span> <span class="n">TRACE</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">SRC</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                     <span class="n">append</span> <span class="n">TRACE</span> <span class="n">to</span> <span class="n">PATH</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">                     <span class="nb">set</span> <span class="n">TRACE</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">PARENT_MAP</span><span class="p">[</span><span class="n">TRACE</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                 <span class="n">reverse</span> <span class="n">the</span> <span class="n">order</span> <span class="n">of</span> <span class="n">PATH</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">                 <span class="k">return</span> <span class="n">PATH</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="n">add</span> <span class="n">CURR</span> <span class="n">to</span> <span class="n">DISCOVERED</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="n">NEIGHS</span> <span class="o">=</span> <span class="n">neighbors</span> <span class="n">of</span> <span class="n">CURR</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="k">for</span> <span class="n">EDGE</span> <span class="ow">in</span> <span class="n">NEIGHS</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">                <span class="n">NODE</span> <span class="o">=</span> <span class="n">first</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">EDGE</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">                <span class="n">append</span> <span class="n">NODE</span> <span class="n">to</span> <span class="n">STACK</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">                <span class="k">if</span> <span class="n">PARENT_MAP</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">have</span> <span class="n">key</span> <span class="n">NODE</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">                    <span class="ow">in</span> <span class="n">the</span> <span class="n">PARENT_MAP</span> <span class="n">dictionary</span> <span class="nb">set</span> <span class="n">key</span> <span class="n">NODE</span> <span class="k">with</span> <span class="n">value</span> <span class="n">CURR</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="k">return</span> <span class="n">nothing</span></span></span></code></pre></div>
<ul>
<li><strong>Time</strong>: The time analysis for the depth first search can be a bit complex. Lines 1 through 5 would execute in near constant time. When we start the while loop on line 6, it is more difficult to analyze how many times this can execute as <code>STACK</code> can contain duplicates. In the case that we have a sparse graph, this would be bound by the number of nodes. For a dense graph however, the number of executions would be bound by the number of edges. The code within the while loop would be bound by the number of nodes because of the check that we have not already discovered the node in line 8. If we haven&rsquo;t discovered it, we would take either the logic of lines 8 through 16 or lines 17 through 23 but never both in the same iteration. Both of these blocks are bound by the number of nodes in our graph. Thus the worst case time requirement would be $n^2$.</li>
<li><strong>Space</strong>: Depending on the density of our graph, the space required will be linear with respect to the number of nodes or edges. This is due to the fact that <code>STACK</code> can contain duplicate nodes. If we have a sparse graph then it will be bound by the number of nodes. If we have a dense graph then the space is bound by the number of edges.
<ul>
<li><code>STACK</code>: linear with respect to the number of edges</li>
<li><code>DISCOVERED</code>: linear with respect to the number of nodes</li>
<li><code>PARENT_MAP</code>: linear with respect to the number of nodes</li>
<li><code>CURR</code>: 1</li>
<li><code>PATH</code>: linear with respect to the number of nodes</li>
<li><code>TRACE</code>: 1</li>
<li><code>NEIGHS</code>: linear with respect to the number of neighbors</li>
<li><code>EDGE</code>: 1</li>
<li><code>NODE</code>: 1</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">BREADTHFIRSTSEARCH</span><span class="p">(</span><span class="n">GRAPH</span><span class="p">,</span><span class="n">SRC</span><span class="p">,</span><span class="n">TAR</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">QUEUE</span> <span class="o">=</span> <span class="n">empty</span> <span class="n">queue</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">DISCOVERED</span> <span class="o">=</span> <span class="n">empty</span> <span class="nb">set</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">PARENT_MAP</span> <span class="o">=</span> <span class="n">empty</span> <span class="n">dictionary</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">add</span> <span class="n">SRC</span> <span class="n">to</span> <span class="n">DISCOVERED</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">add</span> <span class="n">SRC</span> <span class="n">to</span> <span class="n">QUEUE</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">while</span> <span class="n">QUEUE</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">CURR</span> <span class="o">=</span> <span class="n">first</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">QUEUE</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">if</span> <span class="n">CURR</span> <span class="ow">is</span> <span class="n">TAR</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="n">PATH</span> <span class="o">=</span> <span class="n">empty</span> <span class="nb">list</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="n">TRACE</span> <span class="o">=</span> <span class="n">TAR</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="k">while</span> <span class="n">TRACE</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">SRC</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                    <span class="n">append</span> <span class="n">TRACE</span> <span class="n">to</span> <span class="n">PATH</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">                    <span class="nb">set</span> <span class="n">TRACE</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">PARENT_MAP</span><span class="p">[</span><span class="n">TRACE</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                <span class="n">reverse</span> <span class="n">the</span> <span class="n">order</span> <span class="n">of</span> <span class="n">PATH</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">                <span class="k">return</span> <span class="n">PATH</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="n">NEIGHS</span> <span class="o">=</span> <span class="n">neighbors</span> <span class="n">of</span> <span class="n">CURR</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="k">for</span> <span class="n">EDGE</span> <span class="ow">in</span> <span class="n">NEIGHS</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="n">NODE</span> <span class="o">=</span> <span class="n">first</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">EDGE</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">            <span class="k">if</span> <span class="n">NODE</span> <span class="ow">is</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">DISCOVERED</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">                <span class="n">add</span> <span class="n">NODE</span> <span class="n">to</span> <span class="n">DISCOVERED</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">                <span class="k">if</span> <span class="n">PARENT_MAP</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">have</span> <span class="n">key</span> <span class="n">NODE</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">                    <span class="ow">in</span> <span class="n">the</span> <span class="n">PARENT_MAP</span> <span class="n">dictionary</span> <span class="nb">set</span> <span class="n">key</span> <span class="n">NODE</span> <span class="k">with</span> <span class="n">value</span> <span class="n">CURR</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">                <span class="n">append</span> <span class="n">NODE</span> <span class="n">to</span> <span class="n">QUEUE</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="k">return</span> <span class="n">nothing</span></span></span></code></pre></div>
<ul>
<li><strong>Time</strong>: The run time expected for breadth first search is a bit more straight forward as <code>QUEUE</code> will never have duplicates. Lines 1 through 6 will all execute in constant time. The while loop will occur $n$ times where $n$ is the number of nodes. Based on the logic, either 9-16 will execute or 17-24 will execute. Both of these are bound by the number of nodes in terms of time. Each iteration of the while loop will take $n$ time and we do the while loop $n$ times; thus the running time will be $n^2$.</li>
<li><strong>Space</strong>: The space required for BFS will be linear with respect to the number of nodes. We have 5 variables which have size bound by the number of nodes. If the number of nodes doubles, then we expect the amount of space to roughly double.
<ul>
<li><code>QUEUE</code>: linear with respect to the number of nodes</li>
<li><code>DISCOVERED</code>: linear with respect to the number of nodes</li>
<li><code>PARENT_MAP</code>: linear with respect to the number of nodes</li>
<li><code>CURR</code>: 1</li>
<li><code>PATH</code>: linear with respect to the number of nodes</li>
<li><code>TRACE</code>: 1</li>
<li><code>NEIGHS</code>: linear with respect to the number of nodes</li>
<li><code>EDGE</code>: 1</li>
<li><code>NODE</code>: 1</li>
</ul>
</li>
</ul>
<h3 id="minimum-spanning-trees">Minimum Spanning Trees</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">KRUSKAL</span><span class="p">(</span><span class="n">GRAPH</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">MST</span> <span class="o">=</span> <span class="n">GRAPH</span> <span class="n">without</span> <span class="n">the</span> <span class="n">edges</span> <span class="n">attribute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">ALLSETS</span> <span class="o">=</span> <span class="n">an</span> <span class="n">empty</span> <span class="nb">list</span> <span class="n">which</span> <span class="n">will</span> <span class="n">contain</span> <span class="n">the</span> <span class="n">sets</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">for</span> <span class="n">NODE</span> <span class="ow">in</span> <span class="n">GRAPH</span> <span class="n">NODES</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">SET</span> <span class="o">=</span> <span class="n">a</span> <span class="nb">set</span> <span class="k">with</span> <span class="n">element</span> <span class="n">NODE</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">add</span> <span class="n">SET</span> <span class="n">to</span> <span class="n">ALLSETS</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">EDGES</span> <span class="o">=</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">GRAPH</span><span class="s1">&#39;s edges</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">SORTEDEDGES</span> <span class="o">=</span> <span class="n">EDGES</span> <span class="nb">sorted</span> <span class="n">by</span> <span class="n">edge</span> <span class="n">weight</span><span class="p">,</span> <span class="n">smallest</span> <span class="n">to</span> <span class="n">largest</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">for</span> <span class="n">EDGE</span> <span class="ow">in</span> <span class="n">SORTEDEDGES</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">SRC</span> <span class="o">=</span> <span class="n">source</span> <span class="n">node</span> <span class="n">of</span> <span class="n">EDGE</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">TAR</span> <span class="o">=</span> <span class="n">target</span> <span class="n">node</span> <span class="n">of</span> <span class="n">EDGE</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">SRCSET</span> <span class="o">=</span> <span class="n">the</span> <span class="nb">set</span> <span class="kn">from</span> <span class="nn">SETS</span> <span class="ow">in</span> <span class="n">which</span> <span class="n">SRC</span> <span class="ow">is</span> <span class="n">contained</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="n">TARSET</span> <span class="o">=</span> <span class="n">the</span> <span class="nb">set</span> <span class="n">form</span> <span class="n">SETS</span> <span class="ow">in</span> <span class="n">which</span> <span class="n">TAR</span> <span class="ow">is</span> <span class="n">contained</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="k">if</span> <span class="n">SRCSET</span> <span class="ow">not</span> <span class="n">equal</span> <span class="n">TARSET</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="n">UNIONSET</span> <span class="o">=</span> <span class="n">SRCSET</span> <span class="n">union</span> <span class="n">TARSET</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="n">add</span> <span class="n">UNIONSET</span> <span class="n">to</span> <span class="n">ALLSETS</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="n">remove</span> <span class="n">SRCSET</span> <span class="kn">from</span> <span class="nn">ALLSETS</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="n">remove</span> <span class="n">TARSET</span> <span class="kn">from</span> <span class="nn">ALLSETS</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="n">add</span> <span class="n">EDGE</span> <span class="n">to</span> <span class="n">MST</span> <span class="k">as</span> <span class="n">undirected</span> <span class="n">edge</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">return</span> <span class="n">MST</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Time</strong>: The time to initialize <code>MST</code> would be linear with respect to the number of nodes. Regardless of the graph implementation, inserting nodes is constant time and we would do it for the number of nodes in <code>GRAPH</code>. Lines 4-6 would take linear time with respect to the number of nodes. Then lines 9-19 would take linear time with respect to the number of edges as it would execute $e$ times and each operation can be done in constant time, except for searching through the sets and performing set operations, which require $log_2(n)$ time. Thus, Kruskal&rsquo;s algorithm will take time on the order of $e \times log_2(n)$ in the worst case.</p>
</li>
<li>
<p><strong>Space</strong>:The required space for Kruskal&rsquo;s algorithm is dependent on the implementation of the MST. A matrix graph would require $n^2$ space and a list graph we would require $n+e$ space.</p>
<ul>
<li><code>MST</code>: matrix graph $n^2$ or list graph $n+e$</li>
<li><code>ALLSETS</code>: linear with respect to the number of nodes</li>
<li><code>NODE</code>: 1</li>
<li><code>GRAPH NODES</code>: linear with respect to the number of nodes</li>
<li><code>SET</code>: 1</li>
<li><code>EDGES</code>: linear with respect to the number of edges</li>
<li><code>SORTEDEDGES</code>: linear with respect to the number of edges</li>
<li><code>SRC</code>: 1</li>
<li><code>TAR</code>: 1</li>
<li><code>SRCSET</code>: 1</li>
<li><code>TARSET</code>: 1</li>
<li><code>UNIONSET</code>: 1</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">PRIM</span><span class="p">(</span><span class="n">GRAPH</span><span class="p">,</span> <span class="n">START</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">MST</span> <span class="o">=</span> <span class="n">GRAPH</span> <span class="n">without</span> <span class="n">the</span> <span class="n">edges</span> <span class="n">attribute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">VISITED</span> <span class="o">=</span> <span class="n">empty</span> <span class="nb">set</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">add</span> <span class="n">START</span> <span class="n">to</span> <span class="n">VISITED</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">AVAILEDGES</span> <span class="o">=</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">edges</span> <span class="n">where</span> <span class="n">START</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">source</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">sort</span> <span class="n">AVAILEDGES</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">while</span> <span class="n">VISITED</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">the</span> <span class="n">nodes</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">SMLEDGE</span> <span class="o">=</span> <span class="n">smallest</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">AVAILEDGES</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">SRC</span> <span class="o">=</span> <span class="n">source</span> <span class="n">of</span> <span class="n">SMLEDGE</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">TAR</span> <span class="o">=</span> <span class="n">target</span> <span class="n">of</span> <span class="n">SMLEDGE</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="k">if</span> <span class="n">TAR</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VISITED</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="n">add</span> <span class="n">SMLEDGE</span> <span class="n">to</span> <span class="n">MST</span> <span class="k">as</span> <span class="n">undirected</span> <span class="n">edge</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="n">add</span> <span class="n">TAR</span> <span class="n">to</span> <span class="n">VISITED</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="n">add</span> <span class="n">the</span> <span class="n">edges</span> <span class="n">where</span> <span class="n">TAR</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">source</span> <span class="n">to</span> <span class="n">AVAILEDGES</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="n">remove</span> <span class="n">SMLEDGE</span> <span class="kn">from</span> <span class="nn">AVAILEDGES</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="n">sort</span> <span class="n">AVAILEDGES</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="k">return</span> <span class="n">MST</span></span></span></code></pre></div>
<ul>
<li><strong>Time without Priority Queue</strong>: The time to initialize <code>MST</code> would be linear with respect to the number of nodes. Regardless of the graph implementation, inserting nodes is constant time and we would do it for the number of nodes in <code>GRAPH</code>. With a matrix graph, setting up <code>AVAILEDGES</code> would take linear time with respect to the number of nodes. With a list graph, this would happen in constant time. Then, we need to get the smallest edge from the <code>AVAILEDGES</code> list, which would be a linear time operation based on the number of edges, and we must do that once for up to each edge in the graph. So, the worst case running time for Prim&rsquo;s algorithm is $e^2$. (Our implementation is actually a bit slower than this since we sort the list of available edges each time, but that is technically not necessary - our implementation is closer to $e^2 \times log_2(e)$!)</li>
<li><strong>Time with Priority Queue</strong>: We do get an improvement when we choose to implement this with a priority queue. For the most part, the performance is the same. Using a priority queue, heapify would optimize the sorting to happen in linear time with respect to the number of elements. In that case, we can reduce the total running time to on the order of $e \times log_2(n)$, which is the same as Kruskal&rsquo;s algorithm.</li>
<li><strong>Space</strong>: The required space for Prim&rsquo;s algorithm is also dependent on the implementation of the MST. A matrix graph would require $n^2$ space and a list graph we would require $n+e$ space.
<ul>
<li><code>MST</code>: matrix graph $n^2$ or list graph $n+e$</li>
<li><code>VISITED</code>: linear with respect to the number of nodes</li>
<li><code>AVAILEDGES</code>: linear with respect to the number of edges</li>
<li><code>SMLEDGE</code>: 1</li>
<li><code>SRC</code>: 1</li>
<li><code>TAR</code>: 1</li>
</ul>
</li>
</ul>
<h3 id="shortest-path">Shortest Path</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">DIJKSTRAS</span><span class="p">(</span><span class="n">GRAPH</span><span class="p">,</span> <span class="n">SRC</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">   <span class="n">SIZE</span> <span class="o">=</span> <span class="n">size</span> <span class="n">of</span> <span class="n">GRAPH</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">   <span class="n">DISTS</span> <span class="o">=</span> <span class="n">array</span> <span class="k">with</span> <span class="n">length</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">SIZE</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">   <span class="n">PREVIOUS</span> <span class="o">=</span> <span class="n">array</span> <span class="k">with</span> <span class="n">length</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">SIZE</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">   <span class="nb">set</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">the</span> <span class="n">entries</span> <span class="ow">in</span> <span class="n">PREVIOUS</span> <span class="n">to</span> <span class="n">none</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">   <span class="nb">set</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">the</span> <span class="n">entries</span> <span class="ow">in</span> <span class="n">DISTS</span> <span class="n">to</span> <span class="n">infinity</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">   <span class="n">DISTS</span><span class="p">[</span><span class="n">SRC</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">   <span class="n">PQ</span> <span class="o">=</span> <span class="nb">min</span><span class="o">-</span><span class="n">priority</span> <span class="n">queue</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">   <span class="n">loop</span> <span class="n">IDX</span> <span class="n">starting</span> <span class="n">at</span> <span class="mi">0</span> <span class="n">up</span> <span class="n">to</span> <span class="n">SIZE</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">insert</span> <span class="p">(</span><span class="n">DISTS</span><span class="p">[</span><span class="n">IDX</span><span class="p">],</span><span class="n">IDX</span><span class="p">)</span> <span class="n">into</span> <span class="n">PQ</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">while</span> <span class="n">PQ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">MIN</span> <span class="o">=</span> <span class="n">REMOVE</span><span class="o">-</span><span class="n">MIN</span> <span class="kn">from</span> <span class="nn">PQ</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">for</span> <span class="n">NODE</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="n">of</span> <span class="n">MIN</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="n">WEIGHT</span> <span class="o">=</span> <span class="n">graph</span> <span class="n">weight</span> <span class="n">between</span> <span class="n">MIN</span> <span class="ow">and</span> <span class="n">NODE</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="n">CALC</span> <span class="o">=</span> <span class="n">DISTS</span><span class="p">[</span><span class="n">MIN</span><span class="p">]</span> <span class="o">+</span> <span class="n">WEIGHT</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="k">if</span> <span class="n">CALC</span> <span class="o">&lt;</span> <span class="n">DISTS</span><span class="p">[</span><span class="n">NODE</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">                <span class="n">DISTS</span><span class="p">[</span><span class="n">NODE</span><span class="p">]</span> <span class="o">=</span> <span class="n">CALC</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">                <span class="n">PREVIOUS</span><span class="p">[</span><span class="n">NODE</span><span class="p">]</span> <span class="o">=</span> <span class="n">MIN</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">                <span class="n">PQIDX</span> <span class="o">=</span> <span class="n">index</span> <span class="n">of</span> <span class="n">NODE</span> <span class="ow">in</span> <span class="n">PQ</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">                <span class="n">PQ</span> <span class="n">decrease</span><span class="o">-</span><span class="n">key</span> <span class="p">(</span><span class="n">PQIDX</span><span class="p">,</span> <span class="n">CALC</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="k">return</span> <span class="n">DISTS</span> <span class="ow">and</span> <span class="n">PREVIOUS</span></span></span></code></pre></div>
<ul>
<li><strong>Time</strong>: The time required for Dijkstra&rsquo;s algorithm will be $n^2$ in the worst case. We would expect lines 1 through 8 to take constant time. The for loop on line 9 would be bound by the number of nodes. We would expect the for loop on line 13 to be bound by the number of nodes. This for loop will execute each time <code>PQ</code> is not empty (line 11), which is bound by the number of nodes. Thus, the block of code starting at 11 will take $n^2$ time to run in the worst case. This means that if we double the number of nodes, then the running time will be quadrupled. The worst case for Dijkstra&rsquo;s algorithm is characterized by being a very dense graph, meaning each node has a lot of neighbors. If the graph is sparse and our priority queue is efficient, we could expect this running time to be more along the lines of $(n + e) \times log_2(n)$, where $e$ is the number of edges.</li>
<li><strong>Space</strong>: The required space for Dijkstra&rsquo;s algorithm will be linear with respect to the number of nodes. We have 4 variables which have linear size with respect to the number of nodes. We say that this is linear because if we were to double the number of nodes, we would roughly double the space requirement.
<ul>
<li><code>SIZE</code>: 1</li>
<li><code>DISTS</code>: linear with respect to the number of nodes</li>
<li><code>PREVIOUS</code>: linear with respect to the number of nodes</li>
<li><code>PQ</code>: linear with respect to the number of nodes</li>
<li><code>IDX</code>: 1</li>
<li><code>MIN</code>: 1</li>
<li><code>NODE</code>: 1</li>
<li><code>NEIGHBORS</code>: linear with respect to the number of nodes</li>
<li><code>WEIGHT</code>: 1</li>
<li><code>CALC</code>: 1</li>
<li><code>PQIDX</code>: 1</li>
</ul>
</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>
</div>
</main>
</div>

</div>




<script src="/cc310/js/clipboard.min.js?1723740720" defer></script>
<script src="/cc310/js/perfect-scrollbar.min.js?1723740720" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cc310/js/mathjax/tex-mml-chtml.js?1723740720"></script>
<script src="/cc310/js/theme.js?1723740720" defer></script>

<script src="/cc310/js/tele-scroll.js?1723740720" defer></script>

</body>
</html>
