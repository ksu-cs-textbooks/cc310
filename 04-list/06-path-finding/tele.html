




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="The pseudocode for finding the initial path using the stack is shown below. We assume the enclosing class has already defined a stack called myStack and the datatype called Cell, which represents the squares in the maze. The algorithm also uses three helper functions as described below:
getNextCell(maze, topCell): computes the next cell based on our current cell’s location and direction; incrementDirection(topCell): increments a cell’s direction attribute following the clockwise sequence of up, right, down, left, and then finally done, which means that we’ve tried all directions; and valid(nextCell): determines if a cell is valid.">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Path Finding Algorithm :: CC 310 Textbook">
    <meta name="twitter:description" content="The pseudocode for finding the initial path using the stack is shown below. We assume the enclosing class has already defined a stack called myStack and the datatype called Cell, which represents the squares in the maze. The algorithm also uses three helper functions as described below:
getNextCell(maze, topCell): computes the next cell based on our current cell’s location and direction; incrementDirection(topCell): increments a cell’s direction attribute following the clockwise sequence of up, right, down, left, and then finally done, which means that we’ve tried all directions; and valid(nextCell): determines if a cell is valid.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/04-list/06-path-finding/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Path Finding Algorithm :: CC 310 Textbook">
    <meta property="og:description" content="The pseudocode for finding the initial path using the stack is shown below. We assume the enclosing class has already defined a stack called myStack and the datatype called Cell, which represents the squares in the maze. The algorithm also uses three helper functions as described below:
getNextCell(maze, topCell): computes the next cell based on our current cell’s location and direction; incrementDirection(topCell): increments a cell’s direction attribute following the clockwise sequence of up, right, down, left, and then finally done, which means that we’ve tried all directions; and valid(nextCell): determines if a cell is valid.">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Lists">
    <meta property="article:modified_time" content="2024-06-28T15:58:53-05:00">
    <meta itemprop="name" content="Path Finding Algorithm :: CC 310 Textbook">
    <meta itemprop="description" content="The pseudocode for finding the initial path using the stack is shown below. We assume the enclosing class has already defined a stack called myStack and the datatype called Cell, which represents the squares in the maze. The algorithm also uses three helper functions as described below:
getNextCell(maze, topCell): computes the next cell based on our current cell’s location and direction; incrementDirection(topCell): increments a cell’s direction attribute following the clockwise sequence of up, right, down, left, and then finally done, which means that we’ve tried all directions; and valid(nextCell): determines if a cell is valid.">
    <meta itemprop="dateModified" content="2024-06-28T15:58:53-05:00">
    <meta itemprop="wordCount" content="661">
    <title>Path Finding Algorithm :: CC 310 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc310/04-list/06-path-finding/" rel="canonical" type="text/html" title="Path Finding Algorithm :: CC 310 Textbook">
    <link href="/cc310/04-list/06-path-finding/index.xml" rel="alternate" type="application/rss+xml" title="Path Finding Algorithm :: CC 310 Textbook">
    <link href="/cc310/04-list/06-path-finding/index.print.html" rel="alternate" type="text/html" title="Path Finding Algorithm :: CC 310 Textbook">
    <link href="/cc310/04-list/06-path-finding/embed.html" rel="alternate" type="text/html" title="Path Finding Algorithm :: CC 310 Textbook">
    <link href="/cc310/css/fontawesome-all.min.css?1719869971" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1719869971" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1719869971" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1719869971" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1719869971" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1719869971" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1719869971" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1719869971" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1719869971" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1719869971" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1719869971" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1719869971" rel="stylesheet">
    <link href="/cc310/css/print.css?1719869971" rel="stylesheet" media="print">
    <script src="/cc310/js/variant.js?1719869971"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1719869971" rel="stylesheet">
  </head>
  <body class="mobile-support tele disableInlineCopyToClipboard" data-url="/cc310/04-list/06-path-finding/">
    
    <div id="tele" class="tele mirror">
    
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="path-finding-algorithm">Path Finding Algorithm</h1>

<p><a href="#R-image-030570c95447f1bc4367bee839d63533" class="lightbox-link"><img alt="Maze Step 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/5/5.7.maze4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-030570c95447f1bc4367bee839d63533"><img alt="Maze Step 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/5/5.7.maze4.png"></a></p>
<p>The pseudocode for finding the initial path using the stack is shown below. We assume the enclosing class has already defined a stack called <code>myStack</code> and the datatype called <code>Cell</code>, which represents the squares in the maze. The algorithm also uses three helper functions as described below:</p>
<ul>
<li><code>getNextCell(maze, topCell)</code>: computes the next cell based on our current cell&rsquo;s location and direction;</li>
<li><code>incrementDirection(topCell)</code>: increments a cell&rsquo;s direction attribute following the clockwise sequence of up, right, down, left, and then finally done, which means that we&rsquo;ve tried all directions; and</li>
<li><code>valid(nextCell)</code>: determines if a cell is valid. A cell is invalid if it is &ldquo;blocked&rdquo;, is outside the boundaries of the maze, or is in the current path (i.e., if it exists in the stack).</li>
</ul>
<p>The parameters of <code>findPath</code> are a 2-dimensional array called <code>maze</code>, the <code>startCell</code> and the <code>endCell</code>. The algorithm begins by pushing the <code>startCell</code> onto <code>myStack</code>. The cell at the top of the stack will always represent our current cell, while the remaining cells in the stack represent the path of cells taken to reach the current cell.</p>
<p>Next, we enter a loop, where we will do the bulk of the work. We peek at the cell on the top of the stack in order to use it in our computations. If the <code>topCell</code> is equal to our <code>goalCell</code>, then we are done and return <code>true</code> indicating that we have found a path to the goal.</p>
<p>If we are not at our goal, we check to see if we have searched all directions from the current cell. If that is the case, then the <code>direction</code> attribute of the <code>topCell</code> will have been set to <code>done</code>. If the <code>direction</code> attribute of <code>topCell</code> is equal to <code>done</code>, then we pop the <code>topCell</code> of the stack, effectively leaving that cell and returning to the next cell in the stack. This is an algorithmic technique called backtracking.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function FINDPATH(MAZE, STARTCELL, GOALCELL)
</span></span><span class="line"><span class="cl">    MYSTACK.PUSH(STARTCELL);
</span></span><span class="line"><span class="cl">	loop while !MYSTACK.ISEMPTY()
</span></span><span class="line"><span class="cl">        TOPCELL = MYSTACK.PEEK()
</span></span><span class="line"><span class="cl">		if TOPCELL equals GOALCELL
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		if TOPCELL.GETDIRECTION() = done then
</span></span><span class="line"><span class="cl">            MYSTACK.POP()
</span></span><span class="line"><span class="cl">		else
</span></span><span class="line"><span class="cl">            NEXTCELL = GETNEXTCELL(MAZE, TOPCELL)
</span></span><span class="line"><span class="cl">            INCREMENTDIRECTION(TOPCELL)	
</span></span><span class="line"><span class="cl">			if VALID(MAZE, NEXTCELL) then
</span></span><span class="line"><span class="cl">				if MYSTACK.ISFULL() then
</span></span><span class="line"><span class="cl">                    MYSTACK.DOUBLECAPACITY();
</span></span><span class="line"><span class="cl">				end if
</span></span><span class="line"><span class="cl">                MYSTACK.PUSH(NEXTCELL)
</span></span><span class="line"><span class="cl">			end if 
</span></span><span class="line"><span class="cl">		end if
</span></span><span class="line"><span class="cl">	end while 
</span></span><span class="line"><span class="cl">	return false
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>However, if we have not searched in all directions from <code>topCell</code>, we will try to explore a new cell (<code>nextCell</code>) adjacent to the <code>topCell</code>. Specifically, <code>nextCell</code> will be the adjacent cell in the direction stored by the <code>direction</code> attribute. We then increment the direction attribute of the <code>topCell</code> so if we end up backtracking, we will know which direction to try next.</p>
<p>Before we push the <code>nextCell</code> onto the stack, we must first check to see if it&rsquo;s a valid cell by calling the helper function <code>valid</code>. A cell is valid if it is open to be explored. A cell is invalid if it is &ldquo;blocked,&rdquo; is outside the boundaries of the maze, or is in the current path (i.e., if it exists in the stack). To help us determine if a cell is in the stack, we will need to extend our stack operations to include a <code>find</code> operation that searches the stack while leaving its contents intact. You will get to implement this operation in your project.</p>
<p>If <code>nextCell</code> is valid, we then check to make sure that the stack is not already full. If it is, we simply call <code>doubleCapacity</code> and continue on our way. Then we push <code>nextCell</code> onto <code>myStack</code> so it will become our next <code>topCell</code> on the next pass through the loop.</p>
<p>After we have explored all possible paths through the maze, the loop will eventually end, and the operation will return <code>false</code> indicating no path was found. While this is not the most efficient path finding algorithm, it is a good example of using stacks for backtracking. Also, if we do find a path and return, the path will be saved in the stack. We can then use the previous pseudocode for retracing our steps and going back to the <code>startCell</code>.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>
</div>
</main>
</div>

</div>




<script src="/cc310/js/clipboard.min.js?1719869971" defer></script>
<script src="/cc310/js/perfect-scrollbar.min.js?1719869971" defer></script>
<script src="/cc310/js/theme.js?1719869971" defer></script>

<script src="/cc310/js/tele-scroll.js?1719869971" defer></script>

</body>
</html>
