




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="Old Content">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Old Conetnt :: CC 310 Textbook">
    <meta name="twitter:description" content="Old Content">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/04-list/old/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Old Conetnt :: CC 310 Textbook">
    <meta property="og:description" content="Old Content">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Old Conetnt :: CC 310 Textbook">
    <meta itemprop="description" content="Old Content">
    <meta itemprop="dateModified" content="2024-06-28T15:58:53-05:00">
    <meta itemprop="wordCount" content="2">
    <title>Old Conetnt :: CC 310 Textbook</title>
    <link href="/cc310/css/fontawesome-all.min.css?1719688935" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1719688935" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1719688935" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1719688935" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1719688935" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1719688935" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1719688935" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1719688935" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1719688935" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1719688935" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1719688935" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1719688935" rel="stylesheet">
    <link href="/cc310/css/print.css?1719688935" rel="stylesheet" media="print">
    <link href="/cc310/css/format-print.css?1719688935" rel="stylesheet">
    <script src="/cc310/js/variant.js?1719688935"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1719688935" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc310/04-list/old/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="/cc310/04-list/"><span itemprop="name">Lists</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Old Conetnt</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/04-list/19-summary/" title="Lists Summary (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/04-list/old/04-stack-operations/" title="Basic Operations (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="old-conetnt">Old Conetnt</h1>

<p>Old Content</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Old Conetnt</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="basic-operations">Basic Operations</h1>


<a href="https://www.youtube.com/watch?v=_VILq37deuY">YouTube Video</a>

<p>We have already seen two basic stack operations: <code>push</code> and <code>pop</code>. However, there are others that make the stack much easier to use. These basic operations are:</p>
<ul>
<li><code>push</code>: places an item on top of the stack,</li>
<li><code>pop</code>: removes the item on the top of the stack and returns it,</li>
<li><code>peek</code>: returns the item on the top of the stack without removing it from the stack,</li>
<li><code>isEmpty</code>: returns true if there are no items on the stack, and</li>
<li><code>isFull</code>: returns true if our stack array is full.</li>
</ul>
<p>We will discuss each of these operations. But first, let&rsquo;s talk about the constructor for the <code>stack</code> class and what it must do to properly set up a <code>stack</code> object.</p>
<h2 id="constructor">Constructor</h2>
<p>The main responsibility of the constructor is to initialize our attributes in the <code>stack</code> class. As we discussed above, the attributes include the <code>myStack</code> array and the <code>top</code> attribute that keeps track of the top of the stack.</p>
<p>Since we are using an array for our stack, we will need to know how big to make the array in our constructor. There are two options. We could just use a default size for the array. Or, we could allow the user to pass in a positive integer to set the size. In this module we assume the caller must provide a <code>capacity</code> value, which must be greater than <code>0</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function STACKCONSTRUCTOR(CAPACITY)
</span></span><span class="line"><span class="cl">    if CAPACITY not an integer then
</span></span><span class="line"><span class="cl">        throw exception
</span></span><span class="line"><span class="cl">    else if CAPACITY &lt;= 0 then
</span></span><span class="line"><span class="cl">        throw exception
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">    MYSTACK = new array[CAPACITY]
</span></span><span class="line"><span class="cl">    TOP = -1
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>The first thing we do in the code is to check to make sure that <code>capacity</code> is actually an integer that is greater than <code>0</code>. Essentially, this is our precondition for the method. If our precondition is not met, we throw an exception. (If we are using a  typed language such as Java, we can enforce our precondition by requiring that <code>capacity</code> be of type <code>integer</code> instead of explicitly checking it in the code.) Once we&rsquo;ve validated our precondition, we create a new array of size <code>capacity</code> for the <code>myStack</code> array and set the attribute <code>top</code> to <code>-1</code>.</p>
<h2 id="push">Push</h2>
<p>We have already discussed the <code>push</code> operation and seen it in operation earlier in this module. In the pseudocode below, we see that we must first check to ensure that the stack is not already full. Again, this is our precondition. You may be picking up on the fact that the first thing we do in our methods is to check our precondition and throw an exception if it is not met. This is good coding practice.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PUSH(ITEM)
</span></span><span class="line"><span class="cl">    if MYSTACK is full then
</span></span><span class="line"><span class="cl">        throw exception
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">    TOP = TOP + 1
</span></span><span class="line"><span class="cl">    MYSTACK[TOP] = ITEM
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Once our precondition is validated, we simply increment <code>top</code> by <code>1</code> and store the <code>item</code> into the array at index <code>top</code>. We do not return anything from the <code>push</code> function. Also, notice that there are no loops in the <code>push</code> operation and thus the time it takes to execute the operation will always be the same regardless of the size of the <code>myStack</code> array. We call this constant time performance, which is typically very fast.</p>
<h2 id="pop">Pop</h2>
<p>Like <code>push</code>, we have already seen the <code>pop</code> operation. It simply takes the top item off of the stack and returns it. However, once again we need to validate our precondition before getting into the body of the operation. For the <code>pop</code> operation, our precondition is that the stack must not already be empty, which is detected when <code>top</code> equals <code>-1</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function POP
</span></span><span class="line"><span class="cl">    if TOP == -1 then
</span></span><span class="line"><span class="cl">        throw exception
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">    TOP = TOP - 1
</span></span><span class="line"><span class="cl">    return MYSTACK[TOP + 1]
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Once we have validated our precondition, we simply decrement <code>top</code> by <code>1</code> and then return the previous item at the top of the stack (<code>myStack[top + 1]</code>). Like the <code>push</code> operation, the <code>pop</code> operation takes a constant time to execute.</p>
<h2 id="isfull">IsFull</h2>
<p>To allow the calling program to detect when the stack is full, we define an <code>isFull</code> operation. Notice that code external to the <code>stack</code> class cannot access the value of <code>top</code> and so it cannot simply check if <code>top + 1 == length of myStack</code> on its own. In this case, the operation is very simple as we only need to return the Boolean value of <code>top + 1 == length of myStack</code> as shown below. There is no precondition for <code>isFull</code> and <code>isFull</code> operates in constant time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISFULL()
</span></span><span class="line"><span class="cl">	return TOP + 1 == length of MYSTACK
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="isempty">IsEmpty</h2>
<p>The <code>isEmpty</code> operation is very similar to the <code>isFull</code> operation except that we return the Boolean value of the condition  <code>top == -1</code> instead of <code>top + 1 == length of myStack</code>.</p>
<h2 id="peek">Peek</h2>
<p>The <code>peek</code> operation returns the top item on the stack, without removing it from the stack. Like the <code>pop</code> operation it has the precondition that the stack must not be empty. The pseudocode for the <code>peek</code> operation is shown below. It is also a constant time operation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PEEK()
</span></span><span class="line"><span class="cl">	if ISEMTPY() then
</span></span><span class="line"><span class="cl">		throw exception
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">    return MYSTACK[TOP]
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Notice that we replaced the precondition check of <code>top == -1</code> with a call to <code>isEmpty</code>, which produces the same result. The real benefit here is the readability of the code and the fact that we only have to code the <code>top == -1</code> check in the <code>isEmpty</code> operation. This will make it easier to maintain the code in the future if we change the way we implement the stack.</p>
<h2 id="doublecapacity">DoubleCapacity</h2>
<p>The <code>doubleCapacity</code> operation doubles the size of the array holding our stack. So, if we started with an array of size <code>4</code>, the <code>doubleCapacity</code> operation will result in an array of size <code>8</code> with the contents of our original array stored in it. Unfortunately, most programming languages (like Java) do not simply let you double the size of the array. A noted exception to this is Python, which does allow you to directly extend an array.</p>
<p>In a traditional programming language, the easiest way to accomplish the <code>doubleCapacity</code> operation is to complete the following steps:</p>
<ol>
<li>Create a new array with twice the capacity of the existing array,</li>
<li>Copy the contents of original array into the new array, then</li>
<li>Point the <code>myStack</code> array at the new array.</li>
</ol>
<p>The pseudocode for the <code>doubleCapacity</code> operation is shown below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function DOUBLECAPACITY()
</span></span><span class="line"><span class="cl">    NEWSTACK = new array[length of MYSTACK * 2]
</span></span><span class="line"><span class="cl">    loop I from 0 to TOP
</span></span><span class="line"><span class="cl">        NEWSTACK[i] = MYSTACK[i]
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">    MYSTACK = NEWSTACK
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>The <code>doubleCapacity</code> operation is not a constant time operation.  This is due to the fact that copying the contents of the original array into the new array requires us to copy each item in the stack into the new array individually. This requires N steps. Thus, we would say that <code>doubleCapacity</code> runs in the order of $N$ time.</p>
<h2 id="halvecapacity">HalveCapacity</h2>
<p>The <code>halveCapacity</code> operation is like the <code>doubleCapacity</code> operation except that we now have a precondition. We must make sure that when we cut the space for storing the stack that we still have enough space to store all the items currently in the stack. For example, if we have 10 items in a stack with a capacity of 16, we can&rsquo;t successfully perform <code>halveCapacity</code>. Doing so would only leave us a stack with a capacity of 8 and we would not be able to fit all 10 items in the new stack.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function HALVECAPACITY()
</span></span><span class="line"><span class="cl">	if TOP + 1 &gt; length of MYSTACK / 2 then
</span></span><span class="line"><span class="cl">		throw exception
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">    NEWSTACK = new array[length of MYSTACK / 2]
</span></span><span class="line"><span class="cl">    loop I from 0 to TOP
</span></span><span class="line"><span class="cl">        NEWSTACK[i] = MYSTACK[i]
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">    MYSTACK = NEWSTACK
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="tostring">ToString</h2>
<p>The <code>toString</code> operation returns a string that concatenates the strings representing all the items stored in an array. In most programming languages, each object class must implement the <code>toString</code> operation. For instance, in the stack below where each item is a character, if we called <code>myStack.toString()</code>, we would expect to be returned the string <code>&quot;K-State&quot;</code>.</p>
<p>Notice that we must read the stack array from top (right) to bottom (left) to get the proper output string.
In the pseudocode below we first create an empty string and then loop through the stack from top to bottom (0) using the item&rsquo;s own <code>toString</code> operation to create the appropriate output string. Notice that there are no preconditions for the operation. This is because if the stack is empty, the <code>for</code> loop is not executed and we simply return an empty string. However, because of the loop the <code>toString</code> operation runs in order N time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function TOSTRING()
</span></span><span class="line"><span class="cl">    OUTPUT = &#34;&#34;
</span></span><span class="line"><span class="cl">    loop I from TOP to 0
</span></span><span class="line"><span class="cl">        OUTPUT = OUTPUT + MYSTACK[I].TOSTRING()
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">    return OUTPUT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="basic-operations">Basic Operations</h1>


<a href="https://www.youtube.com/watch?v=htP3pacx1fI">YouTube Video</a>

<p>We have already seen the pseudocode for the two key operations for queues: <code>enqueue</code> and <code>dequeue</code>. However, there are several others that make the queue data structure much easier to use:</p>
<ul>
<li>enqueue&mdash;places an item on the end of the queue,</li>
<li>dequeue&mdash;removes and returns the item at the start of the queue,</li>
<li>peek&mdash;returns the item at the start of the queue without removing it,</li>
<li>isEmpty&mdash;returns true if there are no items in the queue,</li>
<li>isFull&mdash;returns true if our queue array is full, and</li>
<li>size&mdash;returns the number of items in the queue.</li>
</ul>
<p>We will discuss each of these operations. But first, let&rsquo;s talk about the constructor for the <code>queue</code> class and what it must do to properly set up a <code>queue</code> object.</p>
<h2 id="constructor">Constructor</h2>
<p>The main responsibility of the constructor is to initialize all the attributes in the <code>queue</code> class. As we discussed above, the attributes include the <code>myQueue</code> array and the <code>start</code> and <code>end</code> variables that hold indexes into <code>myQueue</code>.</p>
<p>Since we are using an array for our queue, we will need to know how big to make the array in our constructor. There are two options. We could just use a default size for the array. Or, we could allow the user to pass in a positive integer to set the size. In this module we assume the caller must provide a <code>capacity</code> value, which must be greater than <code>0</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function QUEUE (CAPACITY)
</span></span><span class="line"><span class="cl">	if CAPACITY is not an integer then		(1)
</span></span><span class="line"><span class="cl">		throw exception				        (2)
</span></span><span class="line"><span class="cl">	else if CAPACITY &lt;= 0 then			    (3)
</span></span><span class="line"><span class="cl">		throw exception				        (4)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	MYQUEUE = new array of size capacity	(5)
</span></span><span class="line"><span class="cl">    START = -1						        (6)
</span></span><span class="line"><span class="cl">    END = 0						            (7)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>The first thing we do in the code is to check to make sure that <code>capacity</code> is actually an integer that is greater than <code>0</code>. Essentially, this is our precondition for the method. If our precondition is not met, we throw an exception. (If we are using a  typed language such as Java, we can enforce our precondition by requiring that <code>capacity</code> be of type <code>integer</code> instead of explicitly checking it in the code.) Once we&rsquo;ve validated our precondition, we create a new array of size <code>capacity</code> for the <code>myQueue</code> array and set the attribute <code>start</code> to <code>-1</code> and <code>end</code> to <code>0</code>.</p>
<h2 id="enqueue">Enqueue</h2>
<p>We have already discussed the <code>enqueue</code> operation and seen it in operation above. In the pseudocode below, we see that we must first check to ensure that the queue is not already full. Again, this is our precondition.</p>
<div class="highlight"><pre tabindex="0"><code>function ENQUEUE (item)
	if ISFULL() then			          (1)
		raise exception			          (2)
	end if	
	MYQUEUE[END] = ITEM			          (3)
	END = (END + 1) % length of MYQUEUE	  (4)
	if START == -1				          (5)
		START = 0				          (6)
	end if
end function</code></pre></div><p>Once our precondition is validated, we simply increment and store the <code>item</code> into the array at index <code>end</code>. Then we increment <code>end</code>, using the modulo operator to wrap <code>end</code> to point to the beginning of the array if warranted. Next, we check for the condition of an empty queue. If <code>start = 1</code>, then we know the queue is empty, so we set <code>start = 0</code>. The <code>enqueue</code> function does not return a value.</p>
<p>Because there are no loops in the enqueue function, the function operates in constant time regardless of the size of the array or the number of items in it.</p>
<h2 id="dequeue">Dequeue</h2>
<p>Like <code>enqueue</code>, we have already seen the <code>dequeue</code> operation. It simply takes the first item from the <code>start</code> of the queue and returns it. However, before we can do that, we need to validate our precondition. For the <code>dequeue</code> operation, our precondition is that the queue must not already be empty, which is detected by the <code>isEmpty</code> function in line 1.</p>
<div class="highlight"><pre tabindex="0"><code>function DEQUEUE ()
    if ISEMPTY() then					        (1)
		raise exception					        (2)
    end if 
	ITEM = MYQUEUE[START]					    (3)
	START = (START + 1) % length of MYQUEUE		(4)
	if START == END						        (5)
		START = -1						        (6)
		END = 0						            (7)
	end if
	return ITEM							        (8)
end function</code></pre></div><p>Once we have validated our precondition, we simply copy the item from the <code>myQueue[start]</code> in line 3 and increment <code>start</code>. Again, we use the modulo operator in line 4 to wrap <code>start</code> back to <code>0</code> if it is needed.  Next, we check to see if the <code>myQueue</code> is empty, and, if it is, reset the values of <code>start</code> and <code>end</code> back to their initial values. Finally, we return the item to the calling function in line 8. Like the <code>enqueue</code> operation, the <code>dequeue</code> function operates in constant time.</p>
<h2 id="peek">Peek</h2>
<p>The <code>peek</code> operation returns the item at the start of the queue, without removing it from the array. Like the <code>dequeue</code> operation it has the precondition that the queue must not be empty. The pseudocode for the <code>peek</code> operation is shown below. It is also a constant time operation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PEEK()					(1)
</span></span><span class="line"><span class="cl">    if ISEMPTY() then			(2)
</span></span><span class="line"><span class="cl">		raise exception			(3)
</span></span><span class="line"><span class="cl">    else	
</span></span><span class="line"><span class="cl">		return MYQUEUE[START]	(4)
</span></span><span class="line"><span class="cl">    end if 
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="isfull">isFull</h2>
<p>To allow the calling program to detect when the queue is full, we define an <code>isFull</code> operation. Notice that code external to the <code>queue</code> class cannot access the value of <code>start</code> or <code>end</code> so it cannot simply check if <code>start == end</code> on its own. In this case, the operation is very simple as we only need to return the Boolean value of <code>start == end</code> as shown below. There is no precondition for <code>isFull</code> and <code>isFull</code> operates in constant time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISFULL()
</span></span><span class="line"><span class="cl">	return START == END				(1)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="isempty">isEmpty</h2>
<p>The <code>isEmpty</code> operation is very similar to the <code>isFull</code> operation except that we return the Boolean value of the condition  <code>start == -1</code> instead of <code>start == end</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISEMPTY()
</span></span><span class="line"><span class="cl">	return START == -1				(1)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="size">Size</h2>
<p>This <code>size</code> method returns the number of items in the queue. However, it is not as straightforward as it might sound. Actually, there are several cases that we must consider, based on the fact that both <code>start</code> and <code>end</code> can &ldquo;wrap around&rdquo; the end of the array:</p>
<ol>
<li><code>start == -1</code>&mdash;the queue is empty, and <code>size = 0</code>,</li>
<li><code>start == end</code>&mdash;the queue is full, and <code>size</code> equals the capacity of the array,</li>
<li><code>start &lt; end</code>&mdash;<code>size = end – start</code>, and</li>
<li><code>start &gt; end</code>&mdash;<code>size = capacity of array - start + end + 1</code>.</li>
</ol>
<p>Thus, in our function, we simply need to check four conditions.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function SIZE()
</span></span><span class="line"><span class="cl">	if START = -1							            (1)
</span></span><span class="line"><span class="cl">		return 0							            (2)
</span></span><span class="line"><span class="cl">	else if START == END					            (3)
</span></span><span class="line"><span class="cl">		return capacity of MYQUEUE			            (4)
</span></span><span class="line"><span class="cl">	else if START &lt; END						            (5)
</span></span><span class="line"><span class="cl">		return END – START					            (6)
</span></span><span class="line"><span class="cl">	else	
</span></span><span class="line"><span class="cl">		return capacity of MYQUEUE – START + END		(7)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Notice that the conditions that are checked in lines 3 and 5 ensure that <code>start</code> must be greater than <code>end</code>.  Therefore, we can simply use an <code>else</code> statement to capture the last case in line 7. Once again, this is a constant time function.</p>
<h2 id="doublecapacity">doubleCapacity</h2>
<p>The <code>doubleCapacity</code> operation doubles the size of the array holding our queue. If we started with an array of size <code>4</code>, the <code>doubleCapacity</code> operation will result in an array of size <code>8</code> with the contents of our original array stored in it. Unfortunately, most programming languages (like Java) do not simply let you double the size of the array. A noted exception to this is Python, which does allow you to directly extend an array.</p>
<p>In a traditional programming language, the easiest way to accomplish the <code>doubleCapacity</code> operation is to complete the following steps:</p>
<ol>
<li>Create a new array with twice the capacity of the existing array,</li>
<li>Copy the contents of original array into the new array,</li>
<li>Update the <code>start</code> and <code>end</code> variables to point at the correct elements, then</li>
<li>Point the <code>myQueue</code> array at the new array.</li>
</ol>
<p>The pseudocode for the <code>doubleCapacity</code> operation is shown below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function DOUBLECAPACITY()
</span></span><span class="line"><span class="cl">    NEWQUEUE = new array of MYQUEUE capacity * 2	(1)
</span></span><span class="line"><span class="cl">    LENGTH = SIZE()						            (2)
</span></span><span class="line"><span class="cl">    for I = 0 to LENGTH - 1					        (3)
</span></span><span class="line"><span class="cl">        NEWQUEUE[I] = DEQUEUE()				        (4)
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">    START = 0							            (5)
</span></span><span class="line"><span class="cl">    END = LENGTH						            (6)
</span></span><span class="line"><span class="cl">    MYQUEUE = NEWQUEUE					            (7)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>In the function, we create the new array in line 1 and then save the total number of items in the array for use later in line 2. Next, we use a <code>for</code> loop in lines 3 and 4 to copy the contents from <code>myQueue</code> into <code>newQueue</code>. Since the contents of <code>myQueue</code> are not necessarily stored neatly in the array (i.e., from $0$ to $n$), it is easier for us to use the existing <code>size</code> and <code>dequeue</code> functions to get access to each item in the queue in order. Once we have copied the items from <code>myQueue</code> to <code>newQueue</code>, we simply need to set the <code>start</code> and <code>end</code> variables in line 5 and 6, and then set <code>myQueue = newQueue</code> in line 7 to complete the process.</p>
<p>The <code>doubleCapacity</code> operation is not a constant time operation since copying the contents of the original array into the new array requires us to copy each item via a loop. This requires $N$ steps. Thus, we would say that <code>doubleCapacity</code> runs in &ldquo;order $N$&rdquo; time.</p>
<h2 id="halvecapacity">halveCapacity</h2>
<p>The <code>halveCapacity</code> operation is similar to the <code>doubleCapacity</code> operation except that we now have a precondition. We must make sure that when we reduce the space for storing the queue that we still have enough space to store all the items currently in the queue. For example, if we have 10 items in a queue with a capacity of 16, we can&rsquo;t successfully perform <code>halveCapacity</code>. Doing so would only leave us a queue with a capacity of 8 and we would not be able to fit all 10 items in the new queue.</p>
<p>The pseudocode for the <code>halveCapacity</code> function is shown below, with the precondition being checked in line 2. Once we create <code>newQueue</code> to be half the capacity of <code>myQueue</code> in line 4, the remainder of the function is exactly the same as the <code>doubleCapacity</code> function, since lines 5-10 are just concerned with copying the items from <code>myQueue</code> to <code>newQueue</code> and setting the associated variables.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function HALVECAPACITY()
</span></span><span class="line"><span class="cl">	if SIZE() &gt; MYQUEUE capacity / 2 then		    (2)
</span></span><span class="line"><span class="cl">		throw exception					            (3)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">    NEWQUEUE = new array of MYQUEUE capacity / 2	(4)
</span></span><span class="line"><span class="cl">    LENGTH = SIZE()						            (5)
</span></span><span class="line"><span class="cl">    for I = 0 to LENGTH - 1					        (6)
</span></span><span class="line"><span class="cl">        NEWQUEUE[I] = DEQUEUE()				        (7)
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">    START = 0							            (8)
</span></span><span class="line"><span class="cl">    END = LENGTH <span class="c">% length of NEWQUEUE	            (9)
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    MYQUEUE = NEWQUEUE					            (10)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Like the <code>doubleCapacity</code> operation, <code>halveCapacity</code> is not a constant time operation since copying the contents of the original array requires us to loop $N$ times. So, <code>halveCapacity</code> runs in &ldquo;order $N$&rdquo; time.</p>
<h2 id="tostring">toString</h2>
<p>The <code>toString</code> function returns a string that concatenates the strings representing all the items stored in an array. In most programming languages, each object class must implement the <code>toString</code> operation. For instance, in the queue below where each item is a character, if we called <code>myQueue.toString()</code>, we would expect to be returned the string <code>&quot;Wildcats&quot;</code>.</p>
<p><a href="#R-image-b98c9e4465d2a652bdb1e05d130db815" class="lightbox-link"><img alt="Queue Containing Wildcats" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/8/8.4.wildcats.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b98c9e4465d2a652bdb1e05d130db815"><img alt="Queue Containing Wildcats" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/8/8.4.wildcats.png"></a></p>
<p>Notice that we must read the queue array from <code>start</code> to <code>end</code> to get the proper output string.</p>
<p>In the pseudocode below we first create an empty string called <code>output</code> in line 1. Then, we create a loop in line 2 that counts using <code>i</code> the number of items in the queue from <code>0</code> to the <code>size</code> of the queue. However, we can&rsquo;t use this counter <code>i</code> to directly index into the array, since <code>start</code> and <code>end</code> may be almost anywhere in the array. Thus, we use <code>i</code> to compute <code>next</code> in line 3, which we will use as our index into the array. Our index <code>i</code> should begin with <code>start</code> and finish with the <code>end</code> value, which can also be computed as <code>start + size() – 1</code> modulo the capacity of <code>myQueue</code>. We then use the index <code>next</code> in line 4 to select the appropriate element of <code>myQueue</code> to append to our output string. Once the loop ends, we simply return our <code>output</code> string.</p>
<div class="highlight"><pre tabindex="0"><code>function TOSTRING()
    OUTPUT = &#34;&#34;								          (1)
    for I = 0 to SIZE() - 1						      (2)
        NEXT = (START + I) % MYQUEUE capacity		  (3)
        OUTPUT = OUTPUT + MYQUEUE[next].TOSTRING()	  (4)
    end for								              (5)
    return OUTPUT							          (6)
end function</code></pre></div><p>The <code>toString</code> function includes a loop that, at most, looks at each element in <code>myQueue</code>; therefore, <code>toString</code> executes in order $N$ time.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="singly-linked-lists">Singly Linked Lists</h1>


<a href="https://www.youtube.com/watch?v=U-abMlixblw">YouTube Video</a>

<h2 id="linked-node">Linked Node</h2>
<p>To solve the disadvantages of arrays, we need a data structure that allows us to insert and remove items in an ordered collection in constant time, independently from the number of items in the data structure.</p>
<p>The solution lies in creating our own specialized data structure where each node contains the data of interest as well as a reference, or pointer to the next node in the list. Of course, we would also need to have a pointer to the first node in the list, which we call the <code>head</code>.</p>
<p>The figure below shows how we can construct a linked list data structure. The <code>head</code> entity shown in the figure is a variable that contains a pointer to the first node in the list, in this case the node containing <code>-2</code>. Each node in the list is an object that has two main parts: the data that it holds, and a pointer to the next item in the list.</p>
<p><a href="#R-image-a86eb60e13b701c62cdd25b8fff29b63" class="lightbox-link"><img alt="Linked Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.listnode.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a86eb60e13b701c62cdd25b8fff29b63"><img alt="Linked Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.listnode.png"></a></p>
<p>The class representation of a singly linked list <code>Node</code> is shown below. As discussed above, we have two attributes: <code>data</code>, which holds the data of the node, and <code>next</code>, which is a reference or pointer to the next node. We also use a constructor and a standard <code>toString</code> operation to appropriately create a string representation for the data stored in the node.</p>
<p><a href="#R-image-537e3da842cb328d0f32af2898031261" class="lightbox-link"><img alt="Linked Node UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.listnodeuml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-537e3da842cb328d0f32af2898031261"><img alt="Linked Node UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.listnodeuml.png"></a></p>
<h2 id="linked-list">Linked List</h2>
<p>A list is represented by a special variable <code>head</code> that contains a pointer to the first item in the list. If the <code>head</code> is <code>null</code> (equal to <code>0</code>), then we have an empty list, which is a list with no items in it.</p>
<p>However, if we have items in the list, <code>head</code> will point to a node as shown in the figure below. This node has some data (in this case <code>-2</code>) and its own pointer that points to the next node in the list. As we can see in our example, <code>head</code> points to a sequence of five nodes that makes up our list. The node with the data 67 in it is the last item in the list since its pointer is <code>null</code>. We often refer to this condition as having a <code>null</code> pointer.</p>
<p><a href="#R-image-f55cb6ed247eab024fcdc2fe94e2d25a" class="lightbox-link"><img alt="Linked List Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.single.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f55cb6ed247eab024fcdc2fe94e2d25a"><img alt="Linked List Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.single.png"></a></p>
<p>While we will not show them explicitly in this module, each pointer is actually an address in memory. If we have a pointer to node <code>X</code> in our node, that means that we actually store the address of <code>X</code> in memory in our node.</p>
<h2 id="linked-list-class">Linked List Class</h2>
<p>To capture the necessary details for a singly linked list, we put everything into a class. The singly linked list class has two attributes:</p>
<ul>
<li><code>list</code>&mdash;the pointer to the first node in the list, and</li>
<li><code>size</code>&mdash;an integer to keep track of the number of items in the list.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">Class SingleLinkedList 
</span></span><span class="line"><span class="cl">    Node head
</span></span><span class="line"><span class="cl">    Integer size = 0</span></span></code></pre></div><p>While we would normally create getter and setter methods for each attribute in the class, to simplify and clarify our pseudocode below we use &ldquo;dot notation&rdquo; to refer directly to the attributes in the node. The following table illustrates our usage in this module.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Use</th>
<th style="text-align:center">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>node</code></td>
<td style="text-align:center"><a href="#R-image-7462e7c30acbe45879d5856e92102363" class="lightbox-link"><img alt="Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.node.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7462e7c30acbe45879d5856e92102363"><img alt="Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.node.png"></a></td>
</tr>
<tr>
<td style="text-align:center"><code>node.next</code></td>
<td style="text-align:center"><a href="#R-image-fefb200c08e5782dbe0c4f05567b0e5b" class="lightbox-link"><img alt="Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.node.next.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fefb200c08e5782dbe0c4f05567b0e5b"><img alt="Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.node.next.png"></a></td>
</tr>
<tr>
<td style="text-align:center"><code>node.next.next</code></td>
<td style="text-align:center"><a href="#R-image-6dbe38322653a10a90e59f80cf2f54b2" class="lightbox-link"><img alt="Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.node.next.next.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6dbe38322653a10a90e59f80cf2f54b2"><img alt="Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.node.next.next.png"></a></td>
</tr>
<tr>
<td style="text-align:center"><code>head</code></td>
<td style="text-align:center"><a href="#R-image-fe68110dadd37d0fad96415dae89ca3c" class="lightbox-link"><img alt="Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.head.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fe68110dadd37d0fad96415dae89ca3c"><img alt="Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.head.png"></a></td>
</tr>
<tr>
<td style="text-align:center"><code>head.next</code></td>
<td style="text-align:center"><a href="#R-image-c46aff5c273738189c775c6aa845e1f1" class="lightbox-link"><img alt="Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.head.next.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c46aff5c273738189c775c6aa845e1f1"><img alt="Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.head.next.png"></a></td>
</tr>
</tbody>
</table>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="singly-linked-lists---insertion">Singly Linked Lists - Insertion</h1>


<a href="https://www.youtube.com/watch?v=2TVtKD6jvQw">YouTube Video</a>

<p>Given the structure of our linked list, we can easily insert a new node at any location in the list. However, for our purposes we are generally interested in inserting new nodes at the beginning of the list, at some specific location in the list, or in the appropriate order if the list is sorted.</p>
<h2 id="inserting-at-the-beginning">Inserting at the Beginning</h2>
<p>Inserting a node at the beginning of a list is straightforward. We just have to be careful about the order we use when swapping pointers. In the <code>prepend</code> code below, line 1 creates the new node to be stored in the list. Next, line 2 assigns the pointer in the new node to point to the pointer held by the <code>head</code>. If there was an item already in the list, <code>head</code> will point to the previous first item in the list. If the list was empty, <code>head</code> will have been <code>null</code> and thus the <code>node.next</code> will become <code>null</code> as well. Line 3 assigns <code>head</code> to point to the new node and line 4 increments our size variable.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function prepend(data)
</span></span><span class="line"><span class="cl">    node = new Node(data)	(1) 
</span></span><span class="line"><span class="cl">	node.next = head 	    (2)
</span></span><span class="line"><span class="cl">	head = node			    (3)
</span></span><span class="line"><span class="cl">	size = size + 1		    (4)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>We show this process in the following example. The figure below shows the initial state as we enter the <code>prepend</code> operation. Our list has three items in it, an &ldquo;a&rdquo;, &ldquo;W&rdquo;, and &ldquo;Q&rdquo; and we want to add the new node &ldquo;M&rdquo; in front of item &ldquo;a&rdquo;.</p>
<p><a href="#R-image-5380558632e224b111b08e79c525ff3f" class="lightbox-link"><img alt="Singly Linked List Prepend 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5380558632e224b111b08e79c525ff3f"><img alt="Singly Linked List Prepend 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert1.png"></a></p>
<p>The figure below shows the effect of the first step of the operation. This step creates a new node for &ldquo;M&rdquo; and changes <code>next</code> to point at the same node as the pointer held by <code>head</code>, which is the address of the first item in the list, &ldquo;a&rdquo;.</p>
<p><a href="#R-image-83b94fa88c9c9bb1dcc6a03d9b3944de" class="lightbox-link"><img alt="Singly Linked List Prepend 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-83b94fa88c9c9bb1dcc6a03d9b3944de"><img alt="Singly Linked List Prepend 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert2.png"></a></p>
<p>The result of performing line 3 in the operation is shown below. In line 3 we simply change <code>head</code> to point to our new node, instead of node &ldquo;a&rdquo;. Notice now that the new node has been fully inserted into the list.</p>
<p><a href="#R-image-c58cdab1c17116ab19e699280dd333aa" class="lightbox-link"><img alt="Singly Linked List Prepend 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c58cdab1c17116ab19e699280dd333aa"><img alt="Singly Linked List Prepend 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert3.png"></a></p>
<p>And, if we redraw our diagram a bit, we get a nice neat list!</p>
<p><a href="#R-image-1a1c3b6494aecc75c592d9f4a018b6b4" class="lightbox-link"><img alt="Singly Linked List Prepend 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1a1c3b6494aecc75c592d9f4a018b6b4"><img alt="Singly Linked List Prepend 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert4.png"></a></p>
<p>Since there are no loops in the <code>prepend</code> operation, <code>prepend</code> runs in constant time.</p>
<h2 id="inserting-in-the-middle">Inserting in the Middle</h2>
<p>Inserting a node at a given index in the linked list is a little more difficult than inserting a node at the beginning of the list. First, we have to find the proper location to insert the new node before we can actually insert it. However, since we are given an index number, we simply need to follow the linked list to the appropriate index and then perform the insertion.</p>
<p>We do have a precondition to meet before we proceed, however. We need to make sure that the index provided to the operation is not less than 0 and that it is not greater than the size of the list, which is checked in line 2. If the precondition is not satisfied, we raise an exception in line 3.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function insertAt(data, index)	        (1)
</span></span><span class="line"><span class="cl">		if index &lt; 0 or index &gt; size	(2)
</span></span><span class="line"><span class="cl">			raise exception	            (3)
</span></span><span class="line"><span class="cl">		elseif index == 0	            (4)
</span></span><span class="line"><span class="cl">			prepend(data)		        (5)
</span></span><span class="line"><span class="cl">		else
</span></span><span class="line"><span class="cl">			curr = head.next	        (6)
</span></span><span class="line"><span class="cl">			prev = head		            (7)
</span></span><span class="line"><span class="cl">			node = new Node(data)	    (8)
</span></span><span class="line"><span class="cl">		for i = 1 to index – 1	        (9)
</span></span><span class="line"><span class="cl">			prev = curr	                (10)
</span></span><span class="line"><span class="cl">			curr = curr.next	        (11)
</span></span><span class="line"><span class="cl">		end for			                (12)
</span></span><span class="line"><span class="cl">		prev.next = node	            (13)
</span></span><span class="line"><span class="cl">		node.next = curr	            (14)
</span></span><span class="line"><span class="cl">		size = size + 1	                (15)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Lines 4 and 5 check to see if the <code>index</code> is 0, which means that we want to insert it as the first item in the list. Since this is the same as the <code>prepend</code> operation we&rsquo;ve already defined, we simply call that operation. While this may not seem like a big deal, it is actually more efficient and helps us to simplify the code in the rest of the operation.</p>
<p>The operation uses <code>curr</code> to keep track of which node in the list we are currently looking at, thus we initialize <code>curr</code> to point at the first node in the list in line 6.  To allow us to swap pointers once we find the appropriate place in the list, we keep track of the node previous to <code>curr</code> as well by using the variable <code>pre</code>. This variable is initialized to <code>head</code> in line 7, and line 8 creates the new node we will insert into our list. After line 8, our <code>list</code>, <code>node</code>, and <code>previous</code> pointers would look like the following (assuming the index passed in was <code>2</code>).</p>
<p><a href="#R-image-da7474336b927952a0a46546945e9f76" class="lightbox-link"><img alt="Singly Linked List Insert 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.insertat1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-da7474336b927952a0a46546945e9f76"><img alt="Singly Linked List Insert 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.insertat1.png"></a></p>
<p>At this point we start our walk through the list using the <code>for</code> loop in lines 9 - 12. Specifically, with an <code>index</code> of 2 we will actually go through the loop exactly one time, from <code>1 to 1</code>. Each time through the loop, lines 10 and 11 will cause <code>curr</code> and <code>prev</code> to point at the next nodes in the list. At the end of one time through our loop, our example will be as shown below.</p>
<p><a href="#R-image-2c11c689dcd98859ff320dc904cfcdd1" class="lightbox-link"><img alt="Singly Linked List Insert 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.insertat2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2c11c689dcd98859ff320dc904cfcdd1"><img alt="Singly Linked List Insert 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.insertat2.png"></a></p>
<p>Now, the only thing left to do is update the <code>next</code> pointer of node &ldquo;3&rdquo; to point at <code>node</code> (line 13), and <code>node.next</code> to point at <code>curr</code> node (line 14), while line 15 increments the size attribute. The updated list is shown below.</p>
<p><a href="#R-image-528783d5b84ed20d194601463a5a613b" class="lightbox-link"><img alt="Singly Linked List Insert 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.insertat3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-528783d5b84ed20d194601463a5a613b"><img alt="Singly Linked List Insert 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.insertat3.png"></a></p>
<p>The <code>insertAt</code> operation, while being quite flexible and useful, can potentially loop through each node in the list. Therefore, it runs in order $N$ time.</p>
<h2 id="inserting-in-order">Inserting in Order</h2>
<p>When we want to insert an item into an ordered list, we need to find the right place in the list to actually insert the new node. Essentially, we need to search the list to find two adjacent nodes where the first node&rsquo;s data is less than or equal to <code>data</code> and the second node&rsquo;s data is greater than <code>data</code>. This process requires a linear search of the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function insertOrdered(data) 
</span></span><span class="line"><span class="cl">		curr = head			                (1)
</span></span><span class="line"><span class="cl">	index = 0				                (2)
</span></span><span class="line"><span class="cl">	while curr != NULL AND curr.data &lt; data	(3) 
</span></span><span class="line"><span class="cl">		index = index + 1	                (4)
</span></span><span class="line"><span class="cl">		curr = curr.next	                (5)
</span></span><span class="line"><span class="cl">	end while
</span></span><span class="line"><span class="cl">	insertAt(data, index)	                (6)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Notice that we do not have a precondition since we will search the list for the appropriate place to insert the new node, even if the list is currently empty. In line 1, we create a <code>curr</code> variable to point to the current node we are checking in the list, while in line 2 we initialize an <code>index</code> variable to keep track of the index of <code>curr</code> in the list.</p>
<p>Next, lines 3 – 5 implement a loop that searches through the list to find a node where the data in that node is greater than or equal to the data we are trying to put into the list. We also check to see if we are at the end of the list. Inside the loop, we increment <code>index</code> and point <code>curr</code> to the next node in the list.</p>
<p>Once we find the appropriate place in the list, we simply call the <code>insertAt</code> operation to perform the actual insertion. Using the <code>insertAt</code> operation provides a nice, easy to understand operation. However, we do suffer a little in efficiency since both operations loop through the list to the location where we want to insert the new data node. However, since the <code>insertAt</code> call is not embedded within the loop, our <code>insertOrdered</code> operation still runs in order $N$ time.</p>
<p>Since the previous example inserts the number 2 into the list (which falls between -1 and 3), the results of running the <code>insertOrdered</code> operation will be the same output as the result of the <code>insertAt</code> operation as shown above.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="singly-linked-lists---removal">Singly Linked Lists - Removal</h1>

<p>The process of removing a node from a linked list is fairly straightforward. First, we find the node we want to remove from the list and then change the <code>next</code> pointer from the previous node in the list to the next node in the list.  This effectively bypasses the node we want to remove. For instance, if we want to remove node &ldquo;3&rdquo; from the following list,</p>
<p><a href="#R-image-996a7ec3ba8af8a723883539a19a8169" class="lightbox-link"><img alt="Linked List Remove 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.6.remove1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-996a7ec3ba8af8a723883539a19a8169"><img alt="Linked List Remove 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.6.remove1.png"></a></p>
<p>we simply change the <code>next</code> pointer in the &ldquo;-2&rdquo; node to point to node &ldquo;18&rdquo; instead of node &ldquo;3&rdquo;. Since no other nodes are pointing at node &ldquo;3&rdquo; it is effectively removed from our list as shown below. We then return the data in that node to the requesting function. Eventually, the garbage collector will come along and realize that nothing is referencing node &ldquo;3&rdquo; and put it back into available memory.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<h1 id="garbage-collector">Garbage Collector</h1>
<p>Many programming languages, including Java and Python, automatically manage memory for us. So, as we create or delete objects in memory, a special subroutine called the <em>garbage collector</em> will find and remove any objects that we are no longer using. This will help free up memory so we can use it again.</p>
<p>Other languages, such as C, require us to do that manually. So, whenever we stop using objects, we would have to also remember to free the memory used by that object. Thankfully, we don&rsquo;t have to worry about that in this course!</p>
</div>
</div>
<h2 id="removing-at-the-beginning">Removing at the Beginning</h2>
<p>Removing an item at the beginning of a list is extremely simple. After checking our precondition in line 1, which ensures that the list is not empty, we create a temporary copy of the data in the first node in line 3 so we can return it later in line 6. However, the actual removal of the first node simply requires us to point <code>head</code> to the second node in the list (line 4), which is found at <code>head.next</code>. This effectively skips over the first node in the list. Finally, we decrement our <code>size</code> variable in line 5 to keep it consistent with the number of nodes now in the list. Since there are no loops, <code>removeFirst</code> runs in constant time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeFirst() returns data
</span></span><span class="line"><span class="cl">		if size == 0			(1)
</span></span><span class="line"><span class="cl">			raise exception	    (2)
</span></span><span class="line"><span class="cl">		end if
</span></span><span class="line"><span class="cl">		temp = head.data		(3)
</span></span><span class="line"><span class="cl">	head = head.next 	        (4)
</span></span><span class="line"><span class="cl">	size = size – 1		        (5)
</span></span><span class="line"><span class="cl">	return temp			        (6)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="removing-in-the-middle">Removing in the Middle</h2>
<p>Removing a node at a specific index in the list is more difficult than simply removing the first node in the list since we have to walk through the list to find the node we want to remove before we can actually remove it. In addition, while walking through the list, we must keep track of the current node as well as the previous node, since removing a node requires us to change the previous node in the list.</p>
<p>In our <code>removeAt</code> operation below, we first check our precondition in line 1 to ensure that the <code>index</code> provided is a valid index in the list. If it is, we check to see if <code>index</code> is 0 in line 3 and call the <code>removeFirst</code> operation in line 4 if it is.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeAt(index) returns data
</span></span><span class="line"><span class="cl">    if index &lt; 0 OR index &gt; size – 1	(1)
</span></span><span class="line"><span class="cl">        raise exception	                (2)
</span></span><span class="line"><span class="cl">    else if index == 0	                (3)
</span></span><span class="line"><span class="cl">        return removeFirst()            (4)
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        curr = head.next	            (5)
</span></span><span class="line"><span class="cl">        prev = head		                (6)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for i = 1 to index - 1 	        (7)
</span></span><span class="line"><span class="cl">            prev = curr	                (8)
</span></span><span class="line"><span class="cl">            curr = curr.next	        (9)
</span></span><span class="line"><span class="cl">        end for
</span></span><span class="line"><span class="cl">        prev.next = curr.next	        (10)
</span></span><span class="line"><span class="cl">        size = size – 1	                (11)
</span></span><span class="line"><span class="cl">        return curr.data	            (12)
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Before we start our walk through the list using the <code>for</code> loop in lines 7 - 9, we declare two variables in lines 5 and 6:</p>
<ul>
<li><code>curr</code> points to the current node in our walk, and</li>
<li><code>prev</code> points to the node before <code>curr</code> in the list.</li>
</ul>
<p>Lines 7 – 9 are the <code>for</code> loop that we use to walk through the list to find the node at <code>index</code>. We simply update the values of <code>prev</code> and <code>curr</code> each time through the loop to point to the next node in the list.</p>
<p>Once we complete the <code>for</code> loop, <code>curr</code> is pointing at the node we want to remove and <code>prev</code> points at the previous node. Thus, we simply set <code>prev.next = curr.next</code> to bypass the <code>curr</code> node, decrement our size attribute by 1 to retain consistency, and return the data associated with the <code>curr</code> node.</p>
<p>Like the <code>insertAt</code> operation, the <code>removeAt</code> operation uses a loop and thus runs in order $N$ time.</p>
<h2 id="removing-instances-of-a-node">Removing Instances of a Node</h2>
<p>If we want to remove all occurrences of a specific node from the list, we take the data we want to remove from the list and then search all nodes in the list, removing any whose data matches the data from the input node. We will return the number of nodes removed from the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeData(data)
</span></span><span class="line"><span class="cl">	curr = head			            (1)
</span></span><span class="line"><span class="cl">	index = 0				        (2)
</span></span><span class="line"><span class="cl">	while (curr != null) 	        (3)
</span></span><span class="line"><span class="cl">		if (curr.data == data) 	    (4)
</span></span><span class="line"><span class="cl">			removeAt(index)	        (5)
</span></span><span class="line"><span class="cl">		end if
</span></span><span class="line"><span class="cl">		index = index + 1	        (6)
</span></span><span class="line"><span class="cl">		curr = curr.next	        (7)
</span></span><span class="line"><span class="cl">	end while	
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>To simplify this operation, we will call the <code>removeAt</code> operation to actually remove the node from the list, leaving this operation to simply find the nodes whose data match the input <code>data</code>.  We will use two variables in this operation:</p>
<ul>
<li><code>curr</code> will point to the current node we are checking, and</li>
<li><code>index</code> will keep track of the index of the <code>curr</code> node so we can use the <code>removeAt</code> operation.</li>
</ul>
<p>The main part of the operation is a <code>while</code> loop (lines 3 – 7) that walks through the list, node by node. For each node in the list, we check if its data matches the input <code>data</code> in line 5, and then call <code>removeAt</code> to remove it from the list if it does. Then, each time through the loop, we increment <code>index</code> in line 7 and then point <code>curr</code> to the next node in the list in line 8. When our loop exits, we have removed all the nodes whose data matched the input <code>data</code>.</p>
<p>Since we walk through the entire list, the <code>removeData</code> operation runs in order $N$ time.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="singly-linked-lists---other-operations">Singly Linked Lists - Other Operations</h1>

<h2 id="isempty">isEmpty</h2>
<p>The list <code>isEmpty</code> operation is rather straightforward. We simply need to return the truth of whether <code>head.next</code> has a null pointer. Obviously, <code>isEmpty</code> runs in constant time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function isEmpty() returns boolean
</span></span><span class="line"><span class="cl">    return head == NULL       (1)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="peek">peek</h2>
<p>The <code>peek</code> operation is designed to return the data from the last node inserted into the list, which is the node pointed at by <code>head</code>. This is easy to do; however, we must ensure that we check to see if the list is empty in line 1 before we return the <code>head.data</code> in line 3. Due to its simple structure, the run time of the <code>peek</code> operation is constant.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function peek() returns data
</span></span><span class="line"><span class="cl">	if isEmpty()			(1)
</span></span><span class="line"><span class="cl">		raise exception		(2)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	return head.data		(3)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="peekend">peekEnd</h2>
<p>The <code>peekEnd</code> operation is designed to return the first node inserted into the list, which is now the last node in the list. Like the <code>peek</code> operation, we must ensure the list is not empty in line 1 before actually searching for the end of the list. Lines 3 – 5 walk through the list using a <code>while</code> statement until <code>curr.next</code> is null, signifying that <code>curr</code> is pointing at the last node in the queue. Finally, line 6 simply returns the <code>data</code> in the last node. Since <code>peekEnd</code> must walk through the entire list to find the last node, it runs in order $N$ time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function peekEnd() returns data
</span></span><span class="line"><span class="cl">	if isEmpty()			    (1)
</span></span><span class="line"><span class="cl">		raise exception		    (2)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">    curr = head 			    (3)
</span></span><span class="line"><span class="cl">    while curr.next != null		(4)
</span></span><span class="line"><span class="cl">        curr = curr.next		(5)
</span></span><span class="line"><span class="cl">    end while
</span></span><span class="line"><span class="cl">    return curr.data			(6)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="list-based-stacks">List-Based Stacks</h1>


<a href="https://www.youtube.com/watch?v=Chs-MJlCbdg">YouTube Video</a>

<p>If we implement a stack using a singly linked list, we can simplify many things about the implementation. First of all, we can totally remove the <code>isFull</code>, <code>doubleCapacity</code>, and <code>halveCapacity</code> operations since we can grow and shrink our list-based stack as needed. The rest of the operations can be implemented directly with list operations. The front of the list will be the top of the stack since the operations to insert and remove items from the front of list are very efficient.</p>
<p>To implement our stack, we assume we have declared a linked list object named <code>list</code>.</p>
<h2 id="push">Push</h2>
<p>As expected, the <code>push</code> operation is almost trivial. We simply call the list <code>prepend</code> operation to insert the data into the front of the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function push(data)
</span></span><span class="line"><span class="cl">	list.prepend(data)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="pop">Pop</h2>
<p>Like <code>push</code>, the <code>pop</code> operation is also easily implemented using the <code>removeFirst</code> operation of our linked list. As long as the list is not empty, we simply return the data from the first item when we remove it from the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function pop() returns data
</span></span><span class="line"><span class="cl">	if list.isEmpty() then
</span></span><span class="line"><span class="cl">		throw exception
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">    return list.removeFirst().data
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="isempty">isEmpty</h2>
<p>The <code>isEmpty</code> operation is even easier. It is implemented by simply returning the results of the list <code>isEmpty</code> operation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function isEmpty() return boolean
</span></span><span class="line"><span class="cl">	return list.isEmpty()
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="peek">Peek</h2>
<p>The stack <code>peek</code> operation is also straightforward. To implement the <code>peek</code> operation we simply return the results from the list <code>peek</code> operation, which returns the <code>data</code> from the first node in the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function peek() returns data
</span></span><span class="line"><span class="cl">    return list.peek()
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>As we can see, each of the major operations for a stack is implemented easily using list operations that run in constant time. This makes list-based stacks extremely efficient data structures to use.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="doubly-linked-lists---insertion">Doubly Linked Lists - Insertion</h1>

<p>Insertion in doubly linked lists is similar to what we saw in the singly linked list with two exceptions:</p>
<ol>
<li>We must update both the <code>previous</code> and <code>next</code> pointers in all affected nodes.</li>
<li>We can use the <code>tail</code> pointer to make the insertion of data at the end of the list very efficient.</li>
</ol>
<h2 id="inserting-at-the-beginning">Inserting at the Beginning</h2>
<p>Inserting at the beginning of a doubly linked list is almost as straightforward as in a singly linked list. We just need to make sure that we update the <code>previous</code> pointer in each affected node. After creating the new <code>node</code> in line 1, we check to see if the list is empty in line 2. If it is empty, then we only have to worry about updating the <code>head</code> and <code>tail</code> pointers to both point at <code>node</code> in lines 3 and 4. If the list is not empty, we have the situation shown below.</p>
<p><a href="#R-image-9085035cdb89047703bfbcff8f2e742a" class="lightbox-link"><img alt="Doubly Linked List Insert 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9085035cdb89047703bfbcff8f2e742a"><img alt="Doubly Linked List Insert 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert1.png"></a></p>
<p>To insert a node at the beginning of the list, we set <code>head.previous</code> (the <code>previous</code> pointer in the first node in the list) to point to the new node in line 5.</p>
<p><a href="#R-image-7b6a7829e23269c5effec1d2ee66a0df" class="lightbox-link"><img alt="Doubly Linked List Insert 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7b6a7829e23269c5effec1d2ee66a0df"><img alt="Doubly Linked List Insert 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert2.png"></a></p>
<p>Next, we set the <code>next</code> pointer in the new node to point to where <code>head</code> is currently pointing in line 6, which is the first node in the list.</p>
<p><a href="#R-image-19d728c222a2b82c45b92e19653c4cf9" class="lightbox-link"><img alt="Doubly Linked List Insert 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-19d728c222a2b82c45b92e19653c4cf9"><img alt="Doubly Linked List Insert 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert3.png"></a></p>
<p>Finally, we update <code>head</code> to point to the new <code>node</code> and then increment the size in line 8.</p>
<p><a href="#R-image-7ac70a7e6cbfcba27a8f5a3c8f4237bf" class="lightbox-link"><img alt="Doubly Linked List Insert 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7ac70a7e6cbfcba27a8f5a3c8f4237bf"><img alt="Doubly Linked List Insert 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert4.png"></a></p>
<p>With a little bit of reformatting, we can see that we&rsquo;ve successfully inserted our new node in the list.</p>
<p><a href="#R-image-7e218110d6fd65f2ea4c01090ba5086d" class="lightbox-link"><img alt="Doubly Linked List Insert 5" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e218110d6fd65f2ea4c01090ba5086d"><img alt="Doubly Linked List Insert 5" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert5.png"></a></p>
<p>The pseudocode for this operation is given below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function prepend(data)
</span></span><span class="line"><span class="cl">	node = new Node(data)	    (1)
</span></span><span class="line"><span class="cl">	if size == 0	            (2)
</span></span><span class="line"><span class="cl">		head = node	            (3)
</span></span><span class="line"><span class="cl">		tail = node	            (4)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		head.previous = node	(5)
</span></span><span class="line"><span class="cl">		node.next = head	    (6)
</span></span><span class="line"><span class="cl">		head = node	            (7)
</span></span><span class="line"><span class="cl">	end 
</span></span><span class="line"><span class="cl">	size = size + 1	            (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Since there are no loops in the <code>prepend</code> code, the code runs in constant time.</p>
<h2 id="inserting-in-the-middle">Inserting in the Middle</h2>
<p>Inserting a new node at some arbitrary index in a doubly linked list is similar to the same operation in a singly linked list with a couple of changes.</p>
<ol>
<li>If the index is at the end of the list, we can use an efficient <code>append</code> operation (defined below) to insert the node at the end of the list.</li>
<li>When walking through the list to the correct index, we do not need to keep track of the previous node.</li>
<li>We will have to update both the <code>previous</code> and <code>next</code> pointers in all affected nodes.</li>
</ol>
<p>Lines 1 and 2 in the code check to ensure that the index is a valid number, then we check to see if we are inserting at the beginning or end of the list in lines 2 and 4. If we are, we simply call the appropriate method, either <code>prepend</code> or <code>append</code>.</p>
<p>If none of those conditions exist, then we start the process of walking through the list to find the node at <code>index</code>. To do this, we need to create the new node we want to insert and then create a temporary pointer <code>curr</code> that we will use to point to the current node on our walk.</p>
<p>Lines 10 and 11 form the loop that walks through the list until we get to the desired index. When the loop ends, we will want to insert the new <code>node</code> between <code>curr</code> and <code>curr.next</code>. Thus, we set the appropriate values for the new node&rsquo;s <code>next</code> and <code>previous</code> pointers in line 12 and 13. Then, we set the <code>previous</code> pointer in <code>node.next</code> to point back to <code>node</code> in line 14 and then set <code>curr.next</code> to point at the new node. Finally, we increment <code>size</code> by 1.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function insertAt(data, index)
</span></span><span class="line"><span class="cl">	if index &lt; 0 OR index &gt; size	(1)
</span></span><span class="line"><span class="cl">		raise exception	            (2)
</span></span><span class="line"><span class="cl">	else if index == 0	            (3)
</span></span><span class="line"><span class="cl">		prepend(data)	            (4)
</span></span><span class="line"><span class="cl">	else if index == size	        (5)
</span></span><span class="line"><span class="cl">		append(data)	            (6)
</span></span><span class="line"><span class="cl">	else				            (7)
</span></span><span class="line"><span class="cl">		node = new node(data)	    (8)
</span></span><span class="line"><span class="cl">		curr = head	                (9)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		for i = 1 to index -1	    (10)
</span></span><span class="line"><span class="cl">			curr = curr.next	    (11)
</span></span><span class="line"><span class="cl">		end for
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		node.next = curr.next	    (12) 
</span></span><span class="line"><span class="cl">		node.previous = curr	    (13)
</span></span><span class="line"><span class="cl">		node.next.previous = node	(14)
</span></span><span class="line"><span class="cl">		curr.next = node	        (15)
</span></span><span class="line"><span class="cl">		size = size + 1	            (16)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Although <code>prepend</code> and <code>append</code> run in constant time, the general case will cause us to walk through the list using a <code>for</code> loop. Therefore, the <code>insertAt</code> operation runs in order $N$ time.</p>
<h2 id="inserting-at-the-end">Inserting at the End</h2>
<p>Since we have added the <code>tail</code> pointer to the doubly linked list class, we can make adding a node at the end of the list run in constant time instead of order $N$ time. In fact, if you look at the code below for the <code>append</code> operation, it is exactly the same as the constant time <code>prepend</code> operation except we have replaced the <code>head</code> pointer with the <code>tail</code> pointer in lines 5 – 7.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function append(data)
</span></span><span class="line"><span class="cl">	node = new node(data)	     (1)
</span></span><span class="line"><span class="cl">	if size == 0	             (2)
</span></span><span class="line"><span class="cl">		tail = node	             (3)
</span></span><span class="line"><span class="cl">		head = node	             (4)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		tail.next = node	     (5)
</span></span><span class="line"><span class="cl">		node.previous = tail 	 (6)
</span></span><span class="line"><span class="cl">		tail = node	             (7)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	size = size + 1	             (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="doubly-linked-lists---removal-and-peek">Doubly Linked Lists - Removal and Peek</h1>

<p>The process of removing a node from a doubly linked list is really no more difficult than from a singly linked list. The only difference is that instead of changing just one pointer, we now also need to modify the <code>previous</code> pointer in the node following the node we want to remove. For instance, if we want to remove node &ldquo;3&rdquo; from the following list,</p>
<p><a href="#R-image-88f4392ee6b252b63dfde569b915d200" class="lightbox-link"><img alt="Doubly Linked List Detail" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.10.double.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-88f4392ee6b252b63dfde569b915d200"><img alt="Doubly Linked List Detail" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.10.double.png"></a></p>
<p>we simply modify the <code>next</code> pointer in node &ldquo;-2&rdquo; to point to node &ldquo;23&rdquo;. Then, we modify the <code>previous</code> pointer in node &ldquo;23&rdquo; to point to node &ldquo;-2&rdquo;. We then return the data in that node to the requesting function.</p>
<p><a href="#R-image-09ac47d198145664efc384dbfc5dc74b" class="lightbox-link"><img alt="Doubly Linked List Remove" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.12.remove.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-09ac47d198145664efc384dbfc5dc74b"><img alt="Doubly Linked List Remove" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.12.remove.png"></a></p>
<h2 id="removing-at-the-beginning">Removing at the Beginning</h2>
<p>The <code>remove</code> operation removes the first node in the list. First, we check to ensure that there is at least one node in the list in line 1 and raise an exception if there is not. Now, the process is simple. We simply create a temporary pointer <code>temp</code> that points to the node we are going to delete in line 3 and then point <code>head</code> to <code>head.next</code>, which is the second node in the list. Then, in line 5, we check to see if the list is empty (<code>head == null</code>) and set <code>tail</code> to <code>null</code> if it is (it was pointing at the node we just removed). If the list is not empty, we do not need to worry about updating <code>tail</code>; however, we do need to set the <code>previous</code> pointer of the first node in the list to <code>null</code> (it was also pointing at the node we just removed). Finally, we decrement <code>size</code> in line 8 and then return the data in the node we just removed in line 9. Obviously, the operation runs in constant time since there are no loops.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function remove() returns data
</span></span><span class="line"><span class="cl">	if size == 0	            (1)
</span></span><span class="line"><span class="cl">		raise exception	        (2)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	temp = head		            (3)
</span></span><span class="line"><span class="cl">	head = head.next	        (4)
</span></span><span class="line"><span class="cl">	if head == null	            (5)
</span></span><span class="line"><span class="cl">		tail = null	            (6)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		head.previous = null	(7)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	size = size – 1	            (8)
</span></span><span class="line"><span class="cl">	return temp.data	        (9)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="removing-in-the-middle">Removing in the Middle</h2>
<p>Removing a node at a specific index is very similar to the way we did it in singly linked lists. First, if we have an invalid <code>index</code> number, we raise an exception in line 2. Otherwise we check for the special cases of removing the first or last node in the list and calling the appropriate operations in lines 3 – 6.
If we have no special conditions, we create a temporary pointer <code>curr</code> and then walk through our list in lines 7 – 9. Once we reach the node we want to remove, we simply update the next node&rsquo;s <code>previous</code> pointer (line 10) and the previous node&rsquo;s <code>next</code> pointer (line 11) and we have effectively removed the node from the list. We then decrement size in line 12 and return the <code>data</code> from the removed node in line 13.</p>
<p>Since the operation relies on a loop to walk through the list, the operation runs in order $N$ time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeAt(index) returns data
</span></span><span class="line"><span class="cl">	if index &lt; 0 OR index &gt; size – 1	    (1)
</span></span><span class="line"><span class="cl">		raise exception	                    (2)
</span></span><span class="line"><span class="cl">	else if (index == 0)	                (3)
</span></span><span class="line"><span class="cl">		return remove()	                    (4)
</span></span><span class="line"><span class="cl">	else if index == size – 1	            (5)
</span></span><span class="line"><span class="cl">		return removeLast()	                (6)
</span></span><span class="line"><span class="cl">	else	
</span></span><span class="line"><span class="cl">		curr = head.next;	                (7)
</span></span><span class="line"><span class="cl">        for i = 1 to index -1 	            (8)
</span></span><span class="line"><span class="cl">            curr = curr.next	            (9)
</span></span><span class="line"><span class="cl">        end for
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        curr.next.previous = curr.previous	(10)
</span></span><span class="line"><span class="cl">        curr.previous.next = curr.next	    (11)
</span></span><span class="line"><span class="cl">        size = size – 1	                    (12)
</span></span><span class="line"><span class="cl">        return curr.data	                (13)
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="removing-at-the-end">Removing at the End</h2>
<p>Since we have added the <code>tail</code> pointer to the doubly linked list class, we can make removing a node at the end of the list run in constant time instead of running in order $N$ time. In fact, if you look at the code below for the <code>removeLast</code> operation, it is almost exactly the same as the constant time <code>removeFirst</code> operation. The only difference is that we have replaced the <code>head</code> pointer with the <code>tail</code> pointer and <code>head.next</code> with <code>tail.previous</code> in lines 3 – 7.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeLast() returns data
</span></span><span class="line"><span class="cl">	if size == 0	        (1)
</span></span><span class="line"><span class="cl">		raise exception	    (2)
</span></span><span class="line"><span class="cl">	end if	
</span></span><span class="line"><span class="cl">	temp = tail		        (3)
</span></span><span class="line"><span class="cl">	tail = tail.previous	(4)
</span></span><span class="line"><span class="cl">	if tail == null	        (5)
</span></span><span class="line"><span class="cl">		head = null	        (6)
</span></span><span class="line"><span class="cl">	else	
</span></span><span class="line"><span class="cl">		tail.next = null	(7)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	size = size – 1	        (8)
</span></span><span class="line"><span class="cl">	return temp.data	    (9)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="peekend">PeekEnd</h2>
<p>Another operation impacted by the addition of the <code>tail</code> pointer is the <code>peekEnd</code> operation. Since we can access the last node in the list directly, we just need to make sure that the list is not empty, which we do in lines 1 and 2. Then, we can return the <code>tail.data</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function peekEnd() returns data
</span></span><span class="line"><span class="cl">	if isEmpty()	        (1)
</span></span><span class="line"><span class="cl">		raise exception 	(2)
</span></span><span class="line"><span class="cl">	else	
</span></span><span class="line"><span class="cl">		return tail.data	(3)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc310/commit/318c7d43593e6a9444589099914205007b2c305d">Jun 28, 2024</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc310/js/clipboard.min.js?1719688935" defer></script>
    <script src="/cc310/js/perfect-scrollbar.min.js?1719688935" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cc310/js/mathjax/tex-mml-chtml.js?1719688935"></script>
    <script src="/cc310/js/theme.js?1719688935" defer></script>
  </body>
</html>
