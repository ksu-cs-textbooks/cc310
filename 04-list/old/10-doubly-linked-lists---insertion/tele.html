




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="Insertion in doubly linked lists is similar to what we saw in the singly linked list with two exceptions:
We must update both the previous and next pointers in all affected nodes. We can use the tail pointer to make the insertion of data at the end of the list very efficient. Inserting at the Beginning Inserting at the beginning of a doubly linked list is almost as straightforward as in a singly linked list.">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Doubly Linked Lists - Insertion :: CC 310 Textbook">
    <meta name="twitter:description" content="Insertion in doubly linked lists is similar to what we saw in the singly linked list with two exceptions:
We must update both the previous and next pointers in all affected nodes. We can use the tail pointer to make the insertion of data at the end of the list very efficient. Inserting at the Beginning Inserting at the beginning of a doubly linked list is almost as straightforward as in a singly linked list.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/04-list/old/10-doubly-linked-lists---insertion/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Doubly Linked Lists - Insertion :: CC 310 Textbook">
    <meta property="og:description" content="Insertion in doubly linked lists is similar to what we saw in the singly linked list with two exceptions:
We must update both the previous and next pointers in all affected nodes. We can use the tail pointer to make the insertion of data at the end of the list very efficient. Inserting at the Beginning Inserting at the beginning of a doubly linked list is almost as straightforward as in a singly linked list.">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Lists">
    <meta property="article:modified_time" content="2024-06-28T15:58:53-05:00">
    <meta itemprop="name" content="Doubly Linked Lists - Insertion :: CC 310 Textbook">
    <meta itemprop="description" content="Insertion in doubly linked lists is similar to what we saw in the singly linked list with two exceptions:
We must update both the previous and next pointers in all affected nodes. We can use the tail pointer to make the insertion of data at the end of the list very efficient. Inserting at the Beginning Inserting at the beginning of a doubly linked list is almost as straightforward as in a singly linked list.">
    <meta itemprop="dateModified" content="2024-06-28T15:58:53-05:00">
    <meta itemprop="wordCount" content="837">
    <title>Doubly Linked Lists - Insertion :: CC 310 Textbook</title>
    <link href="/cc310/css/fontawesome-all.min.css?1719688938" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1719688938" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1719688938" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1719688938" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1719688938" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1719688938" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1719688938" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1719688938" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1719688938" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1719688938" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1719688938" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1719688938" rel="stylesheet">
    <link href="/cc310/css/print.css?1719688938" rel="stylesheet" media="print">
    <script src="/cc310/js/variant.js?1719688938"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1719688938" rel="stylesheet">
  </head>
  <body class="mobile-support tele disableInlineCopyToClipboard" data-url="/cc310/04-list/old/10-doubly-linked-lists---insertion/">
    
    <div id="tele" class="tele mirror">
    
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="doubly-linked-lists---insertion">Doubly Linked Lists - Insertion</h1>

<p>Insertion in doubly linked lists is similar to what we saw in the singly linked list with two exceptions:</p>
<ol>
<li>We must update both the <code>previous</code> and <code>next</code> pointers in all affected nodes.</li>
<li>We can use the <code>tail</code> pointer to make the insertion of data at the end of the list very efficient.</li>
</ol>
<h2 id="inserting-at-the-beginning">Inserting at the Beginning</h2>
<p>Inserting at the beginning of a doubly linked list is almost as straightforward as in a singly linked list. We just need to make sure that we update the <code>previous</code> pointer in each affected node. After creating the new <code>node</code> in line 1, we check to see if the list is empty in line 2. If it is empty, then we only have to worry about updating the <code>head</code> and <code>tail</code> pointers to both point at <code>node</code> in lines 3 and 4. If the list is not empty, we have the situation shown below.</p>
<p><a href="#R-image-9085035cdb89047703bfbcff8f2e742a" class="lightbox-link"><img alt="Doubly Linked List Insert 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9085035cdb89047703bfbcff8f2e742a"><img alt="Doubly Linked List Insert 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert1.png"></a></p>
<p>To insert a node at the beginning of the list, we set <code>head.previous</code> (the <code>previous</code> pointer in the first node in the list) to point to the new node in line 5.</p>
<p><a href="#R-image-7b6a7829e23269c5effec1d2ee66a0df" class="lightbox-link"><img alt="Doubly Linked List Insert 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7b6a7829e23269c5effec1d2ee66a0df"><img alt="Doubly Linked List Insert 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert2.png"></a></p>
<p>Next, we set the <code>next</code> pointer in the new node to point to where <code>head</code> is currently pointing in line 6, which is the first node in the list.</p>
<p><a href="#R-image-19d728c222a2b82c45b92e19653c4cf9" class="lightbox-link"><img alt="Doubly Linked List Insert 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-19d728c222a2b82c45b92e19653c4cf9"><img alt="Doubly Linked List Insert 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert3.png"></a></p>
<p>Finally, we update <code>head</code> to point to the new <code>node</code> and then increment the size in line 8.</p>
<p><a href="#R-image-7ac70a7e6cbfcba27a8f5a3c8f4237bf" class="lightbox-link"><img alt="Doubly Linked List Insert 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7ac70a7e6cbfcba27a8f5a3c8f4237bf"><img alt="Doubly Linked List Insert 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert4.png"></a></p>
<p>With a little bit of reformatting, we can see that we&rsquo;ve successfully inserted our new node in the list.</p>
<p><a href="#R-image-7e218110d6fd65f2ea4c01090ba5086d" class="lightbox-link"><img alt="Doubly Linked List Insert 5" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e218110d6fd65f2ea4c01090ba5086d"><img alt="Doubly Linked List Insert 5" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert5.png"></a></p>
<p>The pseudocode for this operation is given below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function prepend(data)
</span></span><span class="line"><span class="cl">	node = new Node(data)	    (1)
</span></span><span class="line"><span class="cl">	if size == 0	            (2)
</span></span><span class="line"><span class="cl">		head = node	            (3)
</span></span><span class="line"><span class="cl">		tail = node	            (4)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		head.previous = node	(5)
</span></span><span class="line"><span class="cl">		node.next = head	    (6)
</span></span><span class="line"><span class="cl">		head = node	            (7)
</span></span><span class="line"><span class="cl">	end 
</span></span><span class="line"><span class="cl">	size = size + 1	            (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Since there are no loops in the <code>prepend</code> code, the code runs in constant time.</p>
<h2 id="inserting-in-the-middle">Inserting in the Middle</h2>
<p>Inserting a new node at some arbitrary index in a doubly linked list is similar to the same operation in a singly linked list with a couple of changes.</p>
<ol>
<li>If the index is at the end of the list, we can use an efficient <code>append</code> operation (defined below) to insert the node at the end of the list.</li>
<li>When walking through the list to the correct index, we do not need to keep track of the previous node.</li>
<li>We will have to update both the <code>previous</code> and <code>next</code> pointers in all affected nodes.</li>
</ol>
<p>Lines 1 and 2 in the code check to ensure that the index is a valid number, then we check to see if we are inserting at the beginning or end of the list in lines 2 and 4. If we are, we simply call the appropriate method, either <code>prepend</code> or <code>append</code>.</p>
<p>If none of those conditions exist, then we start the process of walking through the list to find the node at <code>index</code>. To do this, we need to create the new node we want to insert and then create a temporary pointer <code>curr</code> that we will use to point to the current node on our walk.</p>
<p>Lines 10 and 11 form the loop that walks through the list until we get to the desired index. When the loop ends, we will want to insert the new <code>node</code> between <code>curr</code> and <code>curr.next</code>. Thus, we set the appropriate values for the new node&rsquo;s <code>next</code> and <code>previous</code> pointers in line 12 and 13. Then, we set the <code>previous</code> pointer in <code>node.next</code> to point back to <code>node</code> in line 14 and then set <code>curr.next</code> to point at the new node. Finally, we increment <code>size</code> by 1.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function insertAt(data, index)
</span></span><span class="line"><span class="cl">	if index &lt; 0 OR index &gt; size	(1)
</span></span><span class="line"><span class="cl">		raise exception	            (2)
</span></span><span class="line"><span class="cl">	else if index == 0	            (3)
</span></span><span class="line"><span class="cl">		prepend(data)	            (4)
</span></span><span class="line"><span class="cl">	else if index == size	        (5)
</span></span><span class="line"><span class="cl">		append(data)	            (6)
</span></span><span class="line"><span class="cl">	else				            (7)
</span></span><span class="line"><span class="cl">		node = new node(data)	    (8)
</span></span><span class="line"><span class="cl">		curr = head	                (9)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		for i = 1 to index -1	    (10)
</span></span><span class="line"><span class="cl">			curr = curr.next	    (11)
</span></span><span class="line"><span class="cl">		end for
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		node.next = curr.next	    (12) 
</span></span><span class="line"><span class="cl">		node.previous = curr	    (13)
</span></span><span class="line"><span class="cl">		node.next.previous = node	(14)
</span></span><span class="line"><span class="cl">		curr.next = node	        (15)
</span></span><span class="line"><span class="cl">		size = size + 1	            (16)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Although <code>prepend</code> and <code>append</code> run in constant time, the general case will cause us to walk through the list using a <code>for</code> loop. Therefore, the <code>insertAt</code> operation runs in order $N$ time.</p>
<h2 id="inserting-at-the-end">Inserting at the End</h2>
<p>Since we have added the <code>tail</code> pointer to the doubly linked list class, we can make adding a node at the end of the list run in constant time instead of order $N$ time. In fact, if you look at the code below for the <code>append</code> operation, it is exactly the same as the constant time <code>prepend</code> operation except we have replaced the <code>head</code> pointer with the <code>tail</code> pointer in lines 5 – 7.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function append(data)
</span></span><span class="line"><span class="cl">	node = new node(data)	     (1)
</span></span><span class="line"><span class="cl">	if size == 0	             (2)
</span></span><span class="line"><span class="cl">		tail = node	             (3)
</span></span><span class="line"><span class="cl">		head = node	             (4)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		tail.next = node	     (5)
</span></span><span class="line"><span class="cl">		node.previous = tail 	 (6)
</span></span><span class="line"><span class="cl">		tail = node	             (7)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	size = size + 1	             (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>
</div>
</main>
</div>

</div>




<script src="/cc310/js/clipboard.min.js?1719688938" defer></script>
<script src="/cc310/js/perfect-scrollbar.min.js?1719688938" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cc310/js/mathjax/tex-mml-chtml.js?1719688938"></script>
<script src="/cc310/js/theme.js?1719688938" defer></script>

<script src="/cc310/js/tele-scroll.js?1719688938" defer></script>

</body>
</html>
