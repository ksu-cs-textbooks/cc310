




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Choosing the correct data structures &amp; writing efficient programs that use strings!">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Performance &amp; String Builder :: CC 310 Textbook">
    <meta name="twitter:description" content="Choosing the correct data structures &amp; writing efficient programs that use strings!">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/08-perf-string/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Performance &amp; String Builder :: CC 310 Textbook">
    <meta property="og:description" content="Choosing the correct data structures &amp; writing efficient programs that use strings!">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Performance &amp; String Builder :: CC 310 Textbook">
    <meta itemprop="description" content="Choosing the correct data structures &amp; writing efficient programs that use strings!">
    <meta itemprop="dateModified" content="2024-07-03T10:50:03-05:00">
    <meta itemprop="wordCount" content="12">
    <title>Performance &amp; String Builder :: CC 310 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc310/08-perf-string/" rel="canonical" type="text/html" title="Performance &amp; String Builder :: CC 310 Textbook">
    <link href="/cc310/08-perf-string/index.xml" rel="alternate" type="application/rss+xml" title="Performance &amp; String Builder :: CC 310 Textbook">
    <link href="/cc310/08-perf-string/tele.html" rel="alternate" type="text/html" title="Performance &amp; String Builder :: CC 310 Textbook">
    <link href="/cc310/08-perf-string/embed.html" rel="alternate" type="text/html" title="Performance &amp; String Builder :: CC 310 Textbook">
    <link href="/cc310/css/fontawesome-all.min.css?1720728605" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1720728605" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1720728605" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1720728605" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1720728605" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1720728605" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1720728605" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1720728605" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1720728605" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1720728605" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1720728605" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1720728605" rel="stylesheet">
    <link href="/cc310/css/print.css?1720728605" rel="stylesheet" media="print">
    <link href="/cc310/css/format-print.css?1720728605" rel="stylesheet">
    <script src="/cc310/js/variant.js?1720728605"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1720728605" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc310/08-perf-string/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Performance &amp; String Builder</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/07-hash-tables/07-summary/" title="Hash Tables Summary (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/08-perf-string/01-choosing/" title="Choosing the Right Structures (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 8</div>

<h1 id="performance--string-builder">Performance &amp; String Builder</h1>

<p>Choosing the correct data structures &amp; writing efficient programs that use strings!</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Performance &amp; String Builder</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="choosing-the-right-structures">Choosing the Right Structures</h1>


<a href="https://www.youtube.com/watch?v=kP_7u0Aw10w">YouTube Video</a>

<p>There are several linear data structures that we can use in our programs, including stacks, queues, lists, sets, and hash tables. In this course, we have covered each of these structures in detail. However, as a programmer, one of the most difficult decisions we will make when developing a program is the choice of which data structure to use. Sometimes the choice may be obvious based on the data we plan to store or the algorithms we need to perform, but in practice that happens very rarely. Instead, we are faced with competing tradeoffs between various factors such as ease of use, performance, and simplicity.</p>
<p>In this chapter, we&rsquo;ll review the various data structures and algorithms we&rsquo;ve learned about in this course, but this time we&rsquo;ll add a bit more focus on the decisions a programmer would make when choosing to use a particular data structure or algorithm.</p>
<h2 id="three-important-questions">Three Important Questions</h2>
<p>The choice of which data structure to use is often the most consequential choice we make when developing a new piece of software, as it can have a large impact on the overall performance of the program. While there are many different factors to consider, here are three important questions we can ask when choosing a data structure:</p>
<ol>
<li><strong>Does it Work?</strong> Above all else, the choice of a data structure must allow the program to complete its work correctly. If the program cannot function properly due to the choice of data structure, then all other factors can effectively be ignored. So, when developing a new program, we should first focus on choosing a data structure that we know will be able to complete the task. Thankfully, with a bit of programming ingenuity, most data structures can be used to complete most tasks, albeit poorly or inefficiently. In those cases, the next two questions will help us further narrow our choice.</li>
<li><strong>Is it Understandable?</strong> Once we have chosen a few data structures to analyze, the next factor we must deal with is understandability. If we cannot understand how to use our chosen data structure to perform the task, or if the method we use is so complex that it is difficult for us to explain to others, it is very likely that we&rsquo;ve made a poor choice. In most cases, the best choice of data structure will lead to the most straightforward and understandable implementation. The only exceptions to this are cases where we must deal with extremes of performance or limits on capability. In those extreme cases, many times a more complex answer ends up being the best one due to the limitations imposed on the system.</li>
<li><strong>Is it Performant?</strong> In programming, we use the term performant to characterize programs that exhibit a high level of performance and efficiency. So, when choosing a data structure to use in our program, we may want to choose one that is most likely to exhibit high levels of performance and efficiency while we use it. As we have learned throughout this course, different data structures are developed with different uses in mind, and it is a very good idea for us to keep that in mind when making our choice. In this chapter, we will spend some time reviewing these performance and efficiency factors for the various data structures we have covered so far, helping us make more informed choices.</li>
</ol>
<p>By answering the questions above in the order they are presented, we should be able to make good decisions about which data structures would work best in our program. We are purposely putting more focus on writing working and understandable code instead of worrying about performance. This is because many programs are only used with small data sets on powerful modern computers, so performance is not the most important aspect. However, there are instances where performance becomes much more important, and in those cases more focus can be placed on finding the most performant solution as well.</p>
<p>As it turns out, these three questions are very similar to a classic (trilemma)[https://en.wikipedia.org/wiki/Trilemma] from the world of business, as shown in the diagram below.</p>
<p><a href="#R-image-36fde87bcefbf3ff839095560744fe65" class="lightbox-link"><img alt="Trilemma Diagram" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/12.1.trilemma.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-36fde87bcefbf3ff839095560744fe65"><img alt="Trilemma Diagram" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/12.1.trilemma.svg"></a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>In the world of software engineering, it is said that the process of developing a new program can only have two of the three factors of &ldquo;good&rdquo;, &ldquo;fast&rdquo;, and &ldquo;cheap&rdquo;. The three questions above form a similar trilemma. Put another way, there will always be competing tradeoffs when selecting a data structure for our programs.</p>
<p>For example, the most performant option may not be as easy to understand, and it may be more difficult to debug and ensure that it works correctly. A great example of this is matrix multiplication, a very common operation in the world of high-performance computing. A simple solution requires just three loops and is very easy to understand. However, the most performant solution requires hundreds of lines of code, assembly instructions, and a deep understanding of the hardware on which the program will be executed. That program will be fast and efficient, but it is much more difficult to understand and debug.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>File:Project-triangle.svg. (2020, January 12). Wikimedia Commons, the free media repository. Retrieved 21:09, April 30, 2020 from <a href="https://commons.wikimedia.org/w/index.php?title=File:Project-triangle.svg&oldid=386979544" rel="external" target="_blank">https://commons.wikimedia.org/w/index.php?title=File:Project-triangle.svg&oldid=386979544</a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="data-structure-performance">Data Structure Performance</h1>

<p>Data structures that are used in our programs can be characterized in terms of two performance attributes: processing time and memory usage.</p>
<p>We will not worry about memory usage at this point, since most of the memory used in these data structures is consumed by the data that we are storing. More technically, we would say that the memory use of a data structure containing N elements is on the order of $N$ size. However, some structures, such as doubly linked lists, must maintain both the next and previous pointers along with each element, so there can be a significant amount of memory overhead. That is something we should keep in mind, but only in cases where we are dealing with a large amount of data and are worried about memory usage.</p>
<p>When evaluating the processing time of a data structure, we are most concerned with the algorithms used to add, remove, access, and find elements in the data structure itself. There are a couple of ways we can evaluate these operations.</p>
<ul>
<li><strong>Empirically</strong> – we can simply measure the real-world time it takes to perform these actions on the data we are expecting our program to process, and then review the results in a spreadsheet or plot them on a graph to compare them. This gives us a good idea of how well the program will work, but it does not give us a very deep understanding of why the data structure performs that way.</li>
<li><strong>Mathematically</strong> – the other option is to mathematically evaluate the algorithm by reviewing the code and determining the order of time it takes relative to the size of the input. While this does not give us an actual, real-world value for the time it takes to perform an operation, it allows us to easily compare different operations and data structures based on how they&rsquo;d perform given the same size of input. We typically discuss both the best-case and worst-case processing times for each operation.</li>
</ul>
<p>Throughout this course, we have included mathematical descriptions of the processing time of most major operations on the data structures we have covered.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="comparing-data-structures">Comparing Data Structures</h1>


<a href="https://www.youtube.com/watch?v=Zxn0f78fH0w">YouTube Video</a>

<p>One of the best ways to compare data structures is to look at the common operations that they can perform. For this analysis, we&rsquo;ve chosen to analyze the following four operations:</p>
<ul>
<li><strong>Insert</strong> – inserting a specific element into the structure, either in sorted order, or at the appropriate place as required by the definition of a stack or queue.</li>
<li><strong>Access</strong> – accessing a desired element. For general data structures, this is the process of accessing an element by its index or key in the structure. For stacks and queues, this is the process of accessing the next element to be returned.</li>
<li><strong>Find</strong> – this is the process of finding a specific element in the data structure, usually by iterating through it or using a binary search method if the structure is sorted</li>
<li><strong>Delete</strong> – this is the process of deleting a specific element in the case of a general-purpose structure or deleting and returning the next element in the case of a stack or queue.</li>
</ul>
<p>The following table compares the best- and worst-case processing time for many common data structures and operations, expressed in terms of $N$, the number of elements in the structure.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Data Structure</th>
<th style="text-align:center">Insert Best</th>
<th style="text-align:center">Insert Worst</th>
<th style="text-align:center">Access Best</th>
<th style="text-align:center">Access Worst</th>
<th style="text-align:center">Find Best</th>
<th style="text-align:center">Find Worst</th>
<th style="text-align:center">Delete Best</th>
<th style="text-align:center">Delete Worst</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Unsorted Array</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Sorted Array</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$\text{lg}(N)$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Array Stack (LIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Array Queue (FIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Unsorted Linked List</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Sorted Linked List</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
</tr>
<tr>
<td style="text-align:center">Linked List Stack (LIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Linked List Queue (FIFO)</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">Hash Table</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$N$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N$</td>
</tr>
</tbody>
</table>
<p>We can also compare these processing times by graphing the equations used to describe them. The graph below shows several of the common orders that we have seen so far.</p>
<p><a href="#R-image-9a0623f15c3190baefa718d390c6377d" class="lightbox-link"><img alt="Graph" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/12.3.graph.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9a0623f15c3190baefa718d390c6377d"><img alt="Graph" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/12.3.graph.png"></a></p>
<p>On the next few pages, we will discuss each data structure in brief, using this table to compare the performance of the various data structures we&rsquo;ve covered in this course.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="lists">Lists</h1>


<a href="https://www.youtube.com/watch?v=f8jtcC4p6BM">YouTube Video</a>

<h2 id="unsorted-linked-list">Unsorted Linked List</h2>
<p><a href="#R-image-38052dd68f25ba8ee1effa1353775ddd" class="lightbox-link"><img alt="Unsorted Linked List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/12.5.ulist.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-38052dd68f25ba8ee1effa1353775ddd"><img alt="Unsorted Linked List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/12.5.ulist.png"></a></p>
<p>The next data structure we learned about is the linked list. Specifically, we will look at the doubly linked list in this example, but in most instances the performance of a singly linked list is comparable.</p>
<p>With a linked list, the process of inserting an element at either the beginning or the end is a constant time operation since we maintain both a head and a tail reference. All we must do is create a new node and update a few references and we are good to go.</p>
<p>However, if we would like to access a specific element somewhere in the list, we will have to iterate through the list starting from either the head or the tail until we find the element we need. So, that operation runs in order $N$ time. This is the major difference between linked lists and arrays: with an array, we can directly access items using the array index, but with linked lists we must iterate to get to that element. This becomes important in the next section when we discuss the performance of a sorted linked list.</p>
<p>Similarly, the process of finding an element also requires iterating through the list, which is an operation that runs in order $N$ time.</p>
<p>Finally, if we want to find and delete an element, that also runs in order $N$ time since we must search through the list to find the element. Once we have found the element, the process of deleting that element is a constant time operation. So, if we use our list iterator methods in an efficient manner, the actual run time may be more efficient than this analysis would lead us to believe.</p>
<h2 id="sorted-linked-list">Sorted Linked List</h2>
<p><a href="#R-image-955c4964d5f54bb4979b666a0f8f6d37" class="lightbox-link"><img alt="Sorted Linked List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/12.5.slinked.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-955c4964d5f54bb4979b666a0f8f6d37"><img alt="Sorted Linked List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/12.5.slinked.png"></a></p>
<p>We have not directly analyzed the performance of a sorted linked list in this course, but hopefully the analysis makes sense based on what we have learned before. Since the process of iterating through a linked list runs in order of $N$ time, every operation required to build a sorted linked list is limited by that fact.</p>
<p>For example, if we want to insert an element into a list in sorted order, we must simply iterate through the list to find the correct location to insert it. Once we&rsquo;ve found it, the process of inserting is actually a constant time operation since we don&rsquo;t have to shift any elements around, but because we can&rsquo;t use binary search on a linked list, we don&rsquo;t have any way to take advantage of the fact that the list is sorted.</p>
<p>The same problem occurs when we want to search for a particular element. Since we cannot use binary search to jump around between various elements in the list, we are limited to a simple linear search process, which runs in order of $N$ time.</p>
<p>Likewise, when we want to search and delete an element from the list, we must once again iterate through the entire list, resulting in an operation that runs in order $N$ time.</p>
<p>So, is there any benefit to sorting a linked list? Based on this analysis, not really! The purpose of sorting a collection is simply to make searching for a particular element faster. However, since we cannot use array indices to jump around a list like we can with an array, we do not see much of an improvement.</p>
<p>However, in the real world, we can improve some of these linear algorithms by &ldquo;short-circuiting&rdquo; them. When we &ldquo;short-circuit&rdquo; an algorithm, we provide additional code that allows the algorithm to return early if it realizes that it will not succeed.</p>
<p>For example, if we are searching for a particular element in a sorted list, we can add an if statement to check and see if the current element is greater than the element we are searching for. If the list is sorted in ascending order, we know that we have gone past the location where we expected to find our element, so we can just return without checking the rest of the list. While this does not change the mathematical analysis of the running time of this operation, it may improve the real-world empirical analysis of the operation.</p>
<h2 id="linked-list-stack-lifo-and-linked-list-queue-fifo">Linked List Stack (LIFO) and Linked List Queue (FIFO)</h2>
<p><a href="#R-image-a148162b2b67b2e7ce97ee1bea7293e1" class="lightbox-link"><img alt="Unsorted Linked List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/12.5.ulist.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a148162b2b67b2e7ce97ee1bea7293e1"><img alt="Unsorted Linked List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/12.5.ulist.png"></a></p>
<p>We already saw how to use the operations from a linked list to implement both a stack and a queue. Since those data structures restrict the operations we can perform a bit, it turns out that we can use a linked list to implement a stack and a queue with comparable performance to an array implementation.</p>
<p>For example, inserting, accessing, and removing elements in a stack or a queue based on a doubly linked list are all constant time operations, since we can use the head and tail references in a doubly linked list to avoid the need to iterate through the entire list to perform those operations. In fact, the only time we would have to iterate through the entire list is when we want to find a particular element in the stack or the queue. However, since we cannot sort a stack or a queue, finding an element runs in order $N$ time, which is comparable to an array implementation.</p>
<p>By limiting the actions we want to perform with our linked list, we can get a level of performance similar to an array implementation of a stack or a queue. It is a useful outcome that demonstrates the ability of different data structures to achieve similar outcomes.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="hash-tables">Hash Tables</h1>


<a href="https://www.youtube.com/watch?v=3l7NGg0YsBk">YouTube Video</a>

<h2 id="hash-tables">Hash Tables</h2>
<p><a href="#R-image-04ea72fc38e794ef04351e48b959e76b" class="lightbox-link"><img alt="Hash Table" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/12.6.hashtable.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-04ea72fc38e794ef04351e48b959e76b"><img alt="Hash Table" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/12.6.hashtable.svg"></a></p>
<p>Analyzing the performance of a hash table is a bit trickier than the other data structures, mainly due to how a hash table tries to use its complex structure to get a &ldquo;best of both worlds&rdquo; performance outcome.</p>
<p>For example, consider the insert operation. In the best case, the hash table has a capacity that is large enough to guarantee that there are not any hash collisions. Each entry in the array of the hash table will be an empty list and inserting an element into an empty list is done in constant time, so the whole operation runs in the order of constant time.</p>
<p>The worst case for inserting an item into a hash table would be when every element has the same hash, so every element in the hash table is contained in the same list. In that case, we must iterate through the entire list to make sure the key has not already been used, which would be in the order of $N$ time.</p>
<p>Thankfully, if we properly design our hash table such that the capacity is much larger than our expected size, and the hash function we use to hash our keys results in a properly distributed hash, this worst case scenario should happen very rarely, if ever. Therefore, our expected performance should be closer to constant time.</p>
<p>One important thing to remember, however, is that each operation in a hash table requires computing the hash of the key given as input. Therefore, while some operations may run in constant time, if the action of computing the hash is costly, the overall operation may run very slowly.</p>
<p>The analysis of the operation to access a single element in a hash table based on a given key is similar. If the hash table elements are distributed across the table, then each list should only contain a single element. In that case, we can just compute the hash of the key and determine if that key has been used in a single operation, which runs in the order of constant time.</p>
<p>In the worst case, however, we once again have the situation where all the elements have been placed in the same linked list. We would need to iterate through each element to find the one we are looking for. In that case, the operation would run in the order of $N$ time.</p>
<p>The operation for finding a specific element in a hash table is a bit unique. In this case, we are discussing looking for a particular value, not necessarily a particular key. That operation is discussed in the previous paragraph. For the operation, the only possible way forward is to iterate through each list in the hash table and perform a linear search for the requested value, which will always run in order $N$ time.</p>
<p>Finally, if we want to delete a single element from a hash table based on a given key, the analysis is the same as inserting or finding an element. In the best case, it runs in the order of constant time, but the worst case runs in the order of N time since we must iterate through an entire list of $N$ elements.</p>
<p>Even though a hash table has some very poor performance in the worst case, as discussed earlier those worst case situations are very rare, and as long as we are careful about how we manage the capacity of our hash table and how we compute the hash of our objects, we can expect to see operations running in near constant time during normal usage.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="algorithms">Algorithms</h1>


<a href="https://www.youtube.com/watch?v=pu5SPVUescU">YouTube Video</a>

<p>We can examine the performance of the algorithms we use in a similar manner. Once again, we are concerned with both the memory usage and processing time of the algorithm. In this case, we are concerned with the amount of memory required to perform the algorithm that is above and beyond the memory used to store the data in the first place.</p>
<p>When analyzing searching and sorting algorithms, we&rsquo;ll assume that we are using arrays as our data structure, since they give us the best performance for accessing and swapping random elements quickly.</p>
<h2 id="searching">Searching</h2>
<p>There are two basic searching algorithms: linear search and binary search.</p>
<p><a href="#R-image-b1380c8a9335e1e0f2b552d0abadef4c" class="lightbox-link"><img alt="Linear Search" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/12.7.linear.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b1380c8a9335e1e0f2b552d0abadef4c"><img alt="Linear Search" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/12.7.linear.png"></a></p>
<p>For linear search, we are simply iterating through the entire data structure until we find the desired item. So, while we can stop looking as soon as it is found, in the worst case we will have to look at all the elements in the structure, meaning the algorithm runs in order $N$ time.</p>
<p><a href="#R-image-8323edea27a19040649d75c1c194353e" class="lightbox-link"><img alt="Binary Search" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/12.7.binary.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8323edea27a19040649d75c1c194353e"><img alt="Binary Search" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/12.7.binary.png"></a></p>
<p>Binary search, on the other hand, takes advantage of a sorted array to jump around quickly. In effect, each element we analyze allows us to eliminate half of the remaining elements in our search. With as few as 8 steps, we can search through an array that contains 64 elements. When we analyze this algorithm, we find that it runs in order $\text{lg}(N)$ time, which is a vast improvement over binary search.</p>
<p>Of course, this only works when we can directly access elements in the middle of our data structure. So, while a linked list gives us several performance improvements over an array, we cannot use binary search effectively on a linked list.</p>
<p>In terms of memory usage, since both linear search and binary search just rely on the original data structures for storing the data, the extra memory usage is constant and consists of just a couple of extra variables, regardless of how many elements are in the data structure.</p>
<h2 id="sorting">Sorting</h2>
<p>We have already discussed how much of an improvement binary search is over a linear search. In fact, our analysis showed that performing as few as 7 or 8 linear searches will take more time than sorting the array and using binary search. Therefore, in many cases we may want to sort our data. There are several different algorithms we can use to sort our data, but in this course we explored four of them: selection sort, bubble sort, merge sort, and quicksort.</p>
<p>The selection sort algorithm involves finding the smallest or largest value in an array, then moving that value to the appropriate end, and repeating the process until the entire array is sorted. Each time we iterate through the array, we look at every remaining element. In the module on sorting, we showed (through some clever mathematical analysis) that this algorithm runs in the order of $N^2$ time.</p>
<p>Bubble sort is similar, but instead of finding the smallest or largest element in each iteration, it focuses on just swapping elements that are out of order, and eventually (through repeated iterations) sorting the entire array. While doing so, the largest or smallest elements appear to &ldquo;bubble&rdquo; to the appropriate end of the array, which gives the algorithm its name. Once again, because the bubble sort algorithm repeatedly iterates through the entire data structure, it also runs on the order of $N^2$ time.</p>
<p>Both selection sort and bubble sort are inefficient as sorting algorithms go, yet their main value is their simplicity. They are also very nice in that they do not require any additional memory usage to run. They are easy to implement and understand and make a good academic example when learning about algorithms. While they are not used often in practice, later in this module we will discuss a couple of situations where we may consider them useful.</p>
<p><a href="#R-image-995ce61aaeac87caca4b24f9f1ea0fda" class="lightbox-link"><img alt="Merge Sort" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/12.7.merge.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-995ce61aaeac87caca4b24f9f1ea0fda"><img alt="Merge Sort" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/12.7.merge.png"></a></p>
<p>Merge sort is a very powerful divide and conquer algorithm, which splits the array to be sorted into progressively smaller parts until each one contains just one or two elements. Then, once those smaller parts are sorted, it slowly merges them back together until the entire array is sorted. We must look at each element in the array at least once per &ldquo;level&rdquo; of the algorithm in the diagram above, so overall this algorithm runs in the order of $N * \text{lg}(N)$ time. This is quite a bit faster than selection sort and bubble sort. However, most implementations of merge sort require at least a second array for storing data as it is merged together, so the additional memory usage is also on the order of $N$.</p>
<p><a href="#R-image-ae35b7191a7ce2f17d5c90458e4f684a" class="lightbox-link"><img alt="Quicksort Best Case" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/7.20.quicktime.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ae35b7191a7ce2f17d5c90458e4f684a"><img alt="Quicksort Best Case" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/7.20.quicktime.png"></a></p>
<p>Quicksort is a very clever algorithm, which involves selecting a &ldquo;pivot&rdquo; element from the data, and then dividing the data into two halves, one containing all elements less than the pivot, and another with all items greater than the pivot. Then, the process repeats on each half until the entire structure is sorted.
In the ideal scenario, shown in the diagram above, quicksort runs on the order of $N * \text{lg}(N)$ time, similar to merge sort. However, this depends on the choice of the pivot element being close to the median element of the structure, which we cannot always guarantee. Thankfully, in practice, we can just choose a random element (such as the last element in the structure) and we&rsquo;ll see performance that is close to the $N * \text{lg}(N)$ target.</p>
<p><a href="#R-image-83d56ebacce7f7b55ef12558072f77e8" class="lightbox-link"><img alt="Quicksort Worst Case" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/12/7.20.quicktime2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-83d56ebacce7f7b55ef12558072f77e8"><img alt="Quicksort Worst Case" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/12/7.20.quicktime2.png"></a></p>
<p>However, if we choose our pivot element poorly, the worst case scenario shown in the diagram above can occur, causing the run time to be on the order of $N^2$ instead. This means that quicksort has a troublesome, but rare, worst case performance scenario.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="choosing-an-algorithm">Choosing an Algorithm</h1>

<p>There are many different algorithms we can use to sort our data, and some of them can be shown mathematically to be more efficient, even in the worst case. So, how should we choose which algorithm to use?</p>
<p>In practice, it really comes down to a variety of factors, based on the amount of data we expect our program to handle, the randomness of the data, and more. The only way to truly know which algorithm is the best is to empirically test all of them and choose the fastest one, but even that approach relies on us predicting the data that our program will be utilizing.</p>
<p>Instead, here are some general guidelines we can use to help us select a sorting algorithm to use in our program.</p>
<ul>
<li>If we know that the data will be nearly sorted, with only a few elements out of place, we can use <strong>bubble sort</strong> to quickly fix those issues. Unlike many other sorting algorithms, it is very easy to modify the bubble sort code to terminate when the data is properly sorted after just a few iterations. While it is rare to find a data set that is nearly sorted, it is an interesting case to be aware of.</li>
<li>If we think our data will be truly random, or if we are not sure we have enough memory to store the data twice, we can use <strong>quicksort</strong> effectively. Since the data is random, we should avoid the worst case scenario that can happen when using quicksort. In most cases quicksort is one of the fastest sorting algorithms when used on real-world data.  In addition, quicksort does not have any additional memory requirements, so it can be used in place without creating a copy of the data.</li>
<li>If we are not sure what features our data will have, but we know we&rsquo;ll have enough memory to store the data twice, then <strong>merge sort</strong> is a good choice. Merge sort guarantees that the performance will be on the order of $N \text{lg}(N)$ regardless of how the data is structured, but it typically requires more memory usage.</li>
<li>Interestingly, if we are dealing with a large set of data that will not fit in memory itself, <strong>merge sort</strong> is also a good choice. Merge sort was originally designed for sorting data stored on multiple removable disks or tapes. Each disk was sorted individually, and then two disks could be merged in sorted order on two more disks. Over time, the entire data set could be sorted by using just a few extra disks, even if it could not all be loaded into the computer at the same time.</li>
</ul>
<p>Of course, the choice of which sorting algorithm to use is one of the most important decisions a programmer can make, and it is a great example of the fact that there are multiple ways to write a program that performs a particular task. Each possible program comes with various performance and memory considerations, and in many cases, there may not be a correct option. Instead, we must rely on our own knowledge and insight to choose the method that we feel would work best in any given situation.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="data-structure-uses">Data Structure Uses</h1>

<p>Throughout this course, we have looked at a few ways we can use the data structures we have already learned to do something useful. In this module, we will look at a few of those examples again, as well as a few more interesting uses of the data structures that we have built.</p>
<h2 id="arrays-and-linked-lists-as-stacks-queues-and-sets">Arrays and Linked Lists as Stacks, Queues, and Sets</h2>
<p>First and foremost, it is important to understand that we can implement many of the simpler data structures such as stacks, queues and sets using both arrays and linked lists. In fact, from a certain point of view, there are only two commonly used containers for data – the array and the linked list. Nearly all other data structures are a variant of one of those two approaches or a combination of both.</p>
<p>Earlier in this chapter, we discussed some of the performance implications that arise when using arrays or linked lists to implement stacks and queues. In practice, we need to understand how we will be using our data in order to choose between the two approaches.</p>
<h2 id="sets-in-compilers-and-interpreters">Sets in Compilers and Interpreters</h2>
<p>One unique use of sets appears in the code of compilers and interpreters. In each case, a programming language can only have one instance of a variable with a given name at any one time. So, we can think of the variables in a program as a set. In the code for a compiler or interpreter, we might find many instances of sets that are used to enforce rules that require each variable or function name to be unique.</p>
<p>Of course, this same property becomes important in even larger data storage structures, such as a relational database. For example, a database may include a column for a username or identification number which must be unique, such that no two entries can be the same. Once again, we can use a set to help enforce that restriction.</p>
<h2 id="hash-tables-as-sets-and-indexers">Hash Tables as Sets and Indexers</h2>
<p>Hash tables are a great example of a data structure that effectively combines arrays and linked lists to increase performance. The best way to understand this is through the analysis of a set implemented using a hash table instead of a linked list.</p>
<p>When we determine if an element is already contained in a set based on a linked list, we must perform a linear search which runs on the order of $N$ time. The same operation performed on a set based on a hash table runs in constant time in the best case. This is because we can use the result of the hash function to jump directly to the bucket where the item should be stored, if it exists.</p>
<p>This same trick is used in large relational databases. If we have a database with a million rows, we can define an <em>index</em> for a column that allows us to quickly jump to entries without searching the entire database. To look up a particular entry using an index, we can calculate its hash, find the entry in the index, and then use the link in that index element to find the record in the database.</p>
<p>Finally, we can also use hash tables to build efficient indexes for large amounts of text data. Consider a textbook, for example. Most textbooks contain an index in the back that gives the page locations where particular terms are discussed. How can we create that index? We can iterate through each word in the textbook, but for each one we will have to search through the existing words in the index to see if that page is already listed for that word. That can be very slow if we must use a linear search through a linked list. However, if we use a hash table to store the index, the process of updating entries can be done in nearly constant time!</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="python-standard-types">Python Standard Types</h1>


<a href="https://www.youtube.com/watch?v=B4vL-QLci8w">YouTube Video</a>

<p>Both Java and Python include standard implementations of each of the data structures we have learned about in this course. While it is very useful and interesting from an academic perspective to build our own linked lists and hash tables, in practice we would rarely do so. In this section, we will briefly introduce the standard library versions of each data structure and provide references to where we can find more information about each one and how to use them.</p>
<h2 id="python">Python</h2>
<p>Python includes many useful data structures as built-in data types. We can use them to build just about any structure we need quickly and efficiently. The <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="external" target="_blank">Python Tutorial</a> has some great information about data structures in Python and how we can use them.</p>
<p>Python includes several data types that are grouped under the heading of <a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range" rel="external" target="_blank">sequence data types</a>, and they all share many operations in common. We&rsquo;ll look at two of the sequence data types: tuples and lists.</p>
<h3 id="tuples">Tuples</h3>
<p>While we have not directly discussed tuples often, it is important to know that Python natively supports tuples as a basic data type. In Python, a <a href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="external" target="_blank">tuple</a> is simply a combination of a number of values separated by commas. They are commonly placed within parentheses, but it is not required.</p>
<p>We can directly access elements in a tuple using the same notation we use for arrays, and we can even unpack tuples into multiple variables or return them from functions. Tuples are a great way to pass multiple values as a single variable.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">tuple1</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">tuple1</span><span class="p">)</span>  <span class="c1"># (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">tuple2</span><span class="p">)</span>  <span class="c1"># (1, 2, 3, 4)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">tuple2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># 1</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">tuple2</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="c1"># 4</span></span></span></code></pre></div><h3 id="lists">Lists</h3>
<p>Python&rsquo;s default data structure for sequences of data is the <a href="https://docs.python.org/3/library/stdtypes.html#list" rel="external" target="_blank">list</a>. In fact, throughout this course, we have been using Python lists as a stand-in for the arrays that are supported by most other languages. Thankfully, lists in Python are much more flexible, since they can be dynamically resized, sliced, and iterated very easily. In terms of performance, a Python list is roughly equivalent to an array in other languages. We can access elements in constant time when the index is known, but inserting and removing from the beginning of the list runs in order of $N$ time since elements must be shifted backwards. This makes them a poor choice for queues and stacks, where elements must be added and removed from both ends of the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span> <span class="c1"># [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">list1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># [&#39;b&#39;, &#39;c&#39;]</span></span></span></code></pre></div><h3 id="deque">Deque</h3>
<p>The Python <a href="https://docs.python.org/3.8/library/collections.html" rel="external" target="_blank">Collections</a> library contains a special class called a deque (pronounced &ldquo;deck&rdquo;, and short for &ldquo;double ended queue&rdquo;) that is a linked list-style implementation that provides much faster constant time inserts and removals from either end of the container. In Python, it is recommended to use the deque data structure when implementing stacks and queues.</p>
<p>In a deque, the ends are referred to as &ldquo;right&rdquo; and &ldquo;left&rdquo;, so there are methods <code>append()</code> and <code>pop()</code> that impact the right side of the container, and <code>appendleft()</code> and <code>popleft()</code> that modify the left side. We can use a combination of those methods to implement both a Stack and a Queue using a deque in Python.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Stack</span>
</span></span><span class="line"><span class="cl"><span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 2 (peek right side)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span> <span class="c1"># 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span> <span class="c1"># 1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Queue</span>
</span></span><span class="line"><span class="cl"><span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># 1 (peek left side)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">())</span> <span class="c1"># 1</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">())</span> <span class="c1"># 2</span></span></span></code></pre></div><h3 id="dictionaries">Dictionaries</h3>
<p>Python also implements a version of the class Map data structure, called a <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="external" target="_blank">dictionary</a>. In Python, a dictionary stores key-value pairs, very similarly to how associative arrays work in other languages. Behind the scenes, it uses a hashing function to efficiently store and retrieve elements, making most operations run in near constant time.</p>
<p>The one limitation with Python dictionaries is that only hashable data types can be used as keys. We cannot use a list or a dictionary as the key for a dictionary in Python. Thankfully, strings, numbers, and most objects that implement a <code>__hash__()</code> and <code>__eq__()</code> method can be used.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s1">&#39;test&#39;</span><span class="p">:</span> <span class="mi">321</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span> <span class="c1"># 123 (get a value)</span>
</span></span><span class="line"><span class="cl"><span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">456</span> <span class="c1"># (add a new entry)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">)</span> <span class="c1"># True (search for entry)</span></span></span></code></pre></div><h3 id="sets">Sets</h3>
<p>Python also includes a built in data type to represent a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="external" target="_blank">set</a>. Just like we saw with our analysis, Python also uses a hash-based implementation to allow us to quickly find elements in the set, and therefore does not keep track of any ordering between the elements. We can easily add or remove elements, and Python uniquely allows us to use the binary operators to compute several set operations such as union and intersection.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">set1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">set2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="mi">2</span> <span class="ow">in</span> <span class="n">set1</span><span class="p">)</span> <span class="c1"># False (check for membership)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="mi">2</span> <span class="ow">in</span> <span class="n">set2</span><span class="p">)</span> <span class="c1"># True (check for membership)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="err">–</span> <span class="n">set2</span><span class="p">)</span> <span class="c1"># {1, 9} (set difference)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="o">|</span> <span class="n">set2</span><span class="p">)</span> <span class="c1"># {1, 3, 5, 7, 9, 2} (union)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="o">&amp;</span> <span class="n">set2</span><span class="p">)</span> <span class="c1"># {3, 5, 7} (intersection)</span></span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="string-builder">String Builder</h1>


  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p>This video was created as part of another course. We have moved this content into CC 310 as a great example of a data structure that exists purely for performance reasons</p>
</div>
</div>

<a href="https://www.youtube.com/watch?v=zcCtPamophM">YouTube Video</a>

<p><a href="/cc310/08-perf-string/10-string-builder/video/">Video Materials</a></p>
<p>In CC 310 we covered various data structures: stacks, sets, lists, queues, and hash tables. When we looked at these structures, we considered how to access elements within the structures, how we would create our own implementation of the structure, and tasks that these structures would be fitting for as well as ill fitting. Throughout this course we will introduce and implement a variety of data structures as we did in CC 310.</p>
<p>We begin this course with an often overlooked structure: strings. By the end of this chapter, we will understand how strings are data structures, how we access elements, what types of tasks are appropriate for strings, and how we can improve on strings in our code.</p>
<h2 id="motivation">Motivation</h2>
<p>In many data science positions, programmers often work with text-based data. Some examples of text-based data include biology for DNA sequencing, social media for sentiment classification, online libraries for citation networks, and many other types of businesses for data analytics. Currently, strings are often used for word embeddings, which determine how similar or dissimilar words are to one another. An industry leading software for this application is Tensorflow for Python, which generated the image below.</p>
<p><a href="#R-image-3907629170179c899ed62604b059852d" class="lightbox-link"><img alt="Word Embeddings Near &lsquo;Python&rsquo;" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/1_word_embedding.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3907629170179c899ed62604b059852d"><img alt="Word Embeddings Near &lsquo;Python&rsquo;" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/1_word_embedding.png"></a></p>
<!--- https://projector.tensorflow.org/ I generated and took this screen shot. --->
<p>In an immense oversimplification, the process used for word embeddings is to read in a large amount of text and then use machine learning algorithms to determine similarity by using the words around each word. This impacts general users like us in search engines, streaming services, dating applications, and much more! For example, if you were to search Python topics in your search results may appear referring to the coding language, the reptile, the comedy troupe, and many more. When we use machine learning to determine word meanings, it is important that the data is first parsed correctly and stored in efficient ways so that we can access elements as needed. Understanding how to work with strings and problems that can arise with them is important to utilizing text successfully.</p>
<p>Reference: <a href="https://projector.tensorflow.org/" rel="external" target="_blank">https://projector.tensorflow.org/</a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of String Builder</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="theory">Theory</h1>


<a href="https://www.youtube.com/watch?v=KII6o4G5I_U">YouTube Video</a>

<p><a href="/cc310/08-perf-string/11-theory/video/">Video Materials</a></p>
<h2 id="what-are-strings">What are Strings?</h2>
<p>Strings are data structures which store an ordered set of characters. Recall that a character can be a: letter, number, symbol, punctuation mark, or white space. Strings can contain any number and any combination of these. As such, strings can be single characters, words, sentences, and even more.</p>
<h2 id="how-do-we-work-with-strings">How do we work with Strings?</h2>
<p>Let&rsquo;s refresh ourselves on how strings work, starting with the example string: <code>s = &quot;Go Cats!&quot;</code>.</p>
<table>
<thead>
<tr>
<th><a href="/cc310/08-perf-string/11-theory/"></a></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Character</td>
<td>G</td>
<td>o</td>
<td></td>
<td>C</td>
<td>a</td>
<td>t</td>
<td>s</td>
<td>!</td>
</tr>
<tr>
<td>Index</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>As with other data structures, we can access elements within the string itself. Using the example above, <code>s[0]</code> would contain the character &lsquo;G&rsquo;, <code>s[1]</code> would contain the character &lsquo;o&rsquo;, <code>s[2]</code> would contain the character &rsquo; &lsquo;, and so on.</p>
<p>We can determine the size of a string by using length functions; in our example, the length of s would be 8. It is also important to note that when dealing with strings, null is not equivalent to &ldquo;&rdquo;. For string <code>s = &quot;&quot;</code>, the length of s would be 0. However for string <code>s = null</code>, accessing the length of s would return an error that null has no length property.</p>
<p>We can also add to strings or append on a surface level; though it is not that simple behind the scenes. The String class is <strong>immutable</strong>. This means that changes will not happen directly to the string; when appending or inserting, code will create a new string to hold that value. More concisely, the state of an immutable object cannot change.</p>
<p>We cannot assign elements of the string directly and more broadly for any immutable object. For example, if we wanted the string from our example to be &lsquo;Go Cat!!&rsquo;, we cannot assign the element through <code>s[6] = '!'</code>. This would result in an item assignment error.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Try It!</div>
  <div class="box-content">

<p>For an example, consider string s = &lsquo;abc&rsquo;. If we then state in code s = s + &lsquo;123&rsquo;, this will create a new place in memory for the new definition of s. We can verify this in code by using the id() function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">string s = &#39;abc&#39;
</span></span><span class="line"><span class="cl">id(s)
</span></span><span class="line"><span class="cl">Output: 140240213073680 #may be different on your personal device
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">string s = s + &#39;123&#39;
</span></span><span class="line"><span class="cl">id(s)
</span></span><span class="line"><span class="cl">Output: 140239945470168 </span></span></code></pre></div></div>
</div>
<p>While on the surface it appears that we are working with the same variable, our code will actually refer to a different one. There are many other immutable data types as well as mutable data types.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Mutable vs. Immutable</div>
  <div class="box-content">

<p>On the topic of immutable, we can also discuss the converse: <strong>mutable</strong> objects. Being a mutable object means that the state of the object can change. In CC310, we often worked with arrays to implement various data structures. Arrays are mutable, so as we add, change, or remove elements from an array, the array changes its state to accommodate the change rather than creating a new location in memory.</p>
<table>
<thead>
<tr>
<th>Data Type</th>
<th>Immutable?</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lists</td>
<td>☐</td>
</tr>
<tr>
<td>Sets</td>
<td>☐</td>
</tr>
<tr>
<td>Byte Arrays</td>
<td>☐</td>
</tr>
<tr>
<td>Dictionaries</td>
<td>☐</td>
</tr>
<tr>
<td>Strings</td>
<td>☑</td>
</tr>
<tr>
<td>Ints</td>
<td>☑</td>
</tr>
<tr>
<td>Floats</td>
<td>☑</td>
</tr>
<tr>
<td>Booleans</td>
<td>☑</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Reference: <a href="http://people.cs.ksu.edu/~rhowell/DataStructures/strings/strings.html" rel="external" target="_blank">http://people.cs.ksu.edu/~rhowell/DataStructures/strings/strings.html</a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Theory</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="memory-example">Memory Example</h1>

<p>Consider the following block of pseudocode:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = &#34;&#34;
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT = RESULT + BASE
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT = RESULT + &#34; &#34;
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT = RESULT + &#34;, &#34; 
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    return RESULT
</span></span><span class="line"><span class="cl">11. end function</span></span></code></pre></div><p>Lets step through the function call with <code>APPENDER(4,'abc')</code> and analyze the memory that the code takes.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Recall that strings are reference variables. As such, string variables hold pointers to values and the value is stored in memory. For the following example, the <code>HEAP</code> refers to what is currently stored in memory and <code>VARIABLE</code> shows the current value of the variable <code>RESULT</code>.</p>
</div>
</div>
<ul>
<li>
<p>Initialization: In line two, we initialize <code>RESULT</code> as an empty string. In the heap, we have the empty string at memory location <code>0x1</code>. Thus, <code>RESULT</code> is holding the pointer <code>0x1</code>.
<a href="#R-image-f11483876cb9bc24c687ea36d573c05c" class="lightbox-link"><img alt="Initialize" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/1mem_map1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f11483876cb9bc24c687ea36d573c05c"><img alt="Initialize" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/1mem_map1.png"></a></p>
</li>
<li>
<p>I = 1: Now we have entered the loop and on line 4, we add more characters to our string. At this point, we would have entry <code>0x2</code> in our heap and our variable <code>RESULT</code> would have the pointer <code>0x2</code>. Continuing through the code, line 5 determines if <code>I</code> is divisible by 2. In this iteration <code>I = 1</code>, so we take the else branch. We again add characters to our string, resulting in a new entry in <code>0x3</code> and our variable <code>RESULT</code> containing the pointer <code>0x3</code>. In total, we have written 8 characters. We then increment <code>I</code> and move to the next iteration.
<a href="#R-image-18808b69973ed2b5a9612aa26b1980ff" class="lightbox-link"><img alt="After 1st loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/1mem_map3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-18808b69973ed2b5a9612aa26b1980ff"><img alt="After 1st loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/1mem_map3.png"></a></p>
</li>
<li>
<p>I = 2: We continue the loop and on line 4, we add more characters to our string. At this point, we would have entry <code>0x4</code> in our heap and our variable <code>RESULT</code> would have the pointer <code>0x4</code>. Continuing through the code, line 5 determines if <code>I</code> is divisible by 2. In this iteration <code>I = 2</code>, so we take the if branch. We again add characters to our string, resulting in a new entry in <code>0x5</code> and our variable <code>RESULT</code> containing the pointer <code>0x5</code>. In this iteration, we have written 17 characters. We then increment <code>I</code> and move to the next iteration of the loop.
<a href="#R-image-ec47e26f6dc1a568aa9127c5e0760806" class="lightbox-link"><img alt="After 2nd loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/1mem_map5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ec47e26f6dc1a568aa9127c5e0760806"><img alt="After 2nd loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/1mem_map5.png"></a></p>
</li>
<li>
<p>I = 3: We continue the loop and on line 4, we add more characters to our string. At this point, we would have entry <code>0x6</code> in our heap and our variable <code>RESULT</code> would have the pointer <code>0x6</code>. Continuing through the code, line 5 determines if <code>I</code> is divisible by 2. In this iteration <code>I = 3</code>, so we take the if branch. We again add characters to our string, resulting in a new entry in <code>0x7</code> and our variable <code>RESULT</code> containing the pointer <code>0x7</code>. In this iteration, we have written 26 characters. We then increment <code>I</code> and thus <code>I = 4</code> breaking out of the loop.
<a href="#R-image-c7a6a34e9fb356a404b0087dcf77c7b6" class="lightbox-link"><img alt="After 3rd loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/1mem_map7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c7a6a34e9fb356a404b0087dcf77c7b6"><img alt="After 3rd loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/1mem_map7.png"></a></p>
</li>
</ul>
<p>We can do some further analysis of the memory that is required for this particular block.</p>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Memory Entries</th>
<th>Total Character Copies</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>8 + 17 = 25</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>25 + 26 = 51</td>
</tr>
<tr>
<td>4</td>
<td>9</td>
<td>51 + 35 = 86</td>
</tr>
<tr>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>n</td>
<td>2n + 1</td>
<td>(9n<sup>2</sup> + 7n)/2</td>
</tr>
</tbody>
</table>
<p>You need not worry about creating the equations! Based on this generalization, if the user wanted to do 100K iterations, say for gene sequencing, there would be (2x100,000 - 1) = 200,001 memory entries and (9x100,000<sup>2</sup> + 7x100,000)/2 = 45 billion character copies. This behavior is not exclusive to strings; this will occur for any immutable type.</p>
<p>While this example is contrived, it is not too far off the mark. Another caveat to this analysis is that, depending on our programming language, there will be a periodic &lsquo;memory collection&rsquo;; there wont be 200K memory addresses occupied at one time. Writing to memory in this way can be costly in terms of time, which in industry is money.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="limitations-in-python">Limitations in Python</h1>


<a href="https://www.youtube.com/watch?v=gsE16hh3iQQ">YouTube Video</a>

<p><a href="/cc310/08-perf-string/13-python-memory/video/">Video Materials</a></p>
<p>As a result of being immutable, strings can be cumbersome to work with in certain applications. When working with long strings or strings that we are continually appending to, such as in the memory example, we end up creating a lot of sizable copies.</p>
<p>Recall from the memory example the block of pseudocode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = &#34;&#34;
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT = RESULT + BASE
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT = RESULT + &#34; &#34;
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT = RESULT + &#34;, &#34; 
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    return RESULT
</span></span><span class="line"><span class="cl">11. end function</span></span></code></pre></div><p>In this example, what if we changed <code>RESULT</code> to a mutable type, such as a StringBuilder in Java. Once the loop is done, we can cast <code>RESULT</code> to a string. By changing just the one aspect of the code, we would make only one copy of <code>RESULT</code> and have far less character copies.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Java specifically has a <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html" rel="external" target="_blank">StringBuilder class</a> which was created for this precise reason.</p>
</div>
</div>
<p>Consider the following, and note the slight changes on lines 2, 4, 6, 8 and the additional line 10.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER<span class="nb">_</span>LIST(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = []
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT.APPEND(BASE) 
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT.APPEND(&#34; &#34;) 
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT.APPEND(&#34;, &#34;)  
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    RESULT = &#34;&#34;.JOIN(RESULT)
</span></span><span class="line"><span class="cl">11.    return RESULT
</span></span><span class="line"><span class="cl">12. end function</span></span></code></pre></div><p>Now consider APPENDER_LIST(4,&lsquo;abc&rsquo;)</p>
<ul>
<li>
<p>Initialization: We start by initializing the empty array. <code>RESULT</code> will hold the pointer <code>0x1</code>.
<a href="#R-image-91339e3f678d6e218703dbf9428a56eb" class="lightbox-link"><img alt="Initialize" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/1SB_mem_map1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-91339e3f678d6e218703dbf9428a56eb"><img alt="Initialize" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/1SB_mem_map1.png"></a></p>
</li>
<li>
<p>I = 1: Now we have entered the loop and on line 4, we add more characters to our array. At this point, we would have only entry <code>0x1</code> in our heap and our variable <code>RESULT</code> would have the pointer <code>0x1</code>. Continuing through the code, line 5 determines if <code>I</code> is divisible by 2. In this iteration <code>I = 1</code>, so we take the else branch. We again add characters to our array.  In total, we have written 5 characters. We then increment I and move to the next iteration.<br>
<a href="#R-image-f6560d0fe1b7009dd6a3d7303009b87a" class="lightbox-link"><img alt="After 1st Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/1SB_mem_map3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f6560d0fe1b7009dd6a3d7303009b87a"><img alt="After 1st Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/1SB_mem_map3.png"></a></p>
</li>
<li>
<p>I = 2: We continue the loop and on line 4, we add more characters to our array. We still have just one entry in memory and our pointer is still <code>0x1</code>. In this iteration, we have written 4 characters. We then increment <code>I</code> and move to the next iteration of the loop.
<a href="#R-image-157c13e230e39e57a2b827ff8441b27b" class="lightbox-link"><img alt="After 2nd Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/1SB_mem_map5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-157c13e230e39e57a2b827ff8441b27b"><img alt="After 2nd Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/1SB_mem_map5.png"></a></p>
</li>
<li>
<p>I = 3: We continue the loop and on line 4, we add more characters to our array.  In this iteration, we have written 5 characters. We then increment <code>I</code> and thus <code>I = 4</code> breaking out of the loop.
<a href="#R-image-857c8766684778dedf338e9771c4c70b" class="lightbox-link"><img alt="After 3rd Loop" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/1SB_mem_map7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-857c8766684778dedf338e9771c4c70b"><img alt="After 3rd Loop" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/1SB_mem_map7.png"></a></p>
</li>
<li>
<p>Post-Loop: Once the loop breaks, we join the array to create the final string. This creates a new place in memory and changes RESULT to contain the pointer <code>0x2</code>.
<a href="#R-image-ef7a6a9f27bb68b80125442ca8bf8937" class="lightbox-link"><img alt="After Loop Breaks" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/1SB_mem_map8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ef7a6a9f27bb68b80125442ca8bf8937"><img alt="After Loop Breaks" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/1SB_mem_map8.png"></a></p>
</li>
</ul>
<p>We can do some further analysis of the memory that is required for this particular block.</p>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Memory Entries</th>
<th>Character Copies</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>17</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>26</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>35</td>
</tr>
<tr>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>n</td>
<td>2</td>
<td>9n - 1</td>
</tr>
</tbody>
</table>
<p>Again, you need not worry about creating these equations for this course. To illustrate the improvement even more explicitly, let&rsquo;s consider our previous example with 100K iterations. For APPENDER there were (2x100,000 - 1) = 200,001 memory entries and (9x100,000<sup>2</sup> + 7x100,000)/2 = 45 billion character copies. For APPENDER_LIST we now have just 2 memory entries and (9x100,000 - 1) = 899,999 character copies. This dramatic improvement was a result of changing our data structure ever so slightly.</p>
<p>Reference: <a href="http://people.cs.ksu.edu/~rhowell/DataStructures/strings/stringbuilders.html" rel="external" target="_blank">http://people.cs.ksu.edu/~rhowell/DataStructures/strings/stringbuilders.html</a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Limitations in Python</h1>
    
    
          </section>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p>In this module, we reviewed each of the data structures we have explored in this class. Most importantly, we looked at how they compare in terms of performance and discussed some of the best and most efficient ways to use them in our programs.</p>
<p>Using that information, we introduced the standard collection libraries for both Java and Python, and saw how those professional implementations closely follow the same ideas and analysis that we saw in our own structures. While the professional structures may have many more features and more complex code, at the core they still work just like the structures we learned how to build from scratch.</p>
<p>One of the best traits of a good programmer is knowing how to most effectively use the tools made available to us through the programming languages and libraries we have chosen to use. The goal of this class is to give us the background we need to understand how the various collection data structures we can choose from work, so that we can use them in the most effective way to build useful and efficient programs.</p>

<a href="https://www.youtube.com/watch?v=MJ1tkFIDEAA">YouTube Video</a>

<p><a href="/cc310/08-perf-string/14-summary/video/">Video Materials</a></p>
<p>To start this course, we have looked into strings. They are a very natural way to represent data, especially in real world applications. Often though, the datapoints can be very large and require multiple modifications. We also examined how strings work: element access, retrieving the size, and modifying them. We looked into some alternatives which included StringBuilders for Java and character arrays for Python.</p>
<p>To really understand this point, we have included a comparison. We have implemented the APPENDER and APPENDER_LIST functions in both Python and Java. For the Java implementation, we utilized StringBuilders.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = &#34;&#34;
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT = RESULT + BASE
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT = RESULT + &#34; &#34;
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT = RESULT + &#34;, &#34; 
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    return RESULT
</span></span><span class="line"><span class="cl">11. end function</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function APPENDER<span class="nb">_</span>LIST(NUMBER, BASE)
</span></span><span class="line"><span class="cl">2.     RESULT = []
</span></span><span class="line"><span class="cl">3.     loop I from 1 to NUMBER
</span></span><span class="line"><span class="cl">4.         RESULT.APPEND(BASE) 
</span></span><span class="line"><span class="cl">5.         if I MOD 2 = 0
</span></span><span class="line"><span class="cl">6.             RESULT.APPEND(&#34; &#34;) 
</span></span><span class="line"><span class="cl">7.         else
</span></span><span class="line"><span class="cl">8.             RESULT.APPEND(&#34;, &#34;)  
</span></span><span class="line"><span class="cl">9.     end loop
</span></span><span class="line"><span class="cl">10.    RESULT = &#34;&#34;.JOIN(RESULT)
</span></span><span class="line"><span class="cl">11.    return RESULT
</span></span><span class="line"><span class="cl">12. end function</span></span></code></pre></div>
  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>For the tests of 10<sup>8</sup> and 10<sup>9</sup> in Java, the string implementation took over 24 hours and the StringBuilder implementation ran out of memory. For these reasons, they are omitted from the figure.</p>
</div>
</div>
<p><a href="#R-image-eba1702a4166c6add7df635379c65ab1" class="lightbox-link"><img alt="Python Time" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/315_stringsTime_python.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-eba1702a4166c6add7df635379c65ab1"><img alt="Python Time" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/315_stringsTime_python.png"></a>
<a href="#R-image-6b047b5f01d3915f3bb2dd66cb204136" class="lightbox-link"><img alt="Java Time" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/13/315_stringsTime_java.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6b047b5f01d3915f3bb2dd66cb204136"><img alt="Java Time" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/13/315_stringsTime_java.png"></a></p>
<p>These figures compare Strings and lists for Python and Strings and StringBuilders for Java. The intention of these is not to compare Python and Java.</p>
<p>In both languages, we see that the string function and the respective alternative performed comparably until approximately 10<sup>6</sup> (1,000,000 characters). Again, these are somewhat contrived examples with the intention of understanding side effects of using strings.</p>
<p>As we have discussed, modern coding languages will have clean up protocols and memory management strategies. With the intention of this class in mind, we will not discuss the memory analysis in practice.</p>
<p>When modifying strings we need to be cognizant of how often we will be making changes and how large those changes will be. If we are just accessing particular elements or only doing a few modifications then using plain strings is a reasonable solution. However, if we are looking to build our own DNA sequence this is not a good way to go as strings are immutable.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Summary</h1>
    
    
          </section>
    
    
          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc310/commit/b806b39e06b3286e793d1e17e7c90e68a994e4ce">Jul 3, 2024</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc310/js/clipboard.min.js?1720728605" defer></script>
    <script src="/cc310/js/perfect-scrollbar.min.js?1720728605" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cc310/js/mathjax/tex-mml-chtml.js?1720728605"></script>
    <script src="/cc310/js/theme.js?1720728605" defer></script>
  </body>
</html>
