




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Searching and Sorting :: CC 310 Textbook</title>
    <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/</link>
    <description>Welcome! This page is the main page for Searching and Sorting</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 Jun 2024 09:14:34 -0500</lastBuildDate>
    <atom:link href="https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Searching</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/1-searching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/1-searching/</guid>
      <description>In this course, we are learning about many different ways we can store data in our programs, using arrays, queues, stacks, lists, maps, and more. We’ve already covered a few of these data structures, and we’ll learn about the others in upcoming modules. Before we get there, we should also look at a couple of the most important operations we can perform on those data structures.&#xA;Consider the classic example of a data structure containing information about students in a school.</description>
    </item>
    <item>
      <title>Linear Search</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/2-linear-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/2-linear-search/</guid>
      <description>When searching for a number in an unordered array, our search algorithms are typically designed as functions that take two parameters:&#xA;the number to find, and the array to search. Our search functions then return an index to the number within the array.&#xA;In this module, we will develop a couple of examples of searching an array for a specific number.&#xA;Finding the first occurrence of a number in an unordered array is a fairly straightforward process.</description>
    </item>
    <item>
      <title>Searching for a Value</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/3-searching-for-a-value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/3-searching-for-a-value/</guid>
      <description>To search for a single number in our array, we will use a loop to search each location in the array until we find the number. The general idea is to iterate over all the elements in the array until we either find the number we are searching for or there are no other elements in the array.&#xA;function FIND(NUMBER, ARRAY)&#x9;(1) loop INDEX from 0 to size of ARRAY - 1 (2) if ARRAY[INDEX] == NUMBER&#x9;(3) return INDEX&#x9;(4) end if&#x9;(5) end for&#x9;(6) return -1&#x9;(7) end function&#x9;(8)As we can see in line 1, the function takes both a number and array parameter.</description>
    </item>
    <item>
      <title>Searching for the Last Value</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/4-searching-for-the-last-value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/4-searching-for-the-last-value/</guid>
      <description>Our find algorithm above will find the first instance of number in the array and return the index of that instance. However, we might also be interested in finding the last instance of number in array. Looking at our original find algorithm, it should be easy to find the last value by simply searching the array in reverse order, as shown in the following figure.&#xA;We will use the same example as above, except we will start searching backwards from the end of the array.</description>
    </item>
    <item>
      <title>Recursive Linear Search</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/5-recursive-linear-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/5-recursive-linear-search/</guid>
      <description>We looked at an iterative version of the find function above. But what would it take to turn that function into a recursive function? While for this particular function, there is not a lot to be gained from the recursive version, it is still instructive to see how we would do it. We will find recursive functions more useful later on in the module.&#xA;In this case, to implement a recursive version of the function, we need to add a third parameter, index, to tell us where to check in the array.</description>
    </item>
    <item>
      <title>Searching for a Minimum</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/6-searching-for-a-minimum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/6-searching-for-a-minimum/</guid>
      <description>We may also want to search through a data structure to find an item with a specific property. For example, we could search for the student with the maximum age, or the minimum GPA. For this example, let’s consider the case where we’d like to find the minimum value in an array of integers.&#xA;Searching for the minimum number in an unordered array is a different problem than searching for a specific number.</description>
    </item>
    <item>
      <title>Linear Search Time Complexity</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/7-linear-search-time-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/7-linear-search-time-complexity/</guid>
      <description>We’ve examined many different versions of a linear search algorithm. We can find the first occurrence of a number in an array, the last occurrence of that number, or a value with a particular property, such as the minimum value. Each of these are examples of a linear search, since we look at each element in the container sequentially until we find what we are looking for.&#xA;So, what would be the time complexity of this process?</description>
    </item>
    <item>
      <title>Sorting</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/8-sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/8-sorting/</guid>
      <description>Sorting is the process we use to organize an ordered container in a way that we understand what the ordering of the values represents. Recall that an ordered container just enforces an ordering between values, but that ordering may appear to be random. By sorting an ordered container, we can enforce a specific ordering on the elements in the container, allowing us to more quickly find specific elements as we’ll see later in this chapter.</description>
    </item>
    <item>
      <title>Selection Sort</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/9-selection-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/9-selection-sort/</guid>
      <description>The first sorting algorithm we’ll learn about is selection sort. The basic idea behind selection sort is to search for the minimum value in the whole container, and place it in the first index. Then, repeat the process for the second smallest value and the second index, and so on until the container is sorted.&#xA;Wikipedia includes a great animation that shows this process:&#xA;^[File:Selection-Sort-Animation.gif. (2016, February 12). Wikimedia Commons, the free media repository.</description>
    </item>
    <item>
      <title>Selection Sort Pseudocode</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/10-selection-sort-pseudocode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/10-selection-sort-pseudocode/</guid>
      <description>To describe our selection sort algorithm, we can start with these basic preconditions and postconditions.&#xA;Preconditions:&#xA;The array stores a type of elements which can be ordered. Postconditions:&#xA;The array will be sorted in ascending order. We can then represent this algorithm using the following pseudocode.&#xA;function SELECTIONSORT(ARRAY)&#x9;(1) loop INDEX from 0 to size of ARRAY – 2&#x9;(2) MININDEX = 0&#x9;(3) # find minimum index&#x9;loop INDEX2 from INDEX to size of ARRAY – 1&#x9;(4) if ARRAY[INDEX2] &lt; ARRAY[MININDEX] then&#x9;(5) MININDEX = INDEX&#x9;(6) end if&#x9;(7) end loop&#x9;(8) # swap elements TEMP = ARRAY[MININDEX]&#x9;(9) ARRAY[MININDEX] = ARRAY[INDEX]&#x9;(10) ARRAY[INDEX] = TEMP&#x9;(11) end loop&#x9;(12) end function&#x9;(13)In this code, we begin by looping through every element in the array except the last one, as seen on line 2.</description>
    </item>
    <item>
      <title>Selection Sort Time Complexity</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/11-selection-sort-time-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/11-selection-sort-time-complexity/</guid>
      <description>Let’s look at the time complexity of the selection sort algorithm, just so we can get a feel for how much time this operation takes.&#xA;First, we must determine if there is a worst-case input for selection sort. Can we think of any particular input which would require more steps to complete?&#xA;In this case, each iteration of selection sort will look at the same number of elements, no matter what they are.</description>
    </item>
    <item>
      <title>Bubble Sort</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/12-bubble-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/12-bubble-sort/</guid>
      <description>Next, let’s look at another sorting algorithm, bubble sort. The basic idea behind bubble sort is to continuously iterate through the array and swap adjacent elements that are out of order. As a side effect of this process, the largest element in the array will be “bubbled” to the end of the array after the first iteration. Subsequent iterations will do the same for each of the next largest elements, until eventually the entire list is sorted.</description>
    </item>
    <item>
      <title>Bubble Sort Pseudocode</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/13-bubble-sort-pseudocode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/13-bubble-sort-pseudocode/</guid>
      <description>To describe our bubble algorithm, we can start with these basic preconditions and postconditions.&#xA;Preconditions:&#xA;The array stores a type of elements which can be ordered. Postconditions:&#xA;The array will be sorted in ascending order. We can then represent this algorithm using the following pseudocode.&#xA;function BUBBLESORT(ARRAY)&#x9;(1) # loop through the array multiple times loop INDEX from 0 to size of ARRAY – 1&#x9;(2) # consider every pair of elements except the sorted ones loop INDEX2 from 0 to size of ARRAY – 2 – INDEX&#x9;(3) if ARRAY[INDEX2] &gt; ARRAY[INDEX2 + 1] then&#x9;(4) # swap elements if they are out of order TEMP = ARRAY[INDEX2]&#x9;(5) ARRAY[INDEX2] = ARRAY[INDEX2 + 1]&#x9;(6) ARRAY[INDEX2 + 1] = TEMP&#x9;(7) end if end loop end loop end functionIn this code, we begin by looping through every element in the array, as seen on line 2.</description>
    </item>
    <item>
      <title>Bubble Sort Time Complexity</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/14-bubble-sort-time-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/14-bubble-sort-time-complexity/</guid>
      <description>Once again, let’s look at the time complexity of the bubble sort algorithm and see how it compares to selection sort.&#xA;Bubble sort is a bit trickier to analyze than selection sort, because there are really two parts to the algorithm:&#xA;The number of comparisons, and The number of swaps. Let’s look at each one individually. First, is there a way to reduce the number of comparisons made by this algorithm just by changing the input?</description>
    </item>
    <item>
      <title>Merge Sort</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/15-merge-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/15-merge-sort/</guid>
      <description>Another commonly used sorting algorithm is merge sort. Merge sort uses a recursive, divide and conquer approach to sorting, which makes it very powerful. It was actually developed to handle sorting data sets that were so large that they couldn’t fit on a single memory device, way back in the early days of computing.&#xA;The basic idea of the merge sort algorithm is as follows:&#xA;If the container only contains one or two elements, we can quickly sort that container by swapping the elements if needed.</description>
    </item>
    <item>
      <title>Merge Sort Pseudocode</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/16-merge-sort-pseudocode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/16-merge-sort-pseudocode/</guid>
      <description>Now that we’ve seen how merge sort works by going through an example, let’s look at the pseudocode of a merge sort function.&#xA;function MERGESORT(ARRAY, START, END)&#x9;(1) # base case size == 1&#x9;if END - START + 1 == 1 then&#x9;(2)&#x9;return&#x9;(3) end if&#x9;(4) # base case size == 2 if END - START + 1 == 2 then&#x9;(5) # check if elements are out of order if ARRAY[START] &gt; ARRAY[END] then&#x9;(6) # swap if so TEMP = ARRAY[START]&#x9;(7) ARRAY[START] = ARRAY[END]&#x9;(8) ARRAY[END] = TEMP&#x9;(9) end if&#x9;(10) return&#x9;(11) end if&#x9;(12) # find midpoint HALF = int((START + END) / 2)&#x9;(13) # sort first half MERGESORT(ARRAY, START, HALF)&#x9;(14) # sort second half MERGESORT(ARRAY, HALF + 1, END)&#x9;(15) # merge halves MERGE(ARRAY, START, HALF, END)&#x9;(16) end function&#x9;(17)This function is a recursive function which has two base cases.</description>
    </item>
    <item>
      <title>Merge Sort Time Complexity</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/</guid>
      <description>Now that we’ve reviewed the pseudocode for the merge sort algorithm, let’s see if we can analyze the time it takes to complete. Analyzing a recursive algorithm requires quite a bit of math and understanding to do it properly, but we can get a pretty close answer using a bit of intuition about what it does.&#xA;For starters, let’s consider a diagram that shows all of the different recursive calls made by merge sort, as shown below.</description>
    </item>
    <item>
      <title>Quicksort</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/18-quicksort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/18-quicksort/</guid>
      <description>The last sorting algorithm we will review in this module is quicksort. Quicksort is another example of a recursive, divide and conquer sorting algorithm, and at first glance it may look very similar to merge sort. However, quicksort uses a different process for dividing the array, and that can produce some very interesting results.&#xA;The basic idea of quicksort is as follows:&#xA;Choose a pivot value, called pivotValue. This value could be any random value in the array.</description>
    </item>
    <item>
      <title>Quicksort Pseudocode</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/19-quicksort-pseudocode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/19-quicksort-pseudocode/</guid>
      <description>Now that we’ve seen an example of how quicksort works, let’s walk through the pseudocode of a quicksort function. The function itself is very simple, as shown below.&#xA;function QUICKSORT(ARRAY, START, END)&#x9;(1) # base case size &lt;= 1&#x9;if START &gt;= END then&#x9;(2)&#x9;return&#x9;(3) end if&#x9;(4) PIVOTINDEX = PARTITION(ARRAY, START, END)&#x9;(5) QUICKSORT(ARRAY, START, PIVOTINDEX – 1)&#x9;(6) QUICKSORT(ARRAY, PIVOTINDEX + 1, END)&#x9;(7) end function&#x9;(8)This implementation of quicksort uses a simple base case on lines 2 through 4 to check if the array is either empty, or contains one element.</description>
    </item>
    <item>
      <title>Quicksort Time Complexity</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/20-quicksort-time-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/20-quicksort-time-complexity/</guid>
      <description>To wrap up our analysis of the quicksort algorithm, let’s take a look at the time complexity of the algorithm. Quicksort is a very difficult algorithm to analyze, especially since the selection of the pivot value is random and can greatly affect the performance of the algorithm. So, we’ll talk about quicksort’s time complexity in terms of two cases, the worst case and the average case. Let’s look at the average case first</description>
    </item>
    <item>
      <title>Performance of Sorting Algorithms</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/21-performance-of-sorting-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/21-performance-of-sorting-algorithms/</guid>
      <description>We introduced four sorting algorithms in this chapter: selection sort, bubble sort, merge sort, and quicksort. In addition, we performed a basic analysis of the time complexity of each algorithm. In this section, we’ll revisit that topic and compare sorting algorithms based on their performance, helping us understand what algorithm to choose based on the situation.&#xA;Overall Comparison The list below shows the overall result of our time complexity analysis for each algorithm.</description>
    </item>
    <item>
      <title>Binary Search</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/22-binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/22-binary-search/</guid>
      <description>Now that we’ve learned how to sort the data in our container, let’s go back and revisit the concept of searching once again. Does our approach change when we know the data has been sorted?&#xA;Our intuition tells us that it should. Recall that we discussed how much easier it would be to find a particular paper in a sorted filing cabinet rather than just searching through a random pile of papers on the floor.</description>
    </item>
    <item>
      <title>Iterative Binary Search</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/23-iterative-binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/23-iterative-binary-search/</guid>
      <description>The binary search algorithm is easily implemented in both an iterative and recursive function. We’ll look at both versions and see how they compare.&#xA;The pseudocode for an iterative version of binary search is shown below.&#xA;function BINARYSEARCH(ARRAY, VALUE)&#x9;(1) START = 0&#x9;(2) END = size of ARRAY - 1&#x9;(3) loop while START &lt;= END&#x9;(4) MIDDLE = INT((START + END) / 2)&#x9;(5) if ARRAY[MIDDLE] == VALUE then&#x9;(6) return MIDDLE&#x9;(7) else if ARRAY[MIDDLE] &gt; VALUE then&#x9;(8) END = MIDDLE – 1&#x9;(9) else if ARRAY[MIDDLE] &lt; VALUE then&#x9;(10) START = MIDDLE + 1&#x9;(11) end if&#x9;(12) end loop&#x9;(13) return -1&#x9;(14) end function&#x9;(15)This function starts by setting the initial values of start and end on lines 2 and 3 to the first and last indexes in the array, respectively.</description>
    </item>
    <item>
      <title>Recursive Binary Search</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/24-recursive-binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/24-recursive-binary-search/</guid>
      <description>The recursive implementation of binary search is very similar to the iterative approach. However, this time we also include both start and end as parameters, which we update at each recursive call. The pseudocode for a recursive binary search is shown below.&#xA;function BINARYSEARCHRECURSE(ARRAY, VALUE, START, END)&#x9;(1) # base case if START &gt; END then&#x9;(2) return -1&#x9;(3) end if&#x9;(4) MIDDLE = INT((START + END) / 2)&#x9;(5) if ARRAY[MIDDLE] == VALUE then&#x9;(6) return MIDDLE&#x9;(7) else if ARRAY[MIDDLE] &gt; VALUE then&#x9;(8) return BINARYSEARCHRECURSE(ARRAY, VALUE, START, MIDDLE – 1)&#x9;(9)&#x9;else if ARRAY[MIDDLE] &lt; VALUE then&#x9;(10) return BINARYSEARCHRECURSE(ARRAY, VALUE, MIDDLE + 1, END)&#x9;(11) end if&#x9;(12) end function&#x9;(13)The recursive version moves the loop’s termination condition to the base case, ensuring that it returns -1 if the start index is greater than the end index.</description>
    </item>
    <item>
      <title>Binary Search Time Complexity</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/25-binary-search-time-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/25-binary-search-time-complexity/</guid>
      <description>Analyzing the time complexity of binary search is similar to the analysis done with merge sort. In essence, we must determine how many times it must check the middle element of the array.&#xA;In the worst case, it will continue to do this until it has determined that the value is not present in the array at all. Any time that our array doesn’t contain our desired value would be our worst-case input.</description>
    </item>
    <item>
      <title>The Importance of Sorting</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/26-the-importance-of-sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/26-the-importance-of-sorting/</guid>
      <description>Let’s go back and look at the performance of our sorting algorithms, now that we know how quickly binary search can find a particular value in an array. Let’s add the function $\text{lg}(N)$ to our graph from earlier, shown below.&#xA;As we can see, the function $\text{lg}(N)$ is even smaller than $N$. So performing a binary search is much faster than a linear search, which we already know runs in the order of $N$ time.</description>
    </item>
    <item>
      <title>Searching and Sorting Summary</title>
      <link>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/27-searching-and-sorting-summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/7-searching-and-sorting/27-searching-and-sorting-summary/</guid>
      <description>In this chapter, we learned how to search for values in an array using a linear search method. Then, we explored four different sorting algorithms, and compared them based on their time complexity. Finally, we learned how we can use a sorted array to perform a faster binary search and saw how we can increase our performance by sorting our array before searching in certain situations.&#xA;Searching and sorting are two of the most common operations performed in computer programs, and it is very important to have a deep understanding of how they work.</description>
    </item>
  </channel>
</rss>