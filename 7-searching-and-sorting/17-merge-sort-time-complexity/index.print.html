




	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CC 310 Textbook">
    <meta name="author" content="Russell Feldhausen">
    <title>Merge Sort Time Complexity :: CC 310 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/index.html" rel="canonical" type="text/html" title="Merge Sort Time Complexity :: CC 310 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/index.xml" rel="alternate" type="application/rss+xml" title="Merge Sort Time Complexity :: CC 310 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/tele.html" rel="alternate" type="text/html" title="Merge Sort Time Complexity :: CC 310 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/embed.html" rel="alternate" type="text/html" title="Merge Sort Time Complexity :: CC 310 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/fontawesome-all.min.css?1694711082" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cc310/css/fontawesome-all.min.css?1694711082" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/nucleus.css?1694711082" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/auto-complete.css?1694711082" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cc310/css/auto-complete.css?1694711082" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/perfect-scrollbar.min.css?1694711082" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/fonts.css?1694711082" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cc310/css/fonts.css?1694711082" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/theme.css?1694711082" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/theme-auto.css?1694711082" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/variant.css?1694711082" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/print.css?1694711082" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/format-print.css?1694711082" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/ie.css?1694711082" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/url.js?1694711082"></script>
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/variant.js?1694711082"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cc310/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cc310/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cc310/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/custom.css?1694711082" rel="stylesheet">

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" class="topbar-link" title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cc310/index.html"><span itemprop="name">CC 310 Textbook</span></a><meta itemprop="position" content="1"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/index.html"><span itemprop="name">Searching and Sorting</span></a><meta itemprop="position" content="2"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Merge Sort Time Complexity</span><meta itemprop="position" content="3"></li>
            </ol>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="merge-sort-time-complexity">Merge Sort Time Complexity</h1>

<p>Now that we&rsquo;ve reviewed the pseudocode for the merge sort algorithm, let&rsquo;s see if we can analyze the time it takes to complete. Analyzing a recursive algorithm requires quite a bit of math and understanding to do it properly, but we can get a pretty close answer using a bit of intuition about what it does.</p>
<p>For starters, let&rsquo;s consider a diagram that shows all of the different recursive calls made by merge sort, as shown below.</p>
<p>
<a href="#image-c808f4af29340122dda39ccec4eff415" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/../../images/7/7.17.mergetree.png" alt="Merge Sort Time Complexity Diagram 1" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-c808f4af29340122dda39ccec4eff415">
<img src="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/../../images/7/7.17.mergetree.png" alt="Merge Sort Time Complexity Diagram 1" class="lightbox-image" loading="lazy">
</a></p>
<p>The first thing we should do is consider the worst-case input for merge sort. What would that look like? Put another way, would the values or the ordering of those values change anything about how merge sort operates?</p>
<p>The only real impact that the input would have is on the number of swaps made by merge sort. If we had an input that caused each of the base cases with exactly two elements to swap them, that would be a few more steps than any other input. Consider the highlighted entries below.</p>
<p>
<a href="#image-7e238fd14e823d550c07721dd382be5b" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/../../images/7/7.17.mergetree2.png" alt="Merge Sort Time Complexity Diagram 2" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-7e238fd14e823d550c07721dd382be5b">
<img src="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/../../images/7/7.17.mergetree2.png" alt="Merge Sort Time Complexity Diagram 2" class="lightbox-image" loading="lazy">
</a></p>
<p>If each of those pairs were reversed, we&rsquo;d end up doing that many swaps. So, how many swaps would that be? As it turns out, a good estimate would be $N / 2$ times. If we have an array with exactly 16 elements, there are at most 8 swaps we could make. With 10 elements, we can make at most 4. So, the number of swaps is on the order of N time complexity.</p>
<p>What about the merge operation? How many steps does that take? This is a bit trickier to answer, but let&rsquo;s look at each row of the diagram above. Across all of the calls to merge sort on each row, we&rsquo;ll end up merging all $N$ elements in the original array at least once. Therefore, we know that it would take around $N$ steps for each row in the diagram. We&rsquo;ll just need to figure out how many rows there are.</p>
<p>A better way to phrase that question might be &ldquo;how many times can we recursively divide an array of $N$ elements in half?&rdquo; As it turns out, the answer to that question lies in the use of the logarithm.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<h1 id="logarithm">Logarithm</h1>
<p>The logarithm is the inverse of exponentiation. For example, we could have the exponentiation formula:</p>
<p>$$
\text{base}^{\text{exponent}} = \text{power}
$$</p>
<p>The inverse of that would be the logarithm
$$
\text{log}_{\text{base}}(\text{power}) = \text{exponent}
$$</p>
<p>So, if we know a value and base, we can determine the exponent required to raise that base to the given value.</p>
</div>
</div>
<p>In this case, we would need to use the logarithm with base $2$, since we are dividing the array in half each time. So, we would say that the number of rows in that diagram, or the number of levels in our tree would be on the order of $\text{log}_2(N)$. In computer science, we typically write $\text{log}_2$ as $\text{lg}$, so we&rsquo;ll say it is on the order of $\text{lg}(N)$.</p>
<p>To get an idea of how that works, consider the case where the array contains exactly $16$ elements. In that case, the value $\text{lg}(16)$ is $4$, since $2^4 = 16$. If we use the diagram above as a model, we can draw a similar diagram for an array containing $16$ elements and find that it indeed has $4$ levels.</p>
<p>If we double the size of the array, we&rsquo;ll now have $32$ elements. However, even by doubling the size of the array, the value of $\text{lg}(32)$ is just $5$, so it has only increased by $1$. In fact, each time we double the size of the array, the value of $\text{lg}(N)$ will only go up by $1$.</p>
<p>With that in mind, we can say that the merge operation runs on the order of $N * \text{lg}(N)$ time. That is because there are ${\text{lg}(N)}$ levels in the tree, and each level of the tree performs $N$ operations to merge various parts of the array together. The diagram below gives a good graphical representation of how we can come to that conclusion.</p>
<p>
<a href="#image-b7282278cde4555ad7d2c5bf35247a30" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/../../images/7/7.17.mergetree3.png" alt="Merge Sort Time Complexity Diagram 3" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-b7282278cde4555ad7d2c5bf35247a30">
<img src="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/../../images/7/7.17.mergetree3.png" alt="Merge Sort Time Complexity Diagram 3" class="lightbox-image" loading="lazy">
</a></p>
<p>Putting it all together, we have $N/2$ swaps, and $N * \text{lg}(N)$ steps for the merge. Since the value $N * \text{lg}(N)$ is larger than $N$, we would say that total running time of merge sort is on the order of $N * \text{lg}(N)$.</p>
<p>Later on in this chapter we&rsquo;ll discuss how that compares to the running time of selection sort and bubble sort and how that impacts our programs.</p>

            <footer class="footline">

            </footer>
          </article>


        </div>
      </main>
    
<div class="git-footer">
<p class="theme-version-footer">5.18.0</p>
<p>Last modified by: 
            <i class='fas fa-user'></i> Russell Feldhausen
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cc/310/generic/textbook/-/commit/301ec8aaa3405c30b07aa146ef1fa7f85a5af97c">Aug 17, 2021</a>
</p>
</div>

    
    </div>
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/clipboard.min.js?1694711084" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/perfect-scrollbar.min.js?1694711084" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/theme.js?1694711084" defer></script>
  </body>
</html>
