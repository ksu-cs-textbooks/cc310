




	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CC 310 Textbook">
    <meta name="author" content="Russell Feldhausen">
    <title>Merge Sort Pseudocode :: CC 310 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/16-merge-sort-pseudocode/index.html" rel="canonical" type="text/html" title="Merge Sort Pseudocode :: CC 310 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/16-merge-sort-pseudocode/index.xml" rel="alternate" type="application/rss+xml" title="Merge Sort Pseudocode :: CC 310 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/16-merge-sort-pseudocode/index.print.html" rel="alternate" type="text/html" title="Merge Sort Pseudocode :: CC 310 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/16-merge-sort-pseudocode/embed.html" rel="alternate" type="text/html" title="Merge Sort Pseudocode :: CC 310 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/fontawesome-all.min.css?1691781778" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cc310/css/fontawesome-all.min.css?1691781778" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/nucleus.css?1691781778" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/auto-complete.css?1691781778" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cc310/css/auto-complete.css?1691781778" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/perfect-scrollbar.min.css?1691781778" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/fonts.css?1691781778" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cc310/css/fonts.css?1691781778" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/theme.css?1691781778" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/theme-auto.css?1691781778" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/variant.css?1691781778" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/print.css?1691781778" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/ie.css?1691781778" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/url.js?1691781778"></script>
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/variant.js?1691781778"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cc310/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cc310/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cc310/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cc310/css/custom.css?1691781778" rel="stylesheet">

  </head>
  <body class="mobile-support tele disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cc310/7-searching-and-sorting/16-merge-sort-pseudocode/index.html">
    
    <div id="tele" class="tele mirror">
    
    <div id="body" class="default-animation">
      
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="merge-sort-pseudocode">Merge Sort Pseudocode</h1>

<p>Now that we&rsquo;ve seen how merge sort works by going through an example, let&rsquo;s look at the pseudocode of a merge sort function.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>function MERGESORT(ARRAY, START, END)			(1)
</span></span><span style="display:flex;"><span>    # base case size == 1		
</span></span><span style="display:flex;"><span>    if END - START + 1 == 1 then				(2)		
</span></span><span style="display:flex;"><span>        return						            (3)
</span></span><span style="display:flex;"><span>    end if							            (4)
</span></span><span style="display:flex;"><span>    # base case size == 2
</span></span><span style="display:flex;"><span>    if END - START + 1 == 2 then				(5)
</span></span><span style="display:flex;"><span>        # check if elements are out of order
</span></span><span style="display:flex;"><span>        if ARRAY[START] &gt; ARRAY[END] then		(6)
</span></span><span style="display:flex;"><span>            # swap if so
</span></span><span style="display:flex;"><span>            TEMP = ARRAY[START]				    (7)
</span></span><span style="display:flex;"><span>            ARRAY[START] = ARRAY[END]			(8)
</span></span><span style="display:flex;"><span>            ARRAY[END] = TEMP				    (9)
</span></span><span style="display:flex;"><span>        end if						            (10)
</span></span><span style="display:flex;"><span>        return						            (11)
</span></span><span style="display:flex;"><span>    end if							            (12)
</span></span><span style="display:flex;"><span>    # find midpoint
</span></span><span style="display:flex;"><span>    HALF = int((START + END) / 2)			    (13)
</span></span><span style="display:flex;"><span>    # sort first half
</span></span><span style="display:flex;"><span>    MERGESORT(ARRAY, START, HALF)			    (14)
</span></span><span style="display:flex;"><span>    # sort second half
</span></span><span style="display:flex;"><span>    MERGESORT(ARRAY, HALF + 1, END)			    (15)
</span></span><span style="display:flex;"><span>    # merge halves
</span></span><span style="display:flex;"><span>    MERGE(ARRAY, START, HALF, END)			    (16)
</span></span><span style="display:flex;"><span>end function							        (17)</span></span></code></pre></div><p>This function is a recursive function which has two base cases. The first base case is shown in lines 2 through 4, where the size of the array is exactly 1. In that case, the array is already sorted, so we just return on line 3 without doing anything.</p>
<p>The other base case is shown in lines 5 through 11. In this case, the element contains just two elements. We can use the if statement on line 6 to check  if those two elements are in the correct order. If not, we can use lines 7 through 9 to swap them, before returning on line 11.</p>
<p>If neither of the base cases occurs, then we reach the recursive case starting on line 13. First, we&rsquo;ll need to determine the midpoint of the array , which is just the average of the <code>start</code> and <code>end</code> variables. We&rsquo;ll need to remember to make sure that value is an integer by truncating it if needed.</p>
<p>Then, on lines 14 and 15 we make two recursive calls, each one focusing on a different half of the array. Once each of those calls returns, we can assume that each half of the array is now sorted.</p>
<p>Finally, in line 16 we call a helper function known as <code>merge</code> to merge the two halves together. The pseudocode for that process is below.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>function MERGE(ARRAY, START, HALF, END)			    (1)
</span></span><span style="display:flex;"><span>    TEMPARRAY = new array[END – START + 1]			(2)
</span></span><span style="display:flex;"><span>    INDEX1 = START							        (3)
</span></span><span style="display:flex;"><span>    INDEX2 = HALF + 1						        (4)
</span></span><span style="display:flex;"><span>    NEWINDEX = 0							        (5)
</span></span><span style="display:flex;"><span>    loop while INDEX1 &lt;= HALF and INDEX2 &lt;= END		(6)
</span></span><span style="display:flex;"><span>        if ARRAY[INDEX1] &lt; ARRAY[INDEX2] then		(7)
</span></span><span style="display:flex;"><span>            TEMPARRAY[NEWINDEX] = ARRAY[INDEX1]		(8)
</span></span><span style="display:flex;"><span>            INDEX1 = INDEX1 + 1					    (9)
</span></span><span style="display:flex;"><span>        else								        (10)
</span></span><span style="display:flex;"><span>            TEMPARRAY[NEWINDEX] = ARRAY[INDEX2]		(11)
</span></span><span style="display:flex;"><span>            INDEX2 = INDEX2 + 1					    (12)
</span></span><span style="display:flex;"><span>        end if							            (13)
</span></span><span style="display:flex;"><span>        NEWINDEX = NEWINDEX + 1					    (14)
</span></span><span style="display:flex;"><span>    end loop								        (15)
</span></span><span style="display:flex;"><span>    loop while INDEX1 &lt;= HALF					    (16)
</span></span><span style="display:flex;"><span>        TEMPARRAY[NEWINDEX] = ARRAY[INDEX1]			(17)
</span></span><span style="display:flex;"><span>        INDEX1 = INDEX1 + 1					        (18)
</span></span><span style="display:flex;"><span>        NEWINDEX = NEWINDEX + 1					    (19)
</span></span><span style="display:flex;"><span>    end loop								        (20)
</span></span><span style="display:flex;"><span>    loop while INDEX2 &lt;= END					    (21)
</span></span><span style="display:flex;"><span>        TEMPARRAY[NEWINDEX] = ARRAY[INDEX2]			(22)
</span></span><span style="display:flex;"><span>        INDEX2 = INDEX2 + 1					        (23)
</span></span><span style="display:flex;"><span>        NEWINDEX = NEWINDEX + 1					    (24)
</span></span><span style="display:flex;"><span>    end loop								        (25)
</span></span><span style="display:flex;"><span>    loop INDEX from 0 to size of TEMPARRAY – 1		(26)
</span></span><span style="display:flex;"><span>        ARRAY[START + INDEX] = TEMPARRAY[INDEX]		(27)
</span></span><span style="display:flex;"><span>    end loop								        (28)
</span></span><span style="display:flex;"><span>end function								        (29)</span></span></code></pre></div><p>The <code>merge</code> function begins by creating some variables. The <code>tempArray</code> will hold the newly merged array. <code>Index1</code> refers to the element in the first half that is being considered, while <code>index2</code> refers to the element in the second half. Finally, <code>newIndex</code> keeps track of our position in the new array.</p>
<p>The first loop starting on line 6 will continue operating until one half or the other has been completely added to the temporary array. It starts by comparing the first element in each half of the array. Then, depending on which one is smaller, it will place the smaller of the two in the new array and increment the indexes.</p>
<p>Once the first loop has completed, there are two more loops starting on lines 16 and 21. However, only one of those loops will actually execute, since only one half of the array will have any elements left in it to be considered. These loops will simply copy the remaining elements to the end of the temporary array.</p>
<p>Finally, the last loop starting on line 26 will copy the elements from the temporary array back into the source array. At this point, they will be properly merged in sorted order.</p>

            <footer class="footline">

            </footer>
          </article>
        </div>
      </main>
    </div>
    
    </div>
    
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/clipboard.min.js?1691781780" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/perfect-scrollbar.min.js?1691781780" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/theme.js?1691781780" defer></script>
    
    <script src="https://ksu-cs-textbooks.github.io/cc310/js/tele-scroll.js?1691781780 defer"></script>
    
  </body>
</html>
