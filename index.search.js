




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
		
var relearn_search_index = [
  {
    "breadcrumb": "",
    "content": "Welcome to CC 310!",
    "description": "Welcome to CC 310!",
    "tags": [],
    "title": "Introduction",
    "uri": "/cc310/00-introduction/"
  },
  {
    "breadcrumb": "Performance \u003e Java Libraries",
    "content": " Both Java and Python include standard implementations of each of the data structures we have learned about in this course. While it is very useful and interesting from an academic perspective to build our own linked lists and hash tables, in practice we would rarely do so. In this section, we will briefly introduce the standard library versions of each data structure and provide references to where we can find more information about each one and how to use them.\nJava In Java, most common data structures are part of the Java Collections Framework. It includes interfaces, implementations, and a variety of algorithms that can be used to do almost any common operation with data structures. You can find more information on the Java Tutorials website.\nArrayList The most useful Java collection is the ArrayList. It performs very similarly to an array in most ways. Accessing an element in an ArrayList with an index runs in constant time, and adding new elements to the end of the container can also be done very quickly. In fact, most commonly used list operations run in constant time, and the memory and performance overhead that comes with using an ArrayList is very small.\nArrayLists in Java also support Generics, which is a fancy way of saying that we can define the data types our collection should store and return, instead of just using Objects like we did in this course. We place this in angled brackets \u003c\u003e when we declare and instantiate the structure. This helps make our code easier to understand and can make it much easier to detect and correct type errors when we accidentally try to store an incorrect type in an ArrayList.\nimport java.util.ArrayList; public class AList{ public static void main(String[] args){ ArrayList\u003cInteger\u003e alist = new ArrayList\u003cInteger\u003e(); alist.add(1); alist.add(2); System.out.println(alist.get(0) + alist.get(1)); } } LinkedList Java also includes an implementation of a LinkedList data structure. This structure also performs very similarly to the one we built in this class. Inserting or removing elements from the beginning and the end are constant time, as well as removing items from the middle of the list, provided we are using an iterator to find them.\nLinkedLists in Java are also the ideal choice for implementing both Stacks and Queues because of the constant time operations for inserting and removing elements from the beginning and end of the list. In fact, it even includes the push(), pop() and peek() methods to simulate a stack, and uses offer() and poll() in place of enqueue() and dequeue() for queues.\nLinkedLists in Java also support Generics. According to the Java documentation, when faced with a choice between ArrayList and LinkedList implementations of a particular container, in most cases the ArrayList implementation may be more performant. The exception would be when working with stacks and queues, in which case a LinkedList may work a bit better. When in doubt, they suggest trying the program with both structures and seeing which one performs better.\nimport java.util.LinkedList; public class LList{ public static void main(String[] args){ LinkedList\u003cInteger\u003e llist = new LinkedList\u003cInteger\u003e(); //Stack llist.push(new Integer(1)); llist.push(new Integer(2)); System.out.println(llist.peek()); llist.pop(); System.out.println(llist.pop()); //Queue llist.offer(new Integer(1)); llist.offer (new Integer(2)); System.out.println(llist.peek()); llist.poll(); System.out.println(llist.poll());\t} } Hash Tables Java includes three different implementations of the generic Map data structure, which stores a key-value pair. Two of them offer the ability to sort the keys or keep track of the order that elements were added to the structure, but we won’t review those here. The fastest is the HashMap, which doesn’t guarantee anything about the ordering of the keys or values but will give the best performance overall.\nHashMaps in Java once again have support for Generics, which allows us to define the data type for both the keys and the values stored in the HashMap. This also simplifies things since we do not have to manage the creation of tuples outside of the collection. Instead, it is all handled internally.\nimport java.util.HashMap; public class HMap{ public static void main(String[] args){ HashMap\u003cString, Integer\u003e hmap = new HashMap\u003cString, Integer\u003e(); hmap.put(“Test”, new Integer(123)); hmap.put(“Name”, new Integer(321)); System.out.println(hmap.get(“Test”)); hmap.remove(“Name”); System.out.println(hmap.containsKey(“Name”)); } } Sets Java also includes a very fast implementation of the Set data structure called HashSet. It uses hashing to guarantee that each element is unique, and does not guarantee any particular ordering of the elements in the set. In fact, behind the scenes, the HashSet data structure uses a HashMap to store the data!\nUnfortunately, the Set data structures in Java do not include straightforward implementations of many of the set operations, such as union, intersection, and subset. However, we can use a few of the included methods such as retainAll() and removeAll() to simulate those operations.\nAs with all the other Java data structures, HashSets also supports Generics, so we can define the data type it should be storing when we create it.\nimport java.util.HashSet; public class HSet{ public static void main(String[] args){ HashSet\u003cString\u003e hset = new HashSet\u003cString\u003e(); hset.add(“Test); hset.add(“Name”); System.out.println(hset.contains(“Name”)); hset.remove(“Name”); System.out.println(hset.containsKey(“Name”)); } } Algorithms Finally, we should also review the Java Collections class. It contains many static methods that we can use to work with the various collections we discussed above. For example, the Collections class includes methods for sorting a collection, finding the minimum or maximum value, determining if two collections are disjoint, and more.\nMany of them are described in detail on the Algorithms page of the Collections tutorial.\nJava also includes a special Arrays class that contains methods for manipulating raw arrays in a similar way.\nBoth of these classes are very useful to work with, since they help us avoid “reinventing the wheel” when we want to perform many common operations with our data.",
    "description": "Both Java and Python include standard implementations of each of the data structures we have learned about in this course. While it is very useful and interesting from an academic perspective to build our own linked lists and hash tables, in practice we would rarely do so. In this section, we will briefly introduce the standard library versions of each data structure and provide references to where we can find more information about each one and how to use them.",
    "tags": [],
    "title": "1 Java Standard Library",
    "uri": "/cc310/12-performance/10-java-libraries/1-1-java-standard-library/"
  },
  {
    "breadcrumb": "Performance",
    "content": " There are several linear data structures that we can use in our programs, including stacks, queues, lists, sets, and hash tables. In this course, we have covered each of these structures in detail. However, as a programmer, one of the most difficult decisions we will make when developing a program is the choice of which data structure to use. Sometimes the choice may be obvious based on the data we plan to store or the algorithms we need to perform, but in practice that happens very rarely. Instead, we are faced with competing tradeoffs between various factors such as ease of use, performance, and simplicity.\nIn this chapter, we’ll review the various data structures and algorithms we’ve learned about in this course, but this time we’ll add a bit more focus on the decisions a programmer would make when choosing to use a particular data structure or algorithm.\nThree Important Questions The choice of which data structure to use is often the most consequential choice we make when developing a new piece of software, as it can have a large impact on the overall performance of the program. While there are many different factors to consider, here are three important questions we can ask when choosing a data structure:\nDoes it Work? Above all else, the choice of a data structure must allow the program to complete its work correctly. If the program cannot function properly due to the choice of data structure, then all other factors can effectively be ignored. So, when developing a new program, we should first focus on choosing a data structure that we know will be able to complete the task. Thankfully, with a bit of programming ingenuity, most data structures can be used to complete most tasks, albeit poorly or inefficiently. In those cases, the next two questions will help us further narrow our choice. Is it Understandable? Once we have chosen a few data structures to analyze, the next factor we must deal with is understandability. If we cannot understand how to use our chosen data structure to perform the task, or if the method we use is so complex that it is difficult for us to explain to others, it is very likely that we’ve made a poor choice. In most cases, the best choice of data structure will lead to the most straightforward and understandable implementation. The only exceptions to this are cases where we must deal with extremes of performance or limits on capability. In those extreme cases, many times a more complex answer ends up being the best one due to the limitations imposed on the system. Is it Performant? In programming, we use the term performant to characterize programs that exhibit a high level of performance and efficiency. So, when choosing a data structure to use in our program, we may want to choose one that is most likely to exhibit high levels of performance and efficiency while we use it. As we have learned throughout this course, different data structures are developed with different uses in mind, and it is a very good idea for us to keep that in mind when making our choice. In this chapter, we will spend some time reviewing these performance and efficiency factors for the various data structures we have covered so far, helping us make more informed choices. By answering the questions above in the order they are presented, we should be able to make good decisions about which data structures would work best in our program. We are purposely putting more focus on writing working and understandable code instead of worrying about performance. This is because many programs are only used with small data sets on powerful modern computers, so performance is not the most important aspect. However, there are instances where performance becomes much more important, and in those cases more focus can be placed on finding the most performant solution as well.\nAs it turns out, these three questions are very similar to a classic (trilemma)[https://en.wikipedia.org/wiki/Trilemma] from the world of business, as shown in the diagram below.\n^[File:Project-triangle.svg. (2020, January 12). Wikimedia Commons, the free media repository. Retrieved 21:09, April 30, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Project-triangle.svg\u0026oldid=386979544.]\nIn the world of software engineering, it is said that the process of developing a new program can only have two of the three factors of “good”, “fast”, and “cheap”. The three questions above form a similar trilemma. Put another way, there will always be competing tradeoffs when selecting a data structure for our programs.\nFor example, the most performant option may not be as easy to understand, and it may be more difficult to debug and ensure that it works correctly. A great example of this is matrix multiplication, a very common operation in the world of high-performance computing. A simple solution requires just three loops and is very easy to understand. However, the most performant solution requires hundreds of lines of code, assembly instructions, and a deep understanding of the hardware on which the program will be executed. That program will be fast and efficient, but it is much more difficult to understand and debug.",
    "description": "There are several linear data structures that we can use in our programs, including stacks, queues, lists, sets, and hash tables. In this course, we have covered each of these structures in detail. However, as a programmer, one of the most difficult decisions we will make when developing a program is the choice of which data structure to use. Sometimes the choice may be obvious based on the data we plan to store or the algorithms we need to perform, but in practice that happens very rarely.",
    "tags": [],
    "title": "Choosing the Right Structures",
    "uri": "/cc310/12-performance/1-choosing-the-right-structures/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "One way to look at a computer program is to think of it as a list of instructions that the computer should follow. However, in another sense, many computer programs are simply ways to manipulate data to achieve a desired result. We’ve already written many programs that do this, from calculating the minimum and maximum values of a list of numbers, to storing and retrieving data about students and teachers in a school.\nAs we start to consider our programs as simply ways to manipulate data, we may quickly realize that we are performing the same actions over and over again, or even treating data in many similar ways. Over time, these ideas have become the basis for several common data structures that we may use in our programs.\n1\nData Structure Broadly speaking, a data structure is any part of our program that stores data using a particular format or method. Typically data structures define how the data is arranged, how it is added to the structure, how it can be removed, and how it can be accessed.\nData structures can give us very useful ways to look at how our data is organized. In addition, a data structure may greatly impact how easy, or difficult, it can be to perform certain actions with the data. Finally, data structures also impose performance limitations on our code. Some structures may be better at performing a particular operation than others, so we may have to consider that as well when choosing a data structure for our program.\nIn this class, we’ll spend the majority of our time learning about these common data structures, as well as algorithmic techniques that work well with each one. By formalizing these structures and techniques, we are able to build a common set of building blocks that every programmer is familiar with, making it much easier to build programs that others can understand and reuse.\nFirst, let’s review some of these common data structures and see how they could be useful in our programs.\nFile:Binary tree.svg. (2019, September 14). Wikimedia Commons, the free media repository. Retrieved 22:18, February 7, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Binary_tree.svg\u0026oldid=365739199. ↩︎",
    "description": "One way to look at a computer program is to think of it as a list of instructions that the computer should follow. However, in another sense, many computer programs are simply ways to manipulate data to achieve a desired result. We’ve already written many programs that do this, from calculating the minimum and maximum values of a list of numbers, to storing and retrieving data about students and teachers in a school.",
    "tags": [],
    "title": "Data Structures",
    "uri": "/cc310/03-intro-dsa/01-data-structures/"
  },
  {
    "breadcrumb": "Recursion",
    "content": " We are now used to using functions in our programs that allow us to decompose complex problems into smaller problems that are easier to solve. Now, we will look at a slight wrinkle in how we use functions. Instead of simply having functions call other functions, we now allow for the fact that a function can actually call itself! When a function calls itself, we call it recursion.\nUsing recursion often allows us to solve complex problems elegantly—with only a few lines of code. Recursion is an alternative to using loops and, theoretically, any function that can be solved with loops can be solved with recursion and vice versa.\nExample: Palindromes So why would a function want to call itself? When we use recursive functions, we are typically trying to break the problem down into smaller versions of itself. For example, suppose we want to check to see if a word is a palindrome (i.e., it is spelled the same way forwards and backwards). How would we do this recursively? Typically, we would check to see if the first and last characters were the same. If so, we would check the rest of the word between the first and last characters. We would do this over and over until we got down to the 0 or 1 characters in the middle of the word. Let’s look at what this might look like in pseudocode.\nfunction isPalindrome (String S) returns Boolean if length of S \u003c 2 then return true else return (first character in S == last character in S) and isPalindrome(substring of S without first and last character) end if end function First, we’ll look at the else part of the if statement. Essentially, this statement determines if the first and last characters of S match, and then calls itself recursively to check the rest of the word S. Of course, if the first and last characters of S match and the rest of the string is a palindrome, the function will return true. However, we can’t keep calling isPalindrome recursively forever. At some point we have to stop. That is what the if part of the statement does. We call this our base case. When we get to the point where the length of the string we are checking is 0 or 1 (i.e., \u003c 2), we know we have reached the middle of the word. Since all strings of length 0 or 1 are, by definition, palindromes, we return true.\nKey Idea: Break Up the Problem The key idea of recursion is to break the problem into simpler subproblems until you get to the point where the solution to the problem is trivial and can be solved directly; this is the base case. The algorithm design technique is a form of divide-and-conquer called decrease-and-conquer. In decrease-and-conquer, we reduce our problem into smaller versions of the larger problem.\nA recursive program is broken into two parts:\na base case—a simple version of the problem that can be solved directly, and a recursive case—a general solution to the problem that uses smaller versions of the problem to compute the solution to the larger problem. The base case is generally the final case we consider in a recursive function and serves to both end the recursive calls and to start the process of returning the final answer to our problem. To avoid endless cycles of recursive calls, it is imperative that we check to ensure that:\na base case exists where no further recursive calls are made, and it is possible to reach the base case; the recursive case must ensure that we are moving closer to the base case with each recursive call. ",
    "description": "We are now used to using functions in our programs that allow us to decompose complex problems into smaller problems that are easier to solve. Now, we will look at a slight wrinkle in how we use functions. Instead of simply having functions call other functions, we now allow for the fact that a function can actually call itself! When a function calls itself, we call it recursion.\nUsing recursion often allows us to solve complex problems elegantly—with only a few lines of code.",
    "tags": [],
    "title": "Introducing Recursion",
    "uri": "/cc310/6-recursion/1-introducing-recursion/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " 1\nObject-oriented programming uses the idea of objects and classes to provide many improvements over other programming paradigms. The key concept of object-oriented programming - encapsulation - allows our data and the operations that manipulate that data to be bundled together within a single object.\nFile:CPT-OOP-inheritance.svg. (2014, June 26). Wikimedia Commons, the free media repository. Retrieved 01:22, January 14, 2020 from https://commons.wikimedia.org/w/index.php?title=File:CPT-OOP-inheritance.svg\u0026oldid=127549650. ↩︎",
    "description": "1\nObject-oriented programming uses the idea of objects and classes to provide many improvements over other programming paradigms. The key concept of object-oriented programming - encapsulation - allows our data and the operations that manipulate that data to be bundled together within a single object.\nFile:CPT-OOP-inheritance.svg. (2014, June 26). Wikimedia Commons, the free media repository. Retrieved 01:22, January 14, 2020 from https://commons.wikimedia.org/w/index.php?title=File:CPT-OOP-inheritance.svg\u0026oldid=127549650. ↩︎",
    "tags": [],
    "title": "Object-Oriented Programming",
    "uri": "/cc310/02-oop-review/01-oop/"
  },
  {
    "breadcrumb": "Python Review",
    "content": " Programming 1\nProgramming is the act of writing source code for a computer program in such a way that a modern computer can understand and perform the steps described in the code. There are many different programming languages that can be used, such as high-level languages like Java and Python.\nTo run code written in those languages, we can use a compiler to convert the code to a low-level language that can be directly executed by the computer, or we can use an interpreter to read the code and perform the requested operations on the computer.\nAt this point, we have most likely written some programs already. This chapter will review the important aspects of our chosen programming language, giving us a solid basis to build upon. Hopefully most of this will be review, but there may be a few new terms or concepts introduced here as well.\nhttps://pxhere.com/en/photo/1172040 ↩︎",
    "description": "Programming 1\nProgramming is the act of writing source code for a computer program in such a way that a modern computer can understand and perform the steps described in the code. There are many different programming languages that can be used, such as high-level languages like Java and Python.\nTo run code written in those languages, we can use a compiler to convert the code to a low-level language that can be directly executed by the computer, or we can use an interpreter to read the code and perform the requested operations on the computer.",
    "tags": [],
    "title": "Programming Overview",
    "uri": "/cc310/01-review/01-overview/"
  },
  {
    "breadcrumb": "",
    "content": "All the stuff you should know already!",
    "description": "All the stuff you should know already!",
    "tags": [],
    "title": "Python Review",
    "uri": "/cc310/01-review/"
  },
  {
    "breadcrumb": "Performance \u003e Python Libraries",
    "content": " Both Java and Python include standard implementations of each of the data structures we have learned about in this course. While it is very useful and interesting from an academic perspective to build our own linked lists and hash tables, in practice we would rarely do so. In this section, we will briefly introduce the standard library versions of each data structure and provide references to where we can find more information about each one and how to use them.\nPython Python includes many useful data structures as built-in data types. We can use them to build just about any structure we need quickly and efficiently. The Python Tutorial has some great information about data structures in Python and how we can use them.\nPython includes several data types that are grouped under the heading of sequence data types, and they all share many operations in common. We’ll look at two of the sequence data types: tuples and lists.\nTuples While we have not directly discussed tuples often, it is important to know that Python natively supports tuples as a basic data type. In Python, a tuple is simply a combination of a number of values separated by commas. They are commonly placed within parentheses, but it is not required.\nWe can directly access elements in a tuple using the same notation we use for arrays, and we can even unpack tuples into multiple variables or return them from functions. Tuples are a great way to pass multiple values as a single variable.\ntuple1 = ‘a', ‘b', ‘c' print(tuple1) # (‘a', ‘b', ‘c') tuple2 = (1, 2, 3, 4) print(tuple2) # (1, 2, 3, 4) print(tuple2[0]) # 1 a, b, c, d = tuple2 print(d) # 4 Lists Python’s default data structure for sequences of data is the list. In fact, throughout this course, we have been using Python lists as a stand-in for the arrays that are supported by most other languages. Thankfully, lists in Python are much more flexible, since they can be dynamically resized, sliced, and iterated very easily. In terms of performance, a Python list is roughly equivalent to an array in other languages. We can access elements in constant time when the index is known, but inserting and removing from the beginning of the list runs in order of $N$ time since elements must be shifted backwards. This makes them a poor choice for queues and stacks, where elements must be added and removed from both ends of the list.\nlist1 = [‘a', ‘b', ‘c'] print(list1) # [‘a', ‘b', ‘c'] print(list1[1:2]) # [‘b', ‘c'] Deque The Python Collections library contains a special class called a deque (pronounced “deck”, and short for “double ended queue”) that is a linked list-style implementation that provides much faster constant time inserts and removals from either end of the container. In Python, it is recommended to use the deque data structure when implementing stacks and queues.\nIn a deque, the ends are referred to as “right” and “left”, so there are methods append() and pop() that impact the right side of the container, and appendleft() and popleft() that modify the left side. We can use a combination of those methods to implement both a Stack and a Queue using a deque in Python.\nfrom collections import deque # Stack stack = deque() stack.append(1) stack.append(2) print(stack[-1]) # 2 (peek right side) print(stack.pop()) # 2 print(stack.pop()) # 1 # Queue queue = deque() queue.append(1) queue.append(2) print(queue[0]) # 1 (peek left side) print(queue.popleft()) # 1 print(queue.popleft()) # 2 Dictionaries Python also implements a version of the class Map data structure, called a dictionary. In Python, a dictionary stores key-value pairs, very similarly to how associative arrays work in other languages. Behind the scenes, it uses a hashing function to efficiently store and retrieve elements, making most operations run in near constant time.\nThe one limitation with Python dictionaries is that only hashable data types can be used as keys. We cannot use a list or a dictionary as the key for a dictionary in Python. Thankfully, strings, numbers, and most objects that implement a __hash__() and __eq__() method can be used.\ndict = {‘name': 123, ‘test': 321} print(dict[‘name']) # 123 (get a value) dict[‘date'] = 456 # (add a new entry) print(‘name' in dict) # True (search for entry) Sets Python also includes a built in data type to represent a set. Just like we saw with our analysis, Python also uses a hash-based implementation to allow us to quickly find elements in the set, and therefore does not keep track of any ordering between the elements. We can easily add or remove elements, and Python uniquely allows us to use the binary operators to compute several set operations such as union and intersection.\nset1 = {1, 3, 5, 7, 9} set2 = {2, 3, 5, 7} print(2 in set1) # False (check for membership) print(2 in set2) # True (check for membership) print(set1 – set2) # {1, 9} (set difference) print(set1 | set2) # {1, 3, 5, 7, 9, 2} (union) print(set1 \u0026 set2) # {3, 5, 7} (intersection) ",
    "description": "Both Java and Python include standard implementations of each of the data structures we have learned about in this course. While it is very useful and interesting from an academic perspective to build our own linked lists and hash tables, in practice we would rarely do so. In this section, we will briefly introduce the standard library versions of each data structure and provide references to where we can find more information about each one and how to use them.",
    "tags": [],
    "title": "Python Standard Types",
    "uri": "/cc310/12-performance/11-python-libraries/1-python-standard-types/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "In this course, we are learning about many different ways we can store data in our programs, using arrays, queues, stacks, lists, maps, and more. We’ve already covered a few of these data structures, and we’ll learn about the others in upcoming modules. Before we get there, we should also look at a couple of the most important operations we can perform on those data structures.\nConsider the classic example of a data structure containing information about students in a school. In the simplest case, we could use an array to store objects created from a Student class, each one representing a single student in the school.\nAs we’ve seen before, we can easily create those objects and store them in our array. We can even iterate through the array to find the maximum age or minimum GPA of all the students in our school. However, what if we want to just find a single student’s information? To do that, we’ll need to discuss one of the most commonly used data structure operations: searching.\nWhat is Searching? Searching typically involves finding a piece of information, or a value stored in a data structure or calculated within a specific domain. For example, we might want to find out if a specific word is found in an array of character strings. We might also want to find an integer that meets a specific criterion, such as finding an integer that is the sum of the two preceding integers. For this module, we will focus on finding values in data structures.\nIn general, we can search for\na specific value, a sequence of values, or values with specific properties such as the minimum or maximum value. The data structure can be thought of more generally as a container, which can be\none dimensional, such as a list or a one-dimensional array, multi-dimensional, such as a two-dimensional array or a matrix, or a problem-specific data structure. For the examples in this module, we’ll generally use a simple finite array as our container. However, it shouldn’t be too difficult to figure out how to expand these examples to work with a larger variety of data structures. In fact, as we introduce more complex data structures in this course, we’ll keep revisiting the concept of searching and see how it applies to the new structure.\nIn general, containers can be either ordered or unordered. In many cases, we may also use the term sorted to refer to an ordered container, but technically an ordered container just enforces an ordering on values, but they may not be in a sorted order. As long as we understand what the ordering is, we can use that to our advantage, as we’ll see later.\nSearches in an unordered container generally require a linear search, where every value in the container must be compared against our search value. On the other hand, search algorithms on ordered containers can take advantage of this ordering to make their searches more efficient. A good example of this is binary search. Let’s begin by looking at the simplest case, linear search.",
    "description": "In this course, we are learning about many different ways we can store data in our programs, using arrays, queues, stacks, lists, maps, and more. We’ve already covered a few of these data structures, and we’ll learn about the others in upcoming modules. Before we get there, we should also look at a couple of the most important operations we can perform on those data structures.\nConsider the classic example of a data structure containing information about students in a school.",
    "tags": [],
    "title": "Searching",
    "uri": "/cc310/7-searching-and-sorting/1-searching/"
  },
  {
    "breadcrumb": "Hash Tables",
    "content": " A hash table is an unordered collection of key-value pairs, where each key is unique. The great thing about hash tables is that they provide efficient insertion, removal and lookup operations that arrays and linked lists cannot match, such as:\nRetrieval operations in an unsorted array run in order $N$ time, Retrieval operations in a sorted array using binary search run in constant time, but insertion operations run in order $N$ time, and Insertion operations run in constant time in linked lists, but retrieval operations run in order $N$ time. A hash table consists of three components:\nAn array that holds buckets where key-value pairs are stored, A hash function that maps a key to a specific array index, and A set of buckets that allow the hash table to store multiple key-value pairs whose keys map to the same index in the array; we implement our buckets using linked lists. A user basically stores a key-value pair in the hash table where the key is used to identify the key-value pair as well as compute where it will be stored. For instance, if we consider all the students in a university, we can store student information (name, address, phone, major, GPA, courses, etc.) in the hash table using their name as the key. Storing a key-value pair in a hash table uses the following procedure.\nThe user presents a key-value pair to be stored in the hash table. The key is run through a hash function, which generates an index into the hash table’s array. The key-value pair is stored in the bucket (linked list) referenced at that index. Retrieving a key-value pair from the hash table follows a similar procedure.\nThe user presents the key to the key-value pair to be retrieved. The key is run through a hash function, which generates an index into the hash table’s array. The bucket referenced at that index in the array is then searched for the appropriate key. If found, the key-value pair is returned to the user. Ideally, it would be nice if there was only a single key-value pair stored in each bucket. However, we cannot guarantee this so we use a linked list to allow us to store multiple items whose key produces the same index.\nDictionaries Another data type that is similar to hash tables and is built into many modern programming languages, is the dictionary or an associative array. A dictionary is a collection of key-value pairs that is directly indexed by a key instead of an integer. These keys can be an integer, a string, or other data types. Dictionaries typically support the following operations:\nAdd a key-value pair to the collection, Remove a key-value pair from the collection, Modify an existing key-value pair in the collection, and Lookup a value associated with a given key. As you can see dictionaries and hash tables are very similar in their basic operation. However, an important difference is that hash tables tend to allow any type of objects as the value in the key-value pairs, while dictionaries typically require a specific type of object to be the value. A dictionary can be implemented using a variety of data structures including linked lists and hash tables.",
    "description": "A hash table is an unordered collection of key-value pairs, where each key is unique. The great thing about hash tables is that they provide efficient insertion, removal and lookup operations that arrays and linked lists cannot match, such as:\nRetrieval operations in an unsorted array run in order $N$ time, Retrieval operations in a sorted array using binary search run in constant time, but insertion operations run in order $N$ time, and Insertion operations run in constant time in linked lists, but retrieval operations run in order $N$ time.",
    "tags": [],
    "title": "What are Hash Tables?",
    "uri": "/cc310/11-hash-tables/1-what-are-hash-tables-/"
  },
  {
    "breadcrumb": "Sets",
    "content": " A set is a collection of elements that are usually related to each other. They can be sets of numbers, letters, people, cars, or even sets themselves! Thus, the elements stored in a stack, queue or list can all be considered as sets. When we define the elements in a set, we typically enclose them in curly brackets as follows.\n$$\r\\text{A} = \\{ \\text{Emily}, \\text{Don}, \\text{Mohammed}, \\text{Huichen} \\}\r$$ Here, $\\text{A}$ is the name of the set and Emily, Don, Mohammed, and Huichen are members of set $\\text{A}$.\nSets do have a few key properties:\nThere are no duplicates allowed; we can’t add another Emily to our set above, and The elements in a set are unordered; Don doesn’t come before or after Huichen in the set. There are also a couple of important sets that we need to know.\nThe universal set, $\\mathbb U$, is the set of all elements in what we call the “universe of interest”. However, this “universe of interest” is relative to the problem at hand; in our example above it could be the set of all people, the set of all students, etc. The empty set, usually written as $\\emptyset$ or {} is the set that contains, well nothing! There is exactly one empty set across all “universes of interest”. Visualizing Sets If we want to visualize sets and the relationships between them, we can view them using a Venn Diagram as shown below.\nThe drawing is equivalent to saying the following.\n$$\r\\text{A} = \\{ 17, 9, 32, 15, 3, 5 \\} \\\\ \\text{B} = \\{ 32, 1, 22, 15, 4, 6, 14 \\}\r$$ If we overlap the two sets so that the common elements (in this case, 15 and 32) are in the overlapping section, we see that we do not get two copies of 15 and 32, but that we have just one copy of each. Thus, we have preserved the property that sets do not have duplicates. This overlapping area is called the intersection of the two sets.\nIn the following operations on sets, we will use variants of the diagram below, which shows set $\\text{A}$ and set $\\text{B}$ overlapping. The yellow part of set $\\text{A}$ denotes elements of set $\\text{A}$ that are not in set $\\text{B}$, while the green part of $\\text{B}$ denotes elements of set $\\text{B}$ that are not in set $\\text{A}$. The orange part of the diagram denotes the intersection of $\\text{A}$ and $\\text{B}$, which includes elements of the sets that exist in both set $\\text{A}$ and set $\\text{B}$.",
    "description": "A set is a collection of elements that are usually related to each other. They can be sets of numbers, letters, people, cars, or even sets themselves! Thus, the elements stored in a stack, queue or list can all be considered as sets. When we define the elements in a set, we typically enclose them in curly brackets as follows.\n$$\r\\text{A} = \\{ \\text{Emily}, \\text{Don}, \\text{Mohammed}, \\text{Huichen} \\}\r$$ Here, $\\text{A}$ is the name of the set and Emily, Don, Mohammed, and Huichen are members of set $\\text{A}$.",
    "tags": [],
    "title": "What are Sets?",
    "uri": "/cc310/10-sets/1-what-are-sets-/"
  },
  {
    "breadcrumb": "Lists",
    "content": " A list is a data structure that holds a sequence of data, such as the shopping list shown below. Each list has a head item and a tail item, with all other items placed linearly between the head and the tail. As we pick up items in the store, we will remove them, or cross them off the list. Likewise, if we get a text from our housemate to get some cookies, we can add them to the list as well.\n^[Source: https://www.agclassroom.org/teacher/matrix/lessonplan.cfm?lpid=367]\nLists are actually very general structures that we can use for a variety of purposes. One common example is the history section of a web browser. The web browser actually creates a list of past web pages we have visited, and each time we visit a new web page it is added to the list. That way, when we check our history, we can see all the web pages we have visited recently in the order we visited them. The list also allows us to scroll through the list and select one to revisit or select another one to remove from the history altogether.\nOf course, we have already seen several instances of lists so far in programming, including arrays, stacks, and queues. However, lists are much more flexible than the arrays, stacks, and queues we have studied so far. Lists allow us to add or remove items from the head, tail, or anywhere in between. We will see how we can actually implement stacks and queues using lists later in this module.",
    "description": "A list is a data structure that holds a sequence of data, such as the shopping list shown below. Each list has a head item and a tail item, with all other items placed linearly between the head and the tail. As we pick up items in the store, we will remove them, or cross them off the list. Likewise, if we get a text from our housemate to get some cookies, we can add them to the list as well.",
    "tags": [],
    "title": "What is a List?",
    "uri": "/cc310/9-lists/1-what-is-a-list-/"
  },
  {
    "breadcrumb": "Queues",
    "content": "A queue (pronounced like the letter “q”) data structure organizes data in a First In, First Out (FIFO) order: the first piece of data put into the queue is the first piece of data available to remove from the queue. A queue functions just like the line you would get into to go into a ballgame, movie, or concert: the person that arrives first is the first to get into the venue.\n^[https://commons.wikimedia.org/w/index.php?title=Special:CiteThisPage\u0026page=File%3AReichstag_queue_2.JPG\u0026id=379395710\u0026wpFormIdentifier=titleform]\nYou might be thinking that this sounds a lot like the stack structure we studied a few modules back, with the exception that the stack was a Last in, First Out (LIFO) structure. If so, you are correct. The real difference between a stack and a queue is how we take data out of the data structure. In a stack, we put data onto the top of the stack and removed it from the top as well. With a queue, we put data onto the end (or rear) of the queue and remove it from the start (or front) of the queue.",
    "description": "A queue (pronounced like the letter “q”) data structure organizes data in a First In, First Out (FIFO) order: the first piece of data put into the queue is the first piece of data available to remove from the queue. A queue functions just like the line you would get into to go into a ballgame, movie, or concert: the person that arrives first is the first to get into the venue.",
    "tags": [],
    "title": "What is a Queue?",
    "uri": "/cc310/8-queues/1-what-is-a-queue-/"
  },
  {
    "breadcrumb": "Stacks",
    "content": " A stack is a data structure with two main operations that are simple in concept. One is the push operation that lets you put data into the data structure and the other is the pop operation that lets you get data out of the structure.\nWhy do we call it a stack? Think about a stack of boxes. When you stack boxes, you can do one of two things: put boxes onto the stack and take boxes off of the stack. And here is the key. You can only put boxes on the top of the stack, and you can only take boxes off the top of the stack. That’s how stacks work in programming as well!\nA stack is what we call a “Last In First Out”, or LIFO, data structure. That means that when we pop a piece of data off the stack, we get the last piece of data we put on the stack.",
    "description": "A stack is a data structure with two main operations that are simple in concept. One is the push operation that lets you put data into the data structure and the other is the pop operation that lets you get data out of the structure.\nWhy do we call it a stack? Think about a stack of boxes. When you stack boxes, you can do one of two things: put boxes onto the stack and take boxes off of the stack.",
    "tags": [],
    "title": "What is a Stack?",
    "uri": "/cc310/5-stacks/1-what-is-a-stack-/"
  },
  {
    "breadcrumb": "Introduction",
    "content": " Resources Slides Previous Versions Video Script Hello and welcome to the Computational Core program!\nMy name is Russ Feldhausen, and I’ll be one of the instructors for this program. My contact information is shown here, and is also listed on the syllabus\n[Slide 2]\nThere are many other instructors and TAs for this program that you may interact with or see in the tutorial videos. They all have been instrumental in the development of this program. Specifically, I’d like to recognize the work of Nathan Bean, the developer of the CIS 400 course on which this course is based.\n[Slide 3]\nIn this course we will primarily use a KSU email group (cc410-help or cc410-help@ksuemailprod.onmicrosoft.com) to communicate. Email sent to this address is forwarded to all instructors and TAs. Our replies to you will also be shared amongst the instructors and TAs so we all have access to the assistance you have already received. We will respond to you within a business day, so be aware that a question emailed Friday night may not receive an answer before Monday. Please read and adhere to the guidance on Netiquette in the syllabus for all electronic communications.\n[Slide 3]\nIn addition to email and Canvas, we’ll be using the online learning platform Codio for most of the programming tutorials and projects in this program. We’ll also discuss how to use Codio later in this module.\n[Slide 5]\nThe Computational Core program consists of several courses, and each course contains a number of learning modules. In general, there are about 12-15 modules per course. Each module will usually consist of an interactive tutorial using Codio, followed by a quiz through Canvas, and lastly a programming project in Codio. In CC 410, there will also be several guided examples for you to follow and submit. The modules themselves are gated, which means that you much complete each item in the module before continuing. In addition, the modules enforce prerequisite requirements from other modules. For CC 410 you must complete them in order starting with module 0.\nYou are welcome to work on this course at any time during the week as your schedule allows, provided that you complete each module before the listed due date. There will be roughly one module due each week. Unlike other Computational Core courses, CC 410 does not include many auto-graded assignments. This is primarily due to the open-ended nature of the course. Instead, your code will be reviewed by an instructor or TA and you’ll receive feedback through Canvas and Codio. In some instances, you may be encouraged to redo parts of an assignment for additional credit. We will strive to provide feedback on an assignment within one week of it being submitted.\n[Slide 6]\nLooking ahead to the rest of this introductory module, you’ll see that there are a few more items to be completed before you can move on. In the next video, I’ll discuss a bit more information about navigating through this course on Canvas and using the Codio learning environment.\n[Slide 7]\nOne thing I highly encourage each of you to do is read the syllabus for this course in its entirety, and let us know if you have any questions. My view is that the syllabus is a contract between me as your teacher and you as a student, defining how each of us should treat each other and what we should expect from each other. We have made a few changes to the standard syllabus template for this program, and those changes are clearly highlighted. Finally, the syllabus itself is subject to change as needed as we adapt this program to meet the needs of its students, and all changes will be clearly communicated to everyone before they take effect.\n[Slide 8]\nOne very important part of the syllabus that every student should read is the late work policy. First off, each module has a due date, and you may work on that module at any time before it is due, provided you have met the prerequisites. As discussed before, you must do all the readings and assignments in a module, preferably in listed order, before moving on, so you cannot jump ahead. A module is considered completed when all items have been completed.\n[Slide 9]\nFor the purposes of grading, we will use the date and time that the confirmation quiz was submitted at the end of each module to determine when the module was completed. This is due to the way that Codio handles grading, as it may resubmit previously graded assignments if an error in the module is corrected, making a previously completed assignment appear to be submitted late.\nIf a module is completed after the due date, a penalty of 10% of the total points of each assignment will be deducted for each day the assignment is late. Therefore, if an assignment is submitted 3 days late, it will be subject to a 30% penalty of the total number of points possible on that assignment. After 10 days, no points will be awarded for a late submission.\nHowever, even if a module is late, it still must be completed before you can move on to a later module. So, it is very important to avoid getting behind in this course, as it can be very difficult to get back on track. If you ever find that you are struggling to keep up, please don’t be afraid to contact either the instructors or GTAs for assistance. We’d be happy to help you get caught back up quickly.\nThe grading in this course is very simple. First, 10% of your final grade will depend on the grades you receive from each of the tutorials and quizzes throughout the course. Next, 10% of your grade will come from the interactive examples that precede several projects. The next 40% of your grade will come from the numerous project milestones throughout the course, of which there will be approximately 10. There will also be a couple of “concept quizzes” throughout the semester, which are a bit longer than a normal quiz and will ask you to apply what you’ve learned to a novel situation. Those are worth 15% of your grade. Finally, the last 25% of your grade will come from the final project in the course, which will be discussed in a later video. In this program, the standard “90-80-70-60” grading scale will apply, though I reserve the right to curve grades up to a higher grade level at my discretion. Therefore, you will never be required to get higher than 90% for an A, but you may get an A if you score slightly below 90% if I choose to curve the grades.\n[Slide 10]\nThis is intended to be a completely online, self-paced course. There are no mandatory scheduled course times. All of the content is available online, so you can work whenever and wherever you want. It could be a 3-hour block once a week, or a few minutes here and there between classes. It’s really up to you and your schedule. However, remember that each module may require 12 to 16 or more hours of work to complete, so make sure you have plenty of time available to devote to this course.\nIn addition, due to the flexible online format of this class, there won’t be any long lecture videos to watch. Instead, each module will consist of a guided tutorial and several short videos, each focused on a particular topic or task. Likewise, there won’t be any textbooks required, since all of the information will be presented in the interactive tutorials through Codio. Finally, since we are using Codio as our learning platform, you won’t have to deal with installing and using a clunky integrated development environment, or IDE, just to learn how to program. Codio helps make learning to program quick and painless by moving everything to the web.\n[Slide 11]\nWhat hasn’t changed, though, is the basic concept of a college course. You’ll still be expected to watch or read about 6-9 hours of content to complete each module. In addition to that, each project assignment may require another 6-9 hours of work to complete. If you plan on doing a module each week, that roughly equates to 6 hours of content and 6 hours of homework each week, which is the expected workload from a 3-4 credit hour college course.\nFrom my experience, I can definitely share that the number one reason students struggle in this class is due to poor time management, not the complexity of the material. So, make sure you are planning to dedicate enough time to this course, and strive to start assignments as soon as you receive them so you have lots of time to get help if you get stuck.\n[Slide 12]\nFor this course, the only supplies you’ll need as a student are access to a modern web browser and a broadband internet connection. No other special hardware or software is necessary! However, in this course you will also be able to do some development on your own computer using Visual Studio Code and Ubuntu. We’ll provide some short videos to help you get started if you choose to go that route, but it is not required. Due to the complex nature of this course, we do not recommend using phones, tablets, or Chromebooks if you choose to do development on your own systems.\n[Slide 13]\nFinally, as you are aware, this course is always subject to change. This is a relatively new program here at K-State, and we’re always working on new and interesting ideas to integrate into the courses. The best advice I have is to look upon this graphic with the words “Don’t Panic” written in large, friendly letters. If you find yourself falling behind, or not understanding seek our help via cc410-help.\n[Slide 14]\nSo, to complete this module, there are a few other things that you’ll need to do. The next step is to watch the video on navigating Canvas and Codio, which will give you a good idea of how to most effectively work through the content in this course.\n[Slide 15]\nTo get to that video, click the “Next” button at the bottom right of this page.",
    "description": "Resources Slides Previous Versions Video Script Hello and welcome to the Computational Core program!\nMy name is Russ Feldhausen, and I’ll be one of the instructors for this program. My contact information is shown here, and is also listed on the syllabus\n[Slide 2]\nThere are many other instructors and TAs for this program that you may interact with or see in the tutorial videos. They all have been instrumental in the development of this program.",
    "tags": [],
    "title": "Course Introduction",
    "uri": "/cc310/00-introduction/01-introduction/"
  },
  {
    "breadcrumb": "Performance",
    "content": "Data structures that are used in our programs can be characterized in terms of two performance attributes: processing time and memory usage.\nWe will not worry about memory usage at this point, since most of the memory used in these data structures is consumed by the data that we are storing. More technically, we would say that the memory use of a data structure containing N elements is on the order of $N$ size. However, some structures, such as doubly linked lists, must maintain both the next and previous pointers along with each element, so there can be a significant amount of memory overhead. That is something we should keep in mind, but only in cases where we are dealing with a large amount of data and are worried about memory usage.\nWhen evaluating the processing time of a data structure, we are most concerned with the algorithms used to add, remove, access, and find elements in the data structure itself. There are a couple of ways we can evaluate these operations.\nEmpirically – we can simply measure the real-world time it takes to perform these actions on the data we are expecting our program to process, and then review the results in a spreadsheet or plot them on a graph to compare them. This gives us a good idea of how well the program will work, but it does not give us a very deep understanding of why the data structure performs that way. Mathematically – the other option is to mathematically evaluate the algorithm by reviewing the code and determining the order of time it takes relative to the size of the input. While this does not give us an actual, real-world value for the time it takes to perform an operation, it allows us to easily compare different operations and data structures based on how they’d perform given the same size of input. We typically discuss both the best-case and worst-case processing times for each operation. Throughout this course, we have included mathematical descriptions of the processing time of most major operations on the data structures we have covered.",
    "description": "Data structures that are used in our programs can be characterized in terms of two performance attributes: processing time and memory usage.\nWe will not worry about memory usage at this point, since most of the memory used in these data structures is consumed by the data that we are storing. More technically, we would say that the memory use of a data structure containing N elements is on the order of $N$ size.",
    "tags": [],
    "title": "Data Structure Performance",
    "uri": "/cc310/12-performance/2-data-structure-performance/"
  },
  {
    "breadcrumb": "Recursion",
    "content": "Suppose we must write a program that reads in a sequence of keyboard characters and prints them in reverse order. The user ends the sequence by typing an asterisk character *.\nWe could solve this problem using an array, but since we do not know how many characters might be entered before the *, we could not be sure the program would actually work. However, we can use a recursive function since its ability to save the input data is not limited by a predefined array size.\nOur solution would look something like this. We’ve also numbered the lines to make the following discussion easier to understand.\nfunction REVERSE()\t(1) read CHARACTER\t(2) if CHARACTER == `*` then\t(3) return\t(4) else\t(5) REVERSE()\t(6) print CHARACTER\t(7) return\t(8) end if (9) end function\t(10)Base Case The function first reads a single character from the keyboard and stores it in CHARACTER. Then, in line 3 it checks to see if the user typed the * character. If so, we simply return, knowing that we have reached the end of the input and need to start printing out the characters we’ve read in reverse order. This is the base case for this recursive function.\nRecursive Case If the CHARACTER we read in was not an *, line 6 will recursively call REVERSE to continue reading characters. Once the function returns (meaning that we have gotten an * character and started the return process) the function prints the CHARACTER in line 7 and then returns itself.\nBehind the Scenes Now let’s look at what happens within the computer when we run REVERSE. Let’s say the program user wants to enter the three characters from the keyboard: n, o, and w followed by the * character. The following figure illustrates the basic concept of what is going on in the computer.\nThe arrows in the figure represent the order of execution of the statements in the computer. Each time we execute the recursive call to REVERSE in line 6, we create a new instance of the function, which starts its execution back at the beginning of the function (line 2). Then, when the function executes return, control reverts back to the next statement to be executed (line 7) in the calling instance of the function.\nIt’s important to understand that each instance of the function has its own set of variables whose values are unique to that instance. When we read n into the CHARACTER variable in the first instance of REVERSE it is not affected by anything that happens in the second instance of REVERSE. Therefore, reading the o into CHARACTER in the second instance of REVERSE does not affect the value of CHARACTER in the first instance of REVERSE.\nDuring the execution of the first instance of REVERSE, the user enters the character n so the if condition is false and we execute the else part of the statement, which calls the REVERSE function. (Note that before we actually start the second instance of REVERSE, the operating system stores the statement where we will pick up execution once the called function returns.) When the second instance of REVERSE is started, a new copy of all variables is created as well to ensure we do not overwrite the values from the first instance.\nThe execution of the second instance of REVERSE runs exactly like the first instance except that the user enters the character o instead of n. Again, the else part of the if statement is executed, which calls the REVERSE function. When the third instance of REVERSE is executed, the user now inputs w, which again causes a new instance of REVERSE to be called.\nFinally, in the fourth instance of REVERSE, the user inputs the * character, which causes the if part of the statement to execute, which performs our return statement. Once the return from the base case of our recursive function is performed, it starts the process of ending all the instances of the REVERSE function and creating the solution. When instance 4 of the REVERSE function returns, execution starts at the write statement (line 7) of instance 3. Here the character w is printed, and the function returns to instance 2. The same process is carried out in instance 2, which prints the o character and returns. Likewise, instance 1 prints its character n and then returns. The screen should now show the full output of the original call to REVERSE , which is “won”.\nRecursion has allowed us to create a very simple and elegant solution to the problem of reversing an arbitrary number of characters. While you can do this in a non-recursive way using loops, the solution is not that simple. If you don’t believe us, just try it! (Yes, that is a challenge.)",
    "description": "Suppose we must write a program that reads in a sequence of keyboard characters and prints them in reverse order. The user ends the sequence by typing an asterisk character *.\nWe could solve this problem using an array, but since we do not know how many characters might be entered before the *, we could not be sure the program would actually work. However, we can use a recursive function since its ability to save the input data is not limited by a predefined array size.",
    "tags": [],
    "title": "Example: Reversing a String",
    "uri": "/cc310/6-recursion/2-example--reversing-a-string/"
  },
  {
    "breadcrumb": "Python Review",
    "content": "In this course, we will primarily be learning different ways to store and manipulate data in our programs. Of course, we could do this using the source code of our chosen programming language, but in many cases that would defeat the purpose of learning how to do it ourselves!\nInstead, we will use several different ways to represent the steps required to build our programs. Let’s review a couple of them now.\nNatural Language One of the simplest ways to describe a computer program is to simply write what it does using our preferred language, such as English. Of course, natural language can be very ambiguous, so we must be careful to make our written descriptions as precise as possible. So, it is a good idea to limit ourselves to simple, clear sentences that aren’t written as prose. It may seem a bit boring, but this is the best way to make sure our intent is completely understood.\nA great example is a recipe for baking. Each step is written clearly and concisely, with enough descriptive words used to allow anyone to read and follow the directions.\nFlowcharts One method of representing computer programs is through the use of flowcharts. A flowchart consists of graphical blocks representing individual operations to be performed, connected with arrows which describe the flow of the program. The image above gives the basic building blocks of the flowcharts that will be used in this course. We will mostly follow the flowchart design used by the Flowgorithm program available online. The following pages in this chapter will introduce and discuss each block in detail.\nPseudocode We can also express our computer programs through the use of pseudocode. Pseudocode is an abstract language that resembles a high-level programming language, but it is written in such a way that it can be easily understood by any programmer who is familiar with any one of several common languages. The pseudocode may not be directly executable as written, but it should contain enough detail to be easily understood and adapted to an actual programming language by a skilled programmer.\nThere are many standards that exist for pseudocode, each with their own unique features and uses. In this course, we will mostly follow the standards from the International Baccalaureate Organization. In the following pages in this chapter, we’ll also introduce pseudocode for each of the flowchart blocks shown above.\nReferences Flowgorithm International Baccalaureate Organization Pseudocode ",
    "description": "In this course, we will primarily be learning different ways to store and manipulate data in our programs. Of course, we could do this using the source code of our chosen programming language, but in many cases that would defeat the purpose of learning how to do it ourselves!\nInstead, we will use several different ways to represent the steps required to build our programs. Let’s review a couple of them now.",
    "tags": [],
    "title": "Flowcharts and Pseudocode",
    "uri": "/cc310/01-review/02-flowchart-pseudocode/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": "Functions are small pieces of reusable code that allow you to divide complex programs into smaller subprograms. Ideally, functions perform a single task and return a single value. (It should be noted that some programming languages allow for procedures, which are similar to functions but return no values. Except for the return value, it is safe to group them with functions in our discussion below.)\nFunctions can be thought of as black boxes. When we talk about black boxes we mean that users cannot look inside the box to see how it actually works. A good example of a black box is a soda machine. We all use them and know how to operate them, but very few of actually know how they work inside. Nor do we really want to know. We are happy to simply use them machine and have it give a nice cold soda when we are thirst!\nCalling Functions To be able to reuse functions easily, it is important to define what a function does and how it should be called.\nBefore we can call a function, we must know the function’s signature. A function’s signature includes the following.\nThe name of the function. The parameters (data) that must be provided for the function to perform its task. The type of result the function returns. While a signature will allow us to actually call the function in code. Of course to use functions effectively, we must also know exactly what the function is supposed to do. We will talk more about how we do this in the next module on programming by contract. For now we can assume that we just have a good description of what the function does.\nWhile we do not need to know exactly how a function actually performs its task, the algorithm used to implement the function is vitally important as well. We will spend a significant amount of time in this course designing such algorithms.\nExecuting Functions The lifecycle of a function is as follows.\nA program (or another function) calls the function. The function executes until it is complete. The function returns to the calling program. When the function is called, the arguments, or actual parameters, are copied to the function’s formal parameters and program execution jumps from the “call” statement to the function. When the function finishes execution, execution resumes at the statement following the “call” statement.\nIn general, parameters are passed to functions by value, which means that the value of the calling program’s actual parameter is copied into the function’s formal parameter. This allows the function to modify the value of the formal parameter without affecting the actual parameter in the calling program.\nHowever, when passing complex data structures such as objects, the parameters are passed by reference instead of by value. In this case, a pointer to the parameter is passed instead of a copy of the parameter value. By passing a pointer to the parameter, this allows the function to actually make changes to the calling program’s actual parameter.",
    "description": "Functions are small pieces of reusable code that allow you to divide complex programs into smaller subprograms. Ideally, functions perform a single task and return a single value. (It should be noted that some programming languages allow for procedures, which are similar to functions but return no values. Except for the return value, it is safe to group them with functions in our discussion below.)\nFunctions can be thought of as black boxes.",
    "tags": [],
    "title": "Functions",
    "uri": "/cc310/02-oop-review/02-functions/"
  },
  {
    "breadcrumb": "Hash Tables",
    "content": "As stated previously, a hash table has three main components: an array, a hash function, and a set of buckets that store key-value pairs. We discuss the implementation of these below.\nArray We use an array to hold pointers to the buckets where the key-value pairs are stored. While the array itself is a common data type found in almost every language, there are some important aspects to the arrays used in hash tables.\nFirst, the array must be large enough to store our key-value pairs without too many collisions. A collision occurs when two key-value pairs map to the same array index. Although we cannot keep this from happening, the fewer collisions, the faster the hash table. Thus, the larger the array, the lower the chance for collisions. We capture the size of the array as its capacity.\nIn the example below, both hash tables are storing the same number of key-value pairs. However, the capacity of the array on the right is more than twice as large as the one on the left. To retrieve a random key-value pair from each of these arrays requires a search of one of the linked list buckets. For the array on the left, the average number of nodes searched is $1.8$, while for the array on the right it is only $1.2$. Thus, in this example doubling the capacity of our array provides a $33\\%$ reduction in the time required to retrieve a key-value pair. (Note that these statistics were computed based on these particular array capacities and the number of key-value pairs in the example.)\nSecond, the array should be re-sizable. Since we generally do not know in advance how many key-value pairs we have to store in our hash table, we need to be able to resize our array when the number of key-value pairs reaches a predefined threshold. This threshold is based on the loading factor, which we define next.\nLoad Factor As we store more key-value pairs in a hash table, the number of collisions will increase. The more collisions we have, the less efficient our hash table will become. Thus, at some point, it makes sense to increase the capacity of the array and rehash our table, which means we compute new indexes for all key-value pairs and add them into the new array. The question is, when is the appropriate time to do this?\nTraditionally, we answer this question using a ratio of the capacity of the hash table array to the number of key-value pairs stored in the table. There are three key properties of hash tables that come into play here:\nThe capacity of the array, The size of the hash tables in terms of the number of key-value pairs stored in the table, The load factor (or ratio) between the size of the hash table and its capacity, $\\text{size} / \\text{capacity}$. Typically, when the load factor reaches a specified threshold, we double the capacity of the array and then rehash the table using the new array. The load factor threshold we choose is a tradeoff between space and time. The larger the array, the more memory you use, but with fewer collisions. Obviously, using a smaller array increases the number of collisions as well as the time it takes to retrieve key-value pairs from the table. For our examples below, we use the standard default load factor of $0.75$.\nBuckets If our array was large enough to ensure our hash function would compute a unique index for each key (i.e., there would be absolutely no collisions), we could store the key-value pairs directly in the array. Unfortunately, this is almost never the case and collisions do occur. Therefore, we store the key-value pairs in buckets associated with each array index. Buckets are the general term we use to describe the mechanism we use to store key-value pairs and handle any collisions that occur. As shown in the figure below, we use linked lists to implement our buckets, which is a fairly standard approach.\nAs we recall, linked lists provide constant time operations for adding key-value pairs to the list and linear time operations for retrieving key-value pairs from the list. While linear time seems slow for adding a key-value pair to the list, we need to remember that we are talking only about the number of key-value pairs in a specific list, not the total number of key-value pairs in the entire hash table. Thus, as shown in the figure above, the maximum number of key-value pairs in any linked list is $2$, even though the size of the entire table is $9$. With a load factor of $0.75$ and a good quality hash function that distributes key-value pairs uniformly across the array, our linked lists generally have a small number of items ($2$ or $3$ maximum) in each list. So, even though retrieving is not technically constant time, because it is very close to it in practice, we say that it is.",
    "description": "As stated previously, a hash table has three main components: an array, a hash function, and a set of buckets that store key-value pairs. We discuss the implementation of these below.\nArray We use an array to hold pointers to the buckets where the key-value pairs are stored. While the array itself is a common data type found in almost every language, there are some important aspects to the arrays used in hash tables.",
    "tags": [],
    "title": "Hash Tables in Code",
    "uri": "/cc310/11-hash-tables/2-hash-tables-in-code/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": " When searching for a number in an unordered array, our search algorithms are typically designed as functions that take two parameters:\nthe number to find, and the array to search. Our search functions then return an index to the number within the array.\nIn this module, we will develop a couple of examples of searching an array for a specific number.\nFinding the first occurrence of a number in an unordered array is a fairly straightforward process. A black box depiction of this function is shown below. There are two inputs–array and number–and a single output, the index of the first occurrence of the number in array.\nWe can also include the search function as a method inside of the container itself. In that case, we don’t have to accept the container as a parameter, since the method will know to refer to the object it is part of.\nOf course, when we begin designing an algorithm for our function we should think about two items immediately: the preconditions and the postconditions of the function. For this function, they are fairly simple.\nThe precondition for find is that the number provided as input is compatible with the type of data held by the provided array. In this case, we have no real stipulations on array. It does not need to actually have any data in it, nor does it have to be ordered or unordered.\nOur postcondition is also straightforward. The function should return the index of number if it exists in the array. However, if number is not found in the array, then -1 is returned. Depending on how we wish to implement this function, it could also return another default index or throw an exception if the desired value is not found. However, most searching algorithms follow the convention of returning an invalid index of -1 when the value is not found in the array, so that’s what we’ll use in our examples.\nPreconditions:\nThe number to be searched for is compatible with data in the array Postconditions:\nThe function returns the index of number in the array The function returns -1 if the number to be searched for is not found in the array ",
    "description": "When searching for a number in an unordered array, our search algorithms are typically designed as functions that take two parameters:\nthe number to find, and the array to search. Our search functions then return an index to the number within the array.\nIn this module, we will develop a couple of examples of searching an array for a specific number.\nFinding the first occurrence of a number in an unordered array is a fairly straightforward process.",
    "tags": [],
    "title": "Linear Search",
    "uri": "/cc310/7-searching-and-sorting/2-linear-search/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": " First, we can broadly separate the data structures we’re going to learn about into two types, linear and non-linear data structures.\nA linear data structure typically stores data in a single dimension, just like an array. By using a linear data structure, we would know that a particular element in the data structure comes before another element or vice-versa, but that’s about it. A great example is seen in the image above. We have a list of numbers, and each element in the list comes before another element, as indicated by the arrows.\nLinear Data Structure Hierarchy Linear data structures can further be divided into two types: arrays, which are typically finite sized; and linked lists, which can be infinitely sized. We’ve already worked with arrays extensively by this point, but linked lists are most likely a new concept. That’s fine! We’ll explore how to build our own later in this course.\nUsing either arrays or linked lists, we can build the three most commonly used linear data structures: stacks, queues, and sets. However, before we learn about each of those, let’s review a bit more about what the list data structure itself looks like.",
    "description": "First, we can broadly separate the data structures we’re going to learn about into two types, linear and non-linear data structures.\nA linear data structure typically stores data in a single dimension, just like an array. By using a linear data structure, we would know that a particular element in the data structure comes before another element or vice-versa, but that’s about it. A great example is seen in the image above.",
    "tags": [],
    "title": "Linear Structures",
    "uri": "/cc310/03-intro-dsa/02-linear-structures/"
  },
  {
    "breadcrumb": "Lists",
    "content": "Most of us see and use lists every day. We have a list for shopping as we saw above, but we may also have a “to do” list, a list of homework assignments, or a list of movies we want to watch. Some of us are list-makers and some are not, but we all know a list when we see it.\n^[Source: https://wiki.videolan.org/index.php?title=File:Basic_playlist_default.png\u0026oldid=59730]\nHowever, there are other lists in the real world that we might not even think of as a list. For instance, a playlist on our favorite music app is an example of a list. A music app lets us move forward or backward in a list or choose a song randomly from a list. We can even reorder our list whenever we want.\nAll the examples we’ve seen for stacks and queues can be thought of as lists as well. Stacks of chairs or moving boxes, railroad trains, and cars going through a tollbooth are all examples of special types of lists.",
    "description": "Most of us see and use lists every day. We have a list for shopping as we saw above, but we may also have a “to do” list, a list of homework assignments, or a list of movies we want to watch. Some of us are list-makers and some are not, but we all know a list when we see it.\n^[Source: https://wiki.videolan.org/index.php?title=File:Basic_playlist_default.png\u0026oldid=59730]\nHowever, there are other lists in the real world that we might not even think of as a list.",
    "tags": [],
    "title": "Lists in the Real World",
    "uri": "/cc310/9-lists/2-lists-in-the-real-world/"
  },
  {
    "breadcrumb": "",
    "content": "Review Object-Oriented Programming in Python",
    "description": "Review Object-Oriented Programming in Python",
    "tags": [],
    "title": "OOP Review",
    "uri": "/cc310/02-oop-review/"
  },
  {
    "breadcrumb": "Sets",
    "content": "Now that we can create and show sets of various types of elements, there are a few interesting operations that we can perform on sets. Given two sets, $\\text{A}$ and $\\text{B}$, we can perform the following operations:\nUnion $\\cup$ — a set with all the elements from both sets, Intersection $\\cap$ — a set with only elements that are in both sets, Difference $\\setminus$ — a set with the elements in one set that are not in the other, Disjoint $\\text{A} \\cap \\text{B} = \\emptyset$ — two sets don’t share any elements in common Subset $\\subseteq$ — one set is completely contained in another set Superset $\\supseteq$ — one set completely contains another set Product $\\times$ — a set of all the ordered pairs where the first element is from the first set and second element is from the second set, and Powerset $\\wp$ — a set of all the subsets of a given set. We will describe each of these operations in more detail below.\nUnion $\\cup$ The union of two sets, $\\text{A}$ and $\\text{B}$, is the set of elements that belongs to either $\\text{A}$ or to $\\text{B}$. The following figure shows the Venn Diagram for the union of set $\\text{A}$ and set $\\text{B}$. In this diagram, the blue color denotes the elements of the set that are in $\\text{A} \\cup \\text{B}$.\nFor our example sets $\\text{A}$ and $\\text{B}$ above, the union would be equivalent to the following.\n$$\r\\text{A} \\cup \\text{B} = \\{ 17, 9, 32, 15, 3, 5, 1, 22, 4, 6, 14 \\}\r$$ Intersection $\\cap$ The intersection of two sets, $\\text{A}$ and $\\text{B}$, includes all the elements that belong to both $\\text{A}$ and $\\text{B}$. The following figure shows the Venn Diagram for the intersection of set $\\text{A}$ and set B. In this diagram, the blue color denotes the elements of the set that are in $\\text{A} \\cap \\text{B}$.\nFor our example sets $\\text{A}$ and $\\text{B}$ above, the union would be equivalent to the following.\n$$\r\\text{A} \\cap \\text{B} = \\{ 15, 32 \\}\r$$ Difference $\\setminus$ The difference of two sets, $\\text{A}$ and $\\text{B}$, includes all the elements in $\\text{A}$ that are not in $\\text{B}$. The following figure shows the Venn Diagram for the difference between set $\\text{A}$ and set $\\text{B}$. In this diagram, the blue color denotes the elements of the set that are in $\\text{A} \\setminus \\text{B}$.\nFor our example sets $\\text{A}$ and $\\text{B}$ above, $\\text{A} \\setminus \\text{B}$ would be equivalent to the following.\n$$\r\\text{A} \\setminus \\text{B} = \\{ 17, 9, 3, 5 \\}\r$$ It is important to realize that the set difference is not symmetrical, which means that the operation $\\text{A} \\setminus \\text{B}$ does not result in the same set as $\\text{B} \\setminus \\text{A}$. $\\text{B} \\setminus \\text{A}$ is the set composed of the elements that belong to $\\text{B}$ but not to $\\text{A}$. The following figure shows the Ven Diagrams for $\\text{B} \\setminus \\text{A}$.\nFor our example sets $\\text{A}$ and $\\text{B}$ above, $\\text{B} \\setminus \\text{A}$ would be equivalent to the following.\n$$\r\\text{B} - \\text{A} = \\{ 1, 22, 4, 6, 14 \\}\r$$ isDisjoint $\\text{A} \\cap \\text{B} = \\emptyset$ We say two sets are disjoint it they have no common elements. The isDisjoint operation returns true if two sets are disjoint and false if they are not. For example, sets $\\text{A}$ and $\\text{B}$ below are disjoint since they do not share any of the same numbers. A simple way of computing the value of isDisjoint is just to check to see if the intersection of the two sets is the empty set. If it is, then the two sets are disjoint.\n$$\r\\text{A} \\cap \\text{B} = \\emptyset \\implies \\text{A and B are disjoint}\r$$ isSubset $\\subseteq$ We say a set $\\text{B}$ is a subset of set $\\text{A}$ if all of the elements of set $\\text{B}$ are also elements of set A. The isSubset operation is an operation that determines if the subset relationship is true or false for any two sets. In the example below, set $\\text{B}$ is a subset of set $\\text{A}$ since all the elements of $\\text{B}$ are also in the set A. Notice also that if set $\\text{A}$ and $\\text{B}$ are equal, then $\\text{A}$ is a subset of $\\text{B}$ and $\\text{B}$ is a subset of $\\text{A}$ as well!\nLike the isDisjoint operation above, we can compute the isSubset operation using the intersection of sets $\\text{A}$ and $\\text{B}$. If set $\\text{B}$ is equal to the intersection of sets $\\text{A}$ and $\\text{B}$, then $\\text{B}$ is a subset of $\\text{A}$.\n$$\r\\text{A} \\cap \\text{B} = \\text{B} \\implies \\text{B} \\subseteq \\text{A}\r$$ isSuperset $\\supseteq$ We say a set $\\text{A}$ is the superset of set $\\text{B}$ if all the elements of $\\text{B}$ are also elements of $\\text{A}$. You may be thinking to yourself, “this sounds a lot like the subset operation”. And you would be correct. If $\\text{B}$ is the subset of $\\text{A}$, then $\\text{A}$ is a superset of $\\text{B}$. It is saying the same thing two different ways.\nOf course, if we can compute the isSubset operation, we can use that directly to compute the isSuperset operation. Or, we can use the intersection operation as well. If set $\\text{B}$ is equal to the intersection of sets $\\text{A}$ and $\\text{B}$, then $\\text{A}$ is a superset of $\\text{B}$.\n$$\r\\text{A} \\cap \\text{B} = \\text{B} \\implies \\text{A} \\supseteq \\text{B}\r$$ Product $\\times$ The product, or Cartesian product, of two sets results in a set that includes all pairs of elements such that the first element of the pair is from the first set and the second is from the second set. Let’s give a quick example to make this easier to understand. We denote a pair of elements as $(a,b)$, where $a$ is the first element in the pair and $b$ is the second element in the pair.\nWe start with two sets, $\\text{A}$ and $\\text{B}$ as defined below.\n$$\r\\text{A} = \\{ 1, 2 \\} \\\\\r\\text{B} = \\{ a, b, c \\}\r$$ Then the Cartesian product of $\\text{A}$ and $\\text{B}$ is\n$$\r\\text{A} \\times \\text{B} = \\{ (1,a), (1,b), (1,c), (2,a), (2,b), (2,c) \\}\r$$ And the Cartesian product of $\\text{B}$ and $\\text{A}$ is\n$$\r\\text{B} \\times \\text{A} = \\{ (a,1), (a, 2), (b,1), (b,2), (c,1), (c,2) \\}\r$$ Another way to think about the product is to consider a matrix where the columns are the elements of the first set and the rows are elements of the second set. Then, each cell in the matrix contains the ordered pair where the first element is the column and the second element is the row. The matrix for our example would look like the following.\nPowerset The powerset of set $\\text{A}$ is the set of all possible subsets of $\\text{A}$ and is denoted as $\\wp(\\text{A})$. If we start with the set $\\text{A} = \\{ 1, 2, 3 \\}$, then its powerset is\n$$\r\\{ \\emptyset, \\{1 \\}, \\{2 \\}, \\{3 \\}, \\{1, 2 \\}, \\{1, 3 \\}, \\{2, 3 \\}, \\{1, 2, 3 \\} \\}\r$$ Notice that the empty set, $\\emptyset$, is a subset of the powerset of $\\text{A}$ as well.",
    "description": "Now that we can create and show sets of various types of elements, there are a few interesting operations that we can perform on sets. Given two sets, $\\text{A}$ and $\\text{B}$, we can perform the following operations:\nUnion $\\cup$ — a set with all the elements from both sets, Intersection $\\cap$ — a set with only elements that are in both sets, Difference $\\setminus$ — a set with the elements in one set that are not in the other, Disjoint $\\text{A} \\cap \\text{B} = \\emptyset$ — two sets don’t share any elements in common Subset $\\subseteq$ — one set is completely contained in another set Superset $\\supseteq$ — one set completely contains another set Product $\\times$ — a set of all the ordered pairs where the first element is from the first set and second element is from the second set, and Powerset $\\wp$ — a set of all the subsets of a given set.",
    "tags": [],
    "title": "Operations on Sets",
    "uri": "/cc310/10-sets/2-operations-on-sets/"
  },
  {
    "breadcrumb": "Queues",
    "content": " The name for queues comes the word in British English used to describe a line of people. Instead of forming lines to wait for some service, British form queues. Thus, when we think of queues, often the first picture to come to mind is a group of people standing in a line. Of course, this is exactly how a computer queue operates as well. The first person in line gets served first. If I get into line before you do, then I will be served before you do.\n^[File:BNSF GE Dash-9 C44-9W Kennewick - Wishram WA.jpg. (2019, July 1). Wikimedia Commons, the free media repository. Retrieved 19:30, March 30, 2020 from https://commons.wikimedia.org/w/index.php?title=File:BNSF_GE_Dash-9_C44-9W_Kennewick_-_Wishram_WA.jpg\u0026oldid=356754103.]\nOf course, there are other examples of queues besides lines of people. You can think of a train as a long line of railway cars. They are all connected and move together as the train engine pulls them. A line of cars waiting to go through a toll booth or to cross a border is another good example of a queue. The first car in line will be the first car to get through the toll booth. In the picture below, there are actually several lines.\n^[File:El Paso Ysleta Port of Entry.jpg. (2018, April 9). Wikimedia Commons, the free media repository. Retrieved 19:30, March 30, 2020 from https://commons.wikimedia.org/w/index.php?title=File:El_Paso_Ysleta_Port_of_Entry.jpg\u0026oldid=296388002.]",
    "description": "The name for queues comes the word in British English used to describe a line of people. Instead of forming lines to wait for some service, British form queues. Thus, when we think of queues, often the first picture to come to mind is a group of people standing in a line. Of course, this is exactly how a computer queue operates as well. The first person in line gets served first.",
    "tags": [],
    "title": "Queues in the Real World",
    "uri": "/cc310/8-queues/2-queues-in-the-real-world/"
  },
  {
    "breadcrumb": "Stacks",
    "content": " So, where do we see stacks in the real world? A great example is repairing an automobile. It is much easier to put a car back together if we put the pieces back on in the reverse order we took them off. Thus, as we take parts off a car, it is highly recommended that we lay them out in a line. Then, when we are ready to put things back together, we can just start at the last piece we took off and work our way back. This operation is exactly how a stack works.\nAnother example is a stack of chairs. Often in schools or in places that hold different types of events, chairs are stacked in large piles to make moving the chairs easier and to make their storage more efficient. Once again, however, if we are going to put chairs onto the stack or remove chairs from the stack, we are going to have to do it from the top.",
    "description": "So, where do we see stacks in the real world? A great example is repairing an automobile. It is much easier to put a car back together if we put the pieces back on in the reverse order we took them off. Thus, as we take parts off a car, it is highly recommended that we lay them out in a line. Then, when we are ready to put things back together, we can just start at the last piece we took off and work our way back.",
    "tags": [],
    "title": "Stacks in the Real World",
    "uri": "/cc310/5-stacks/2-stacks-in-the-real-world/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome! This page is the main page for Programming by Contract and Introduction to Performance",
    "description": "Welcome! This page is the main page for Programming by Contract and Introduction to Performance",
    "tags": [],
    "title": "Programming by Contract and Introduction to Performance",
    "uri": "/cc310/3-programming-by-contract-and-introduction-to-performance/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " As you might guess from its name, object-oriented programming languages are made to create and manipulate entities called objects. But what exactly are these objects? Objects were created to help decompose large complex programs with a lot of complex data into manageable parts.\nObject An object is a programming entity that contains related data and behavior.\nA good example of an object is dog. But not just any dog, or all dogs, but a specific dog. Each dog has specific characteristics that are captured as data such as their name, their height, their weight, their breed, their age, etc. We call these characteristics attributes and all dogs have the same type of attributes, although the values of those attributes may be unique. And generally, all dogs exhibit the same behaviors, or methods. Almost all dogs can walk, run, bark, eat, etc.\nSo, how do we define the basic attributes and behaviors of a dog? We probably start with some kind of idea of what a dog is. How do we describe dogs in general. In object orientation we do that through classes.\nClass A class is a blueprint for an object.\nWhat do we use blueprints for? Well, when we are building a physical structure such as a home or office building, an architect first creates a blueprint that tells the builder what to build and how everything should fit together. That is essentially what a class does. A class describes the types of attributes and methods that an object of that class will have.\nThen to create objects, we say we create an instance of a class by calling the class’s constructor method, which creates an object instance in memory and makes sure it’s attributes are properly created. Once the object has been created, the methods defined by the class can be used to manipulate the attributes and internal data of the object.",
    "description": "As you might guess from its name, object-oriented programming languages are made to create and manipulate entities called objects. But what exactly are these objects? Objects were created to help decompose large complex programs with a lot of complex data into manageable parts.\nObject An object is a programming entity that contains related data and behavior.\nA good example of an object is dog. But not just any dog, or all dogs, but a specific dog.",
    "tags": [],
    "title": "Classes \u0026 Objects",
    "uri": "/cc310/02-oop-review/03-class-object/"
  },
  {
    "breadcrumb": "Performance",
    "content": " One of the best ways to compare data structures is to look at the common operations that they can perform. For this analysis, we’ve chosen to analyze the following four operations:\nInsert – inserting a specific element into the structure, either in sorted order, or at the appropriate place as required by the definition of a stack or queue. Access – accessing a desired element. For general data structures, this is the process of accessing an element by its index or key in the structure. For stacks and queues, this is the process of accessing the next element to be returned. Find – this is the process of finding a specific element in the data structure, usually by iterating through it or using a binary search method if the structure is sorted Delete – this is the process of deleting a specific element in the case of a general-purpose structure or deleting and returning the next element in the case of a stack or queue. The following table compares the best- and worst-case processing time for many common data structures and operations, expressed in terms of $N$, the number of elements in the structure.\nData Structure Insert Best Insert Worst Access Best Access Worst Find Best Find Worst Delete Best Delete Worst Unsorted Array $1$ $1$ $1$ $1$ $N$ $N$ $N$ $N$ Sorted Array $\\text{lg}(N)$ $N$ $1$ $1$ $\\text{lg}(N)$ $\\text{lg}(N)$ $\\text{lg}(N)$ $N$ Array Stack (LIFO) $1$ $1$ $1$ $1$ $N$ $N$ $1$ $1$ Array Queue (FIFO) $1$ $1$ $1$ $1$ $N$ $N$ $1$ $1$ Unsorted Linked List $1$ $1$ $N$ $N$ $N$ $N$ $N$ $N$ Sorted Linked List $N$ $N$ $N$ $N$ $N$ $N$ $N$ $N$ Linked List Stack (LIFO) $1$ $1$ $1$ $1$ $N$ $N$ $1$ $1$ Linked List Queue (FIFO) $1$ $1$ $1$ $1$ $N$ $N$ $1$ $1$ Hash Table $1$ $N$ $1$ $N$ $N$ $N$ $1$ $N$ We can also compare these processing times by graphing the equations used to describe them. The graph below shows several of the common orders that we have seen so far.\nOn the next few pages, we will discuss each data structure in brief, using this table to compare the performance of the various data structures we’ve covered in this course.",
    "description": "One of the best ways to compare data structures is to look at the common operations that they can perform. For this analysis, we’ve chosen to analyze the following four operations:\nInsert – inserting a specific element into the structure, either in sorted order, or at the appropriate place as required by the definition of a stack or queue. Access – accessing a desired element. For general data structures, this is the process of accessing an element by its index or key in the structure.",
    "tags": [],
    "title": "Comparing Data Structures",
    "uri": "/cc310/12-performance/3-comparing-data-structures/"
  },
  {
    "breadcrumb": "Hash Tables",
    "content": "A hash function converts a key into a hash code, which is an integer value that can be used to index our hash table array. Obviously, there are some hash functions that are better than others. Specifically, a good hash function is both easy to compute and should uniformly distribute the keys across our hash table array. Both of these are important factors in how fast our hash table operates, since we compute a hash code each time we insert or get a key-value pair from the hash table. If it takes too long to compute the hash code, we lose the benefits of having constant time insertion and retrieval operations. Likewise, if the function does not distribute the keys evenly across the table, we end up with several keys in the same bucket, which causes longer times to retrieve key-value pairs.\nA good hash function should have three important properties.\nUniform: the input values should uniformly map to the output range. Efficient: the hash function should be fast to compute. Deterministic: the hash function should always compute the same value for a given input. Luckily, many modern programming languages provide native support for hash functions. Both Java and Python provide built-in hashing functions. These functions take any object and produce an integer, which we then use with the modulo operator to reduce it to the appropriate size for our array capacity. An example of how to use the Java hashCode function is shown below. More information on the Java hashCode function can be found here.\npublic int computeIndex(Object key){ return key.hashCode() % this.getCapacity(); }An example of using Python’s hash function is shown below. More information on hashing in Python and the hash function can be found here.\ndef compute_index(self, key): return hash(key) % self.capacity Tip Hashing Passwords Another interesting use of hash functions deals with storing and verifying passwords. When we sign up for an account on a website, it asks us for a password that we’d like to use. Obviously, if that website just stored the password directly in their database, it could be a huge security problem if someone was able to gain access to that information. So, how can the website store a password in a way that prevents a hacker from learning our password, but the website can verify that we’ve entered the correct password?\nIn many cases, we can use a hash function to do just that. When we first enter our password, the website calculates the hash code for the password and then stores the result in the database.\nThen, when we try to log in to the website in the future, we provide the same password, and the website is able to calculate the hash again and verify that they match. As long as the hash function is properly designed, it is very unlikely for two passwords to result in the same hash, even if they are very similar.\nIn practice, most websites add additional random data to the password before hashing it, just to decrease the chances of two passwords hashing to the same value. This is referred to as “salting” the password.\nKeys Keys allow us to easily differentiate between data items that have different values. For example, if we wanted to store student data such as first name, last name, date of birth, and identification number, it would be convenient to have one piece of data that could differentiate between all the students. However, some data are better suited to be keys than others. In general, the student’s last name tends to be more selective than the first name. However, the student identification number is even better since it is guaranteed to be unique. When a key is guaranteed to be unique, we call them primary keys. The efficiency of a key is also important. Numeric keys are more efficient than alphanumeric keys since computing hash codes with numbers is faster than computing them with characters.",
    "description": "A hash function converts a key into a hash code, which is an integer value that can be used to index our hash table array. Obviously, there are some hash functions that are better than others. Specifically, a good hash function is both easy to compute and should uniformly distribute the keys across our hash table array. Both of these are important factors in how fast our hash table operates, since we compute a hash code each time we insert or get a key-value pair from the hash table.",
    "tags": [],
    "title": "Hash Functions",
    "uri": "/cc310/11-hash-tables/3-hash-functions/"
  },
  {
    "breadcrumb": "Recursion",
    "content": " function REVERSE2()\t(1) read CHARACTER\t(2) if CHARACTER == `*` then\t(3) return\t(4) else\t(5) print CHARACTER\t(6a) REVERSE2()\t(7a) return\t(8) end if (9) end function\t(10) The REVERSE2 function in the previous quiz actually prints the characters entered by the user in the same order in which they are typed. Notice how this small variation in the instruction order significantly changed the outcome of the function. To get a better understanding of why this occurs, we will delve into the order of execution in a little more depth.\nHead and Tail Recursion From the output of our original REVERSE function, we could argue that recursive function calls are carried out in a LIFO (last in, first out) order. Conversely, the output of the second version of the function REVERSE2, would lead us to believe that recursive function calls are carried out in FIFO (first in, first out) order. However, the ordering of the output is really based on how we structure our code within the recursive function itself, not the order of execution of the recursive functions.\nTo produce a LIFO ordering, we use a method called head recursion, which causes the function to make a recursive call first, then calculates the results once the recursive call returns. To produce a FIFO ordering, we use a method called tail recursion, which is when the function makes all of its necessary calculations before making a recursive call. With the REVERSE and REVERSE2 functions, this is simply a matter of swapping lines 6 and 7.\nWhile some functions require the use of either head or tail recursion, many times we have the choice of which one to use. The choice is not necessarily just a matter of style, as we shall see next.\nTracing Program Execution Before we finish our discussion of head and tail recursion, we need to make sure we understand how a recursive function actually works in the computer. To do this, we will use a new example. Let’s assume we want to print all numbers from 0 to $N$, where $N$ is provided as a parameter. A recursive solution to this problem is shown below.\nfunction OUTPUT(integer N)\t(1) if N == 0 then\t(2) print N\t(3) else\t(4) print \"Calling to OUTPUT \" N-1\t(5) OUTPUT(N-1)\t(6) print \"Returning from OUTPUT \" N-1\t(7) print N\t(8) end if (9) return\t(10) end function\t(11) Notice that we have added some extra print statements (lines 5 and 7) to the function just to help us keep track of when we have called OUTPUT and when that call has returned. This function is very similar to the REVERSE function above, we just don’t have to worry about reading a character each time the function runs. Now, if we call OUTPUT with an initial parameter of 3, we get the following output. We’ve also marked these lines with letters to make the following discussion simpler.\nCalling to OUTPUT 2\t(a)\rCalling to OUTPUT 1\t(b)\rCalling to OUTPUT 0\t(c)\r0\t(d)\rReturning from OUTPUT 0\t(e)\r1\t(f)\rReturning from OUTPUT 1\t(g)\r2\t(h)\rReturning from OUTPUT 2\t(i)\r3\t(j) Lines a, b, and c show how the function makes all the recursive calls before any output or computation is performed. Thus, this is an example of head recursion which produces a LIFO ordering.\nOnce we get to the call of OUTPUT(0), the function prints out 0 (line d) and we start the return process. When we return from the call to OUTPUT(0) we immediately print out N, which is 1 and return. We continue this return process from lines g through j and eventually return from the original call to OUTPUT having completed the task.\nLooking Under the Covers Now that we have seen how recursion works in practice, we will pull back the covers and take a quick look at what is going on underneath. To be able to call the same function over and over, we need to be able to store the appropriate data related to each function call to ensure we can treat it as a unique instance of the function. While we do not make copies of the code, we do need to make copies of other data. Specifically, when function A calls function B, we must save the following information:\nthe memory address of the current parameters, the address of the statement in function A to be executed when B returns (called the return address), the address of the memory location that will contain the value returned by the function (the value address), and all the local variables of function B. We call this information the activation record for function A. When a call to B is made, this information is stored in a stack data structure known as the activation stack, and execution begins at the first instruction in function B. Upon completion of function B, the following steps are performed.\nThe return address is read from the activation stack. The information stored about function B is removed from the activation stack, leaving the information stored for function A on top of the stack. Execution begins at the return address in function A. Next, we will look at how we use the activation stack to implement recursion. For this we will use a simple MAIN program that calls our simplified OUTPUT function (where we have removed all the print statements used to track our progress).\nfunction MAIN() OUTPUT(3) (1) print (\"Done\")\t(2) end function function OUTPUT(integer N) if N == 0 then\t(1) print N\t(2) else\t(3) OUTPUT(N-1)\t(4) print N\t(5) end if (6) return\t(7) end function When we run MAIN, the only record on the activation stack is the record for MAIN. Since it has not been “called” from another function, it does not contain a return address. It also has no local variables, so the record is basically empty as shown below.\nHowever, when we execute line 1 in MAIN, we call the function OUTPUT with a parameter of 3. This causes the creation of a new function activation record with the return address of line 3 in the calling MAIN function and a parameter for N, which is 3. Again, there are no local variables in OUTPUT. The stack activation is shown in figure a below.\na b c d Following the execution for OUTPUT, we will eventually make our recursive call to OUTPUT in line 4, which creates a new activation record on the stack as shown above in b. This time, the return address will be line 5 and the parameter N is 2.\nExecution of the second instance of OUTPUT will follow the first instance, eventually resulting in another recursive call to OUTPUT and a new activation record as shown in c above. Here the return address is again 5 but now the value of parameter N is 1. Execution of the third instance of OUTPUT yields similar results, giving us another activation record on the stack d with the value of parameter N being 0.\nFinally, the execution of the fourth instance of OUTPUT will reach our base case of N == 0. Here we will write 0 in line 2 and then return. This return will cause us to start execution back in the third instance of OUTPUT at the line indicated by the return value, or in this case, 5. The stack activation will now look like e in the figure below.\ne f g h When execution begins in the third instance of OUTPUT at line 5, we again write the current value of N, which is 1, and we then return. We follow this same process, returning to the second instance of OUTPUT, then the first instance of OUTPUT. Once the initial instance of OUTPUT completes, it returns to line 2 in MAIN, where the print(\"Done\") statement is executed and MAIN ends.\nPerformance While recursion is a very powerful technique, its expressive power has an associated cost in terms of both time and space. Anytime we call a function, a certain amount of memory space is needed to store information on the activation stack. In addition, the process of calling a function takes extra time since we must store parameter values and the return address, etc. before restarting execution. In the general case, a recursive function will take more time and more memory than a similar function computed using loops.\nRecursion Versus Iteration It is possible to demonstrate that any function with a recursive structure can be transformed into an iterative function that uses loops and vice versa. It is also important to know how to use both mechanisms because there are advantages and disadvantages for both iterative and recursive solutions. While we’ve discussed the fact that loops are typically faster and take less memory than similar recursive solutions, it is also true that recursive solutions are generally more elegant and easier to understand. Recursive functions can also allow us to find solutions to problems that are complex to write using loops.",
    "description": "function REVERSE2()\t(1) read CHARACTER\t(2) if CHARACTER == `*` then\t(3) return\t(4) else\t(5) print CHARACTER\t(6a) REVERSE2()\t(7a) return\t(8) end if (9) end function\t(10) The REVERSE2 function in the previous quiz actually prints the characters entered by the user in the same order in which they are typed. Notice how this small variation in the instruction order significantly changed the outcome of the function. To get a better understanding of why this occurs, we will delve into the order of execution in a little more depth.",
    "tags": [],
    "title": "Implementing Recursion",
    "uri": "/cc310/6-recursion/3-implementing-recursion/"
  },
  {
    "breadcrumb": "",
    "content": "The big introduction to new content!",
    "description": "The big introduction to new content!",
    "tags": [],
    "title": "Introduction to Data Structures \u0026 Algorithms",
    "uri": "/cc310/03-intro-dsa/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "The list data structure is the simplest form of a linear data structure. As we can guess from the definition, a list is simply a grouping of data that is presented in a given order. With lists, not only do the elements in the list matter, but the order matters as well. It’s not simply enough to state that elements $8$, $6$ and $7$ are in the list, but generally we also know that $8$ comes before $6$, which comes before $7$.\nWe’ve already learned about arrays, which are perfect examples of lists in programming. In fact, Python uses the data type list in the same way most other programming languages use arrays. Other programming languages, such as Java, provide a list data structure through their standard libraries.\nList Operations One important way to classify data structures is by the operations they can perform on the data. Since a list is the simplest version of a linear data structure, it has several important operations it can perform:\ninsert - inserts an element anywhere in the list, including at the beginning or the end; remove - removes an element from anywhere in the list, including at the beginning or the end; find - finds the location of the given element in the list, usually given as an index just like an array index; get - returns the element at a given location, similar to using an array index to retrieve an element from an array; and size - returns the number of elements in the list. For example, let’s look at the insert operation. Assume we have the list shown in the following diagram:\nThen, we decide we’d like to add the element $4$ at index $3$ in this list. So, we can think of this like trying to place the element in the list as shown below:\nOnce we insert that element, we then shift all of the other elements back one position, making the list one element larger. The final version is shown below:\nLists are a very powerful data structure, and one of the most commonly used in a variety of programs. While arrays may seem very flexible, their static size and limited operations can sometimes make them more difficult to use than they are worth. Many programmers choose to use the more flexible list data structure instead.\nWhen to Use a List When deciding which data structure to use, lists are best when we might be adding or removing data from anywhere in the list, but we want to maintain the ordering between elements. As we’ll see on the later pages, we can have more specific types of structures for particular ways we intend to add and remove data from our structure, but lists are a great choice if neither of those are a good fit.",
    "description": "The list data structure is the simplest form of a linear data structure. As we can guess from the definition, a list is simply a grouping of data that is presented in a given order. With lists, not only do the elements in the list matter, but the order matters as well. It’s not simply enough to state that elements $8$, $6$ and $7$ are in the list, but generally we also know that $8$ comes before $6$, which comes before $7$.",
    "tags": [],
    "title": "Lists",
    "uri": "/cc310/03-intro-dsa/03-lists/"
  },
  {
    "breadcrumb": "Lists",
    "content": "The Problem With Arrays To this point, we have been using arrays as our underlying data structures for implementing linear data structures such as stacks and queues. Given that with stacks and queues we only put items into the array and remove from either the start or end of the data structure, we have been able to make arrays work. However, there are some drawbacks to using arrays for stacks and queues as well as for more general data structures.\nWe can run out of room in our array for our stacks or queues. There is no good way to use memory efficiently. We have to use expensive “double” and “halve” capacity operations for stacks and queues when we need to use more or less memory. Inserting an item into the middle of a sorted list will be very costly in memory. In an array, we will have to move several items to keep the list in order. While drawbacks 1 and 2 above can be overcome (albeit rather awkwardly) when using arrays for stacks and queues, drawback 3 becomes a real problem when trying to use more general list structures. If we insert an item into the middle of an array, we must move several other items “down” the array to make room.\nIf for example, if we want to insert the number 5 into the sorted array shown below, we have to carry out several steps:\nFind the index of the first item whose value is greater than the number we want to insert into the array. We will call this index i, Shift each item from index i to the end of the list down one place location in the array, Insert the new item into the array at index i, and Update the index to the tail of the list. In our example, step 1 will loop through each item of the array until we find the first number in the array greater than 5. As shown below, the number 7 is found in index 3.\nNext, we will use another loop to move each item from index i to the end of the array down by one index number as shown below.\nFinally, we will insert our new number, 5, into the array at index 3 and increment tail to 8.\nIn this operation, if we have $N$ items, we either compare or move all of them, which would require $N$ operations. Of course, this operation runs in order $N$ time.\nThe same problem occurs when we remove an item from the array. In this case we must perform the following steps:\nSearch the array to find the first occurrence of the desired number to remove, Continue searching until we find the last occurrence of the desired number to remove, Shift each item after the last occurrence of our desired number “up” the array, once for each desired number being removed from the array, and Update the index to the tail of the list. A More Flexible Approach Instead of using arrays to try to hold our lists, a more flexible approach is to build our own list data structure that relies on a set of objects that are all linked together through references to each other. In the figure below we have created a list of numbers that are linked to each other. Each object contains both the number as well as a reference to the next number in the list. Using this structure, we can search through each item in the list by starting sequentially from the beginning and performing a linear search much like we did with arrays. However, instead of explicitly keeping track of the end of the list, we use the convention that the reference in the last item of the list is set to 0, which we call null. If a reference is set to null we interpret this to mean that there is no next item in the list. This “linked list” structure also makes inserting items into the middle of the list easier. All we need to do is find the location in the list where we want to insert the item and then adjust the references to include the new item into the list.\nThe following figure shows a slightly more complex version of a linked list, called a “doubly linked list”. Instead of just having each item in the list reference the next item, it references the previous item in the list as well. The main advantage of doubly linked lists is that we can easily traverse the list in either the forward or backward direction. Doubly linked lists are useful in applications to implement undo and redo functions, and in web browser histories where we want the ability to go forward and backward in the history.\nWe will investigate each of these approaches in more detail below and will reimplement both our stack and queue operations using linked lists instead of arrays.",
    "description": "The Problem With Arrays To this point, we have been using arrays as our underlying data structures for implementing linear data structures such as stacks and queues. Given that with stacks and queues we only put items into the array and remove from either the start or end of the data structure, we have been able to make arrays work. However, there are some drawbacks to using arrays for stacks and queues as well as for more general data structures.",
    "tags": [],
    "title": "Lists in Code",
    "uri": "/cc310/9-lists/3-lists-in-code/"
  },
  {
    "breadcrumb": "Queues",
    "content": " How do we implement queues in code? Like we did with stacks, we will use an array, which is an easily understandable way to implement queues. We will store data directly in the array and use special start and end variables to keep track of the start of the queue and the end of the queue.\nThe following figure shows how we might implement a queue with an array. First, we define our array myQueue to be an array that can hold 10 numbers, with an index of 0 to 9. Then we create a start variable to keep track of the index at the start of the queue and an end variable to keep track of the end of the array.\nNotice that since we have not put any items into the queue, we initialize start to be -1. Although this is not a legal index into the array, we can use it like we did with stacks to recognize when we have not yet put anything into the queue. As we will see, this also makes manipulating items in the array much simpler. However, to make our use of the array more efficient, -1 will not always indicate that the queue is empty. We will allow the queue to wrap around the array from the start index to the end index. We’ll see an example of this behavior later.\nWhen we want to enqueue an item into the queue, we follow the simple procedure as shown below. Of course, since our array has a fixed size, we need to make sure that we don’t try to put an item in a full array. Thus, the precondition is that the array cannot be full. Enforcing this precondition is the function of the if statement at line 1. If the array is already full, then we’ll throw an exception in line 2 and let the caller handle the situation. Next, we store item at the end location and then compute the new value of end in line 4. Line 4 uses the modulo operator % to return the remainder of the division of $(\\text{end} + 1) / \\text{length of myQueue}$. In our example, this is helpful when we get to the end of our ten-element array. If end == 9 before enqueue was called, the function would store item in myQueue[9] and then line 4 would cause end to be $(9 +1) % 10$ or $10 % 10$ which is simply $0$, essentially wrapping the queue around the end of the array and continuing it at the beginning of the array.\nfunction ENQUEUE (item)\rif ISFULL() then\t(1)\rraise exception\t(2)\rend if\tMYQUEUE[END] = ITEM\t(3)\rEND = (END + 1) % length of MYQUEUE\t(4)\rif START == -1\t(5)\rSTART = 0\t(6)\rend if\rend function Given our initial configuration above, if we performed an enqueue(7) function call, the result would look like the following.\nNotice that the value 7 was stored at myQueue[0] in line 3, end was updated to 1 in line 4, and start was set to 0 in line 7. Now, let’s assume we continue to perform enqueue operations until myQueue is almost filled as shown below.\nIf at this point, we enqueue another number, say -35, the modulo operator in line 4 would help us wrap the end of the list around the array and back to the beginning as expected. The result of this function call is shown below.\nNow we have a problem! The array is full of numbers and if we try to enqueue another number, the enqueue function will raise an exception in line 2. However, this example also gives us insight into what the isFull condition should be. Notice that both start, and end are pointing at the same array index. You may want to think about this a little, but you should be able to convince yourself that whenever start == end we will be in a situation like the one above where the array is full, and we cannot safely enqueue another number.\nTo rectify our situation, we need to have a function to take things out of the queue. We call this function dequeue, which returns the item at the beginning of the queue (pointed at by start) and updates the value of start to point to the next location in the queue. The pseudocode for the dequeue is shown below.\nfunction DEQUEUE ()\rif ISEMPTY() then\t(1)\rraise exception\t(2)\rend if ITEM = MYQUEUE[START]\t(3)\rSTART = (START + 1) % length of MYQUEUE\t(4)\rif START == END\t(5)\rSTART = -1\t(6)\rEND = 0\t(7)\rend if\rreturn ITEM\t(8)\rend function Line 1 checks if the queue is empty and raises an exception in line 2 if it is. Otherwise, we copy the item at the start location into item at line 3 and then increment the value of start by 1, using the modulo operator to wrap to the beginning of the array if needed in line 4. However, if we dequeue the last item in the queue, we will actually run into the same situation that we ran into in the enqueue when we filled the array, start == end. Since we need to differentiate between being full or empty (it’s kind of important!), we reset the start and end values back to their initial state when we dequeue the last item in the queue. That is, we set start = -1 and end = 0. This way, we will always be able to tell the difference between the queue being empty or full. Finally, we return the item to the calling function in line 8.",
    "description": "How do we implement queues in code? Like we did with stacks, we will use an array, which is an easily understandable way to implement queues. We will store data directly in the array and use special start and end variables to keep track of the start of the queue and the end of the queue.\nThe following figure shows how we might implement a queue with an array. First, we define our array myQueue to be an array that can hold 10 numbers, with an index of 0 to 9.",
    "tags": [],
    "title": "Queues in Code",
    "uri": "/cc310/8-queues/3-queues-in-code/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "To search for a single number in our array, we will use a loop to search each location in the array until we find the number. The general idea is to iterate over all the elements in the array until we either find the number we are searching for or there are no other elements in the array.\nfunction FIND(NUMBER, ARRAY)\t(1) loop INDEX from 0 to size of ARRAY - 1 (2) if ARRAY[INDEX] == NUMBER\t(3) return INDEX\t(4) end if\t(5) end for\t(6) return -1\t(7) end function\t(8)As we can see in line 1, the function takes both a number and array parameter. We then enter a for loop in line 2 to loop through each location in the array. We keep track of the current location in the array using the index variable. For each location, we compare number against the value in the array at location index. If we find the number, we simply return the value of index in line 4. If we do not find the number anywhere in the array, the loop will exit, and the function will return -1 in line 8.\nBelow is an example of how to execute this algorithm on example data. Step 1 shows the initial state of the variables in the function the first time through the loop. Both array and number are passed to the function but we do not modify either of them in the function. The index variable is the for loop variable, which is initially set to 0 the first time through the loop. In line 3, the function compares the number in array[index] against the value of number. In this step, since index is 0, we use array[0], which is 8. Since 8 is not equal to the value of number, which is 3, we do nothing in the if statement and fall to the end for statement in line 6. Of course, this just sends us back to the for statement in line 2.\nThe second time through the for loop is shown as Step 2 in the figure. We follow the same logic as above and compare array[1], or 4, against number, which is still 3. Since these values are not equal, we skip the rest of the if statement and move on to Step 3.\nIn Step 3, index is incremented to 2, thus pointing at array[2], whose value is 3. Since this value is equal to the value of number, we carry out the if part of the statement. Line 4 returns the value of 2, which is the first location in array that holds the value of number.",
    "description": "To search for a single number in our array, we will use a loop to search each location in the array until we find the number. The general idea is to iterate over all the elements in the array until we either find the number we are searching for or there are no other elements in the array.\nfunction FIND(NUMBER, ARRAY)\t(1) loop INDEX from 0 to size of ARRAY - 1 (2) if ARRAY[INDEX] == NUMBER\t(3) return INDEX\t(4) end if\t(5) end for\t(6) return -1\t(7) end function\t(8)As we can see in line 1, the function takes both a number and array parameter.",
    "tags": [],
    "title": "Searching for a Value",
    "uri": "/cc310/7-searching-and-sorting/3-searching-for-a-value/"
  },
  {
    "breadcrumb": "Sets",
    "content": " Different data structures can be used to represents sets and efficiently support their operations. Among the data structures considered so far, it is possible to use both lists and arrays to represent sets. Even though sets by definition are unordered, we could store the elements in order, which has its pros and cons. Storing elements in order will speed up the contains operation since we won’t have to check each element in the set. However, it will also slow down insertions since we have to insert the elements in order.\nFurther, storing elements in order will improve the efficiency of the union and intersection operations since we could compute both the union and the intersection in one pass (similar to merge sort). Likewise, we can speed up our searching for elements in the superset and subset operations by taking advantage of the ordering of elements.\nWhether or not keeping the elements in order makes sense for your application depends on how many times you will actually insert data into the set, versus the number of times you will be using the other set operations.\nArrays We can use arrays to store sets, much like we did for array-based stacks or queues. In fact, if we implemented an array-based list, we could implement sets directly on top of that structure. Unfortunately, if we need to keep the set elements ordered for efficiency, we would compound the inefficiency of inserting or removing items from an array since we would have to move other elements in the array each time to keep it sorted. Even if we’re not interested in sorting our set, we would still face the fixed-capacity issue and would have to manage the size of the set container using the doubleCapacity and halveCapacity operations. On the positive side, if we kept the set elements sorted in the array, we could use binary search to implement a very efficient contains operation.\nLinked Lists We can also use linked lists to implement sets. Lists provide all of the operations we need to implement the basic set operations such as insert, remove, and list iterator. The only property we need to implement is that sets do not include duplicate elements. This is easily taken care of by checking to see if the set contains an element before we insert it. Since linked lists are very flexible and don’t require us to worry about capacity issues, we will use them as the basis for our set operations in this module.",
    "description": "Different data structures can be used to represents sets and efficiently support their operations. Among the data structures considered so far, it is possible to use both lists and arrays to represent sets. Even though sets by definition are unordered, we could store the elements in order, which has its pros and cons. Storing elements in order will speed up the contains operation since we won’t have to check each element in the set.",
    "tags": [],
    "title": "Sets in Code",
    "uri": "/cc310/10-sets/3-sets-in-code/"
  },
  {
    "breadcrumb": "Stacks",
    "content": " How do we implement stacks in code? One way would be to use something we already understand, an array. Remember that arrays allow us to store multiple items, where each entry in the array has a unique index number. This is a great way to implement stacks. We can store items directly in the array and use a special top variable to hold the index of the top of the stack.\nThe following figure shows how we might implement a stack with an array. First, we define our array myStack to be an array that can hold 10 numbers, with an index of 0 to 9. Then we create a top variable that keeps track of the index at the top of the array.\nNotice that since we have not put any items onto the stack, we initialize top to be -1. Although this is not a legal index into the array, we can use it to recognize when the stack is empty, and it makes manipulating items in the array much simpler. When we want to push an item onto the stack, we follow a simple procedure as shown below. Of course, since our array has a fixed size, we need to make sure that we don’t try to put an item in a full array. Thus, the precondition is that the array cannot be full. Enforcing this precondition is the function of the if statement at the beginning of the function. If the array is already full, then we’ll throw an exception and let the user handle the situation. Next, we increment the top variable to point to the next available location to store our data. Then it is just a matter of storing the item into the array at the index stored in top.\nfunction PUSH(ITEM) if MYSTACK is full then throw exception end if TOP = TOP + 1 MYSTACK[TOP] = ITEM end function If we call the function push(a) and follow the pseudocode above, we will get an array with a stored in myStack[0] and top will have the value 0 as shown below.\nAs we push items onto the stack, we continue to increment top and store the items on the stack. The figure below shows how the stack would look if we performed the following push operations.\npush(\"b\") push(\"c\") push(\"d\") push(\"e\") Although we are implementing our stack with an array, we often show stacks vertically instead of horizontally as shown below. In this way the semantics of top makes more sense.\nOf course, the next question you might ask is “how do we get items off the stack?”. As discussed above, we have a special operation called pop to take care of that for us. The pseudocode for the pop operation is shown below and is similar in structure to the push operation.\nfunction POP if TOP == -1 then throw exception end if TOP = TOP - 1 return MYSTACK[TOP + 1] end function However, instead of checking to see if the stack is full, we need to check if the stack is empty. Thus, our precondition is that the stack is not empty, which we evaluate by checking if top is equal to -1. If it is, we simply throw an exception and let the user handle it. If myStack is not empty, then we can go ahead and perform the pop function. We simply decrement the value of top and return the value stored in myStack[top+1].\nNow, if we perform three straight pop operations, we get the following stack.",
    "description": "How do we implement stacks in code? One way would be to use something we already understand, an array. Remember that arrays allow us to store multiple items, where each entry in the array has a unique index number. This is a great way to implement stacks. We can store items directly in the array and use a special top variable to hold the index of the top of the stack.",
    "tags": [],
    "title": "Stacks in Code",
    "uri": "/cc310/5-stacks/3-stacks-in-code/"
  },
  {
    "breadcrumb": "Python Review",
    "content": "Let’s discuss some of the basic concepts we need to understand about the Python programming language.\nProgram Structure To begin, let’s look at a simple Hello World program written in Python:\ndef main(): print(\"Hello World!\") # main guard if __name__ == \"__main__\": main()This program contains multiple important parts:\nFirst, we define a function called main(). Python does not require us to do this, since we can write our code directly in the file and it will execute. However, since we are going to be building larger programs in this course, it is a good idea to start using functions now. The function definition ends with a colon :, and then the code inside of that function comes directly after it. The code contained in the function must be indented a single level. By convention, Python files should use 4 spaces to indent the code. Thankfully, Codio does that for us automatically. At the bottom of the file, we’ve included a main guard that determines if this file is being executed. If it is, it will call the main() function to run the program. Of course, this is a very brief overview for the Python programming language. To learn more, feel free to refer to the references listed below, as well as the textbook content for previous courses.\nTry It! See if you can use the code above to write your own Hello World program a file named HelloWorld.py. We’ll learn how to compile and run that program on the next page.\nReferences The Python Tutorial from Python Python Tutorial from W3Schools Python Tutorial from Tutorials Point ",
    "description": "Let’s discuss some of the basic concepts we need to understand about the Python programming language.\nProgram Structure To begin, let’s look at a simple Hello World program written in Python:\ndef main(): print(\"Hello World!\") # main guard if __name__ == \"__main__\": main()This program contains multiple important parts:\nFirst, we define a function called main(). Python does not require us to do this, since we can write our code directly in the file and it will execute.",
    "tags": [],
    "title": "Syntax Overview",
    "uri": "/cc310/01-review/03-syntax/"
  },
  {
    "breadcrumb": "Introduction",
    "content": " Resources Codio Documentation Video Script This course makes extensive use of several features of Canvas which you may or may not have worked with before. To give you the best experience in this course, this video will briefly describe those features and the best way to access them.\nWhen you first access the course on Canvas, you will be shown this homepage. It contains quick links to the course syllabus and Piazza discussion boards. This is handy if you just need to jump to a particular area.\nLet’s walk through the options in the main menu to the left. The first section is Modules, which is where you’ll primarily interact with the course. You’ll notice that I’ve disabled several of the common menu items in this course, such as Files and Assignments. This is to simplify things for you as students, so you remember that all the course content is available in one place.\nWhen you first arrive at the Modules section, you’ll see all of the content in the course laid out in order. If you like, you can minimize the modules you aren’t working on by clicking the arrow to the left of the module name. I’ll do so, leaving the introductory module open.\nAs you look at each module, you’ll see that it gives quite a bit of information about the course. At the top of each module is an item telling you what parts of the module you must complete to continue. In this case, it says “Complete All Items.” Likewise, the following modules may list a number of prerequisite modules, which you must complete before you can access it.\nWithin each module is a set of items, which must be completed in listed order. Under each item you’ll see information about what you must do in order to complete that item. For many of them, it will simply say view, which means you must view the item at least once to continue. Others may say contribute, submit, or give a minimum score required to continue. For assignments, it also helpfully gives the number of points available, and the due date.\nLet’s click on the first item, Course Introduction, to get started. You’ve already been to this page by this point. Many course pages will consist of an embedded video, followed by links to any resources used or referenced in the video, including the slides and a downloadable version of the video. Finally, a rough video script will be posted on the page for your quick reference.\nWhile I cannot force you to watch each video in its entirety, I highly recommend doing so. The script on the page may not accurately reflect all of the content in the video, nor can it show how to perform some tasks which are purely visual.\nWhen you are ready to move to the next step in a module, click the Next button at the bottom of the page. Canvas will automatically add Next and Previous buttons to each piece of content which is accessed through the Modules section, which makes it very easy to work through the course content. I’ll click through a couple of items here.\nAt any point, you may click on the Modules link in the menu to the left to return to the Modules section of the site. You’ll notice that I’ve viewed the first few items in the first module, so I can access more items here. This is handy if you want to go back and review the content you’ve already seen, or if you leave and want to resume where you left off. Canvas will put green checkmarks to the right of items you’ve completed.\nContinuing down the menu to the left, you’ll find the usual Canvas links to view your grades in the course, as well as a list of fellow students taking the course.\n===\nNow, let’s go back to Canvas and load up one of the Codio projects. To load the first Codio projects, click the Next button at the bottom of this page to go to the next part of this module, which is the Codio Introduction tutorial. On that page, there will be a button to click, which opens Codio in a new browser window or tab.\nOnce Codio loads, it should give you the option to start the Guide for that module. You’ll definitely want to select that option whenever you load a Codio project for the first time.\nFrom there, you can follow the steps in that guide to learn more about the Codio interface. The first page of the guide continues this video. I’ll see you there!",
    "description": "Resources Codio Documentation Video Script This course makes extensive use of several features of Canvas which you may or may not have worked with before. To give you the best experience in this course, this video will briefly describe those features and the best way to access them.\nWhen you first access the course on Canvas, you will be shown this homepage. It contains quick links to the course syllabus and Piazza discussion boards.",
    "tags": [],
    "title": "Navigating Canvas \u0026 Codio",
    "uri": "/cc310/00-introduction/02-navigating-canvas-codio/"
  },
  {
    "breadcrumb": "Performance",
    "content": " Unsorted Array An unsorted array is the most basic data structure, and it is supported by nearly every programming language available. Inserting elements into the array is always a constant time operation since we can simply place it at the end of the array. Of course, this assumes that the array is large enough to hold all our data without needing to be resized. Since we are not worried about memory usage, this is a safe assumption.\nLikewise, since an array allows us to access elements directly by index, we can say that the time it takes to access any single element is also a constant time operation.\nUnfortunately, searching for an element is much more difficult. Since the array is unsorted, we would have to look through each element in the array to find a specific element, making the search operation run on the order of $N$ time.\nLikewise, the process to find and delete a specific item from the list is also on the order of $N$ time, since we’d have to iterate through the list to find the element, remove it, and then shift all remaining elements forward one space in the array.\nUnsorted arrays work best when we simply need to store and access data quickly, but we are not really concerned with finding a specific element each time. Iterating across an entire array takes the same amount of time as finding a specific element, so arrays are great data structures to use when looping through data. As we saw in a previous module, we can probably search linearly through the array for a specific item as many as 7 times before it becomes more efficient to sort it first.\nSorted Array We can improve on some aspects of the performance of an unsorted array by sorting it. Thankfully, we can make it easier by just sorting the data as we insert it into the array! However, by doing so, our insert operation now runs in the order of $\\text{lg}(N)$ time in the best case. This is because it must use a binary search process to figure out where to insert the data into the array. However, in the worst case, it must also shift all the elements after the inserted element back one space, which will make the insert operation run in the order of $N$ time.\nThankfully, since the data is being stored in an array, we can still use array indexes to access single elements directly, making that operation constant time. In addition, now that the array is sorted, the process of finding a specific element is reduced to the order of $\\text{lg}(N)$ time, a vast improvement over the performance of an unsorted array.\nFinally, the process of finding and deleting a specific item can be improved to order of $\\text{lg}(N)$ time in the best case, but the worst case once again involves shifting all of the elements in the array, which is on the order of $N$ time.\nSo, while having a sorted array allows us to improve the performance of finding specific elements, many of the other operations still have poor worst-case performance. Therefore, one of the important things we must consider when choosing whether to store data in a sorted or unsorted array is the number of times we’ll be searching for specific elements vs. the number of times we’ll just be inserting or iterating across the entire array. If we do more iterating, we may want to just use an unsorted array, but if we need to search for items repeatedly, a sorted array may be a better choice from a performance standpoint.\nArray Stack (LIFO) and Array Queue (FIFO) Our array-based implementations of a stack and a queue are very performant examples of data structures based on arrays, simply because we can limit the operations that we perform to the most efficient ones possible.\nFor example, since we are only inserting in one position, the insert operation always runs in constant time. While the position may be different depending on the implementation, each data structure simply keeps track of the array index where the next one should be placed, eliminating the need to shift elements around.\nLikewise, since we are only allowed to remove elements from one position in the array, we can once again avoid the need to shift elements around. Therefore, that operation also runs in constant time for both stacks and queues.\nWe can also use the peek operation to access the next element in the stack or queue in constant time. Since it is array based, those operations only require the index of the element in the array to be known, which is a great advantage here.\nHowever, the find operation still runs in order $N$ time, since it must iterate through each element in the array to determine if the desired element exists in the structure. Thankfully, that operation is not used very often with stacks and queues since we are usually concerned only with the next element to be taken from the structure.",
    "description": "Unsorted Array An unsorted array is the most basic data structure, and it is supported by nearly every programming language available. Inserting elements into the array is always a constant time operation since we can simply place it at the end of the array. Of course, this assumes that the array is large enough to hold all our data without needing to be resized. Since we are not worried about memory usage, this is a safe assumption.",
    "tags": [],
    "title": "Arrays",
    "uri": "/cc310/12-performance/4-arrays/"
  },
  {
    "breadcrumb": "Stacks",
    "content": " We have already seen two basic stack operations: push and pop. However, there are others that make the stack much easier to use. These basic operations are:\npush: places an item on top of the stack, pop: removes the item on the top of the stack and returns it, peek: returns the item on the top of the stack without removing it from the stack, isEmpty: returns true if there are no items on the stack, and isFull: returns true if our stack array is full. We will discuss each of these operations. But first, let’s talk about the constructor for the stack class and what it must do to properly set up a stack object.\nConstructor The main responsibility of the constructor is to initialize our attributes in the stack class. As we discussed above, the attributes include the myStack array and the top attribute that keeps track of the top of the stack.\nSince we are using an array for our stack, we will need to know how big to make the array in our constructor. There are two options. We could just use a default size for the array. Or, we could allow the user to pass in a positive integer to set the size. In this module we assume the caller must provide a capacity value, which must be greater than 0.\nfunction STACKCONSTRUCTOR(CAPACITY) if CAPACITY not an integer then throw exception else if CAPACITY \u003c= 0 then throw exception end if MYSTACK = new array[CAPACITY] TOP = -1 end function The first thing we do in the code is to check to make sure that capacity is actually an integer that is greater than 0. Essentially, this is our precondition for the method. If our precondition is not met, we throw an exception. (If we are using a typed language such as Java, we can enforce our precondition by requiring that capacity be of type integer instead of explicitly checking it in the code.) Once we’ve validated our precondition, we create a new array of size capacity for the myStack array and set the attribute top to -1.\nPush We have already discussed the push operation and seen it in operation earlier in this module. In the pseudocode below, we see that we must first check to ensure that the stack is not already full. Again, this is our precondition. You may be picking up on the fact that the first thing we do in our methods is to check our precondition and throw an exception if it is not met. This is good coding practice.\nfunction PUSH(ITEM) if MYSTACK is full then throw exception end if TOP = TOP + 1 MYSTACK[TOP] = ITEM end function Once our precondition is validated, we simply increment top by 1 and store the item into the array at index top. We do not return anything from the push function. Also, notice that there are no loops in the push operation and thus the time it takes to execute the operation will always be the same regardless of the size of the myStack array. We call this constant time performance, which is typically very fast.\nPop Like push, we have already seen the pop operation. It simply takes the top item off of the stack and returns it. However, once again we need to validate our precondition before getting into the body of the operation. For the pop operation, our precondition is that the stack must not already be empty, which is detected when top equals -1.\nfunction POP if TOP == -1 then throw exception end if TOP = TOP - 1 return MYSTACK[TOP + 1] end function Once we have validated our precondition, we simply decrement top by 1 and then return the previous item at the top of the stack (myStack[top + 1]). Like the push operation, the pop operation takes a constant time to execute.\nIsFull To allow the calling program to detect when the stack is full, we define an isFull operation. Notice that code external to the stack class cannot access the value of top and so it cannot simply check if top + 1 == length of myStack on its own. In this case, the operation is very simple as we only need to return the Boolean value of top + 1 == length of myStack as shown below. There is no precondition for isFull and isFull operates in constant time.\nfunction ISFULL() return TOP + 1 == length of MYSTACK end function IsEmpty The isEmpty operation is very similar to the isFull operation except that we return the Boolean value of the condition top == -1 instead of top + 1 == length of myStack.\nPeek The peek operation returns the top item on the stack, without removing it from the stack. Like the pop operation it has the precondition that the stack must not be empty. The pseudocode for the peek operation is shown below. It is also a constant time operation.\nfunction PEEK() if ISEMTPY() then throw exception end if return MYSTACK[TOP] end function Notice that we replaced the precondition check of top == -1 with a call to isEmpty, which produces the same result. The real benefit here is the readability of the code and the fact that we only have to code the top == -1 check in the isEmpty operation. This will make it easier to maintain the code in the future if we change the way we implement the stack.\nDoubleCapacity The doubleCapacity operation doubles the size of the array holding our stack. So, if we started with an array of size 4, the doubleCapacity operation will result in an array of size 8 with the contents of our original array stored in it. Unfortunately, most programming languages (like Java) do not simply let you double the size of the array. A noted exception to this is Python, which does allow you to directly extend an array.\nIn a traditional programming language, the easiest way to accomplish the doubleCapacity operation is to complete the following steps:\nCreate a new array with twice the capacity of the existing array, Copy the contents of original array into the new array, then Point the myStack array at the new array. The pseudocode for the doubleCapacity operation is shown below.\nfunction DOUBLECAPACITY() NEWSTACK = new array[length of MYSTACK * 2] loop I from 0 to TOP NEWSTACK[i] = MYSTACK[i] end for MYSTACK = NEWSTACK end function The doubleCapacity operation is not a constant time operation. This is due to the fact that copying the contents of the original array into the new array requires us to copy each item in the stack into the new array individually. This requires N steps. Thus, we would say that doubleCapacity runs in the order of $N$ time.\nHalveCapacity The halveCapacity operation is like the doubleCapacity operation except that we now have a precondition. We must make sure that when we cut the space for storing the stack that we still have enough space to store all the items currently in the stack. For example, if we have 10 items in a stack with a capacity of 16, we can’t successfully perform halveCapacity. Doing so would only leave us a stack with a capacity of 8 and we would not be able to fit all 10 items in the new stack.\nfunction HALVECAPACITY() if TOP + 1 \u003e length of MYSTACK / 2 then throw exception end if NEWSTACK = new array[length of MYSTACK / 2] loop I from 0 to TOP NEWSTACK[i] = MYSTACK[i] end for MYSTACK = NEWSTACK end function ToString The toString operation returns a string that concatenates the strings representing all the items stored in an array. In most programming languages, each object class must implement the toString operation. For instance, in the stack below where each item is a character, if we called myStack.toString(), we would expect to be returned the string \"K-State\".\nNotice that we must read the stack array from top (right) to bottom (left) to get the proper output string. In the pseudocode below we first create an empty string and then loop through the stack from top to bottom (0) using the item’s own toString operation to create the appropriate output string. Notice that there are no preconditions for the operation. This is because if the stack is empty, the for loop is not executed and we simply return an empty string. However, because of the loop the toString operation runs in order N time.\nfunction TOSTRING() OUTPUT = \"\" loop I from TOP to 0 OUTPUT = OUTPUT + MYSTACK[I].TOSTRING() end for return OUTPUT end function ",
    "description": "We have already seen two basic stack operations: push and pop. However, there are others that make the stack much easier to use. These basic operations are:\npush: places an item on top of the stack, pop: removes the item on the top of the stack and returns it, peek: returns the item on the top of the stack without removing it from the stack, isEmpty: returns true if there are no items on the stack, and isFull: returns true if our stack array is full.",
    "tags": [],
    "title": "Basic Operations",
    "uri": "/cc310/5-stacks/4-basic-operations/"
  },
  {
    "breadcrumb": "Queues",
    "content": " We have already seen the pseudocode for the two key operations for queues: enqueue and dequeue. However, there are several others that make the queue data structure much easier to use:\nenqueue—places an item on the end of the queue, dequeue—removes and returns the item at the start of the queue, peek—returns the item at the start of the queue without removing it, isEmpty—returns true if there are no items in the queue, isFull—returns true if our queue array is full, and size—returns the number of items in the queue. We will discuss each of these operations. But first, let’s talk about the constructor for the queue class and what it must do to properly set up a queue object.\nConstructor The main responsibility of the constructor is to initialize all the attributes in the queue class. As we discussed above, the attributes include the myQueue array and the start and end variables that hold indexes into myQueue.\nSince we are using an array for our queue, we will need to know how big to make the array in our constructor. There are two options. We could just use a default size for the array. Or, we could allow the user to pass in a positive integer to set the size. In this module we assume the caller must provide a capacity value, which must be greater than 0.\nfunction QUEUE (CAPACITY) if CAPACITY is not an integer then\t(1) throw exception\t(2) else if CAPACITY \u003c= 0 then\t(3) throw exception\t(4) end if MYQUEUE = new array of size capacity\t(5) START = -1\t(6) END = 0\t(7) end function The first thing we do in the code is to check to make sure that capacity is actually an integer that is greater than 0. Essentially, this is our precondition for the method. If our precondition is not met, we throw an exception. (If we are using a typed language such as Java, we can enforce our precondition by requiring that capacity be of type integer instead of explicitly checking it in the code.) Once we’ve validated our precondition, we create a new array of size capacity for the myQueue array and set the attribute start to -1 and end to 0.\nEnqueue We have already discussed the enqueue operation and seen it in operation above. In the pseudocode below, we see that we must first check to ensure that the queue is not already full. Again, this is our precondition.\nfunction ENQUEUE (item)\rif ISFULL() then\t(1)\rraise exception\t(2)\rend if\tMYQUEUE[END] = ITEM\t(3)\rEND = (END + 1) % length of MYQUEUE\t(4)\rif START == -1\t(5)\rSTART = 0\t(6)\rend if\rend function Once our precondition is validated, we simply increment and store the item into the array at index end. Then we increment end, using the modulo operator to wrap end to point to the beginning of the array if warranted. Next, we check for the condition of an empty queue. If start = 1, then we know the queue is empty, so we set start = 0. The enqueue function does not return a value.\nBecause there are no loops in the enqueue function, the function operates in constant time regardless of the size of the array or the number of items in it.\nDequeue Like enqueue, we have already seen the dequeue operation. It simply takes the first item from the start of the queue and returns it. However, before we can do that, we need to validate our precondition. For the dequeue operation, our precondition is that the queue must not already be empty, which is detected by the isEmpty function in line 1.\nfunction DEQUEUE ()\rif ISEMPTY() then\t(1)\rraise exception\t(2)\rend if ITEM = MYQUEUE[START]\t(3)\rSTART = (START + 1) % length of MYQUEUE\t(4)\rif START == END\t(5)\rSTART = -1\t(6)\rEND = 0\t(7)\rend if\rreturn ITEM\t(8)\rend function Once we have validated our precondition, we simply copy the item from the myQueue[start] in line 3 and increment start. Again, we use the modulo operator in line 4 to wrap start back to 0 if it is needed. Next, we check to see if the myQueue is empty, and, if it is, reset the values of start and end back to their initial values. Finally, we return the item to the calling function in line 8. Like the enqueue operation, the dequeue function operates in constant time.\nPeek The peek operation returns the item at the start of the queue, without removing it from the array. Like the dequeue operation it has the precondition that the queue must not be empty. The pseudocode for the peek operation is shown below. It is also a constant time operation.\nfunction PEEK()\t(1) if ISEMPTY() then\t(2) raise exception\t(3) else\treturn MYQUEUE[START]\t(4) end if end function isFull To allow the calling program to detect when the queue is full, we define an isFull operation. Notice that code external to the queue class cannot access the value of start or end so it cannot simply check if start == end on its own. In this case, the operation is very simple as we only need to return the Boolean value of start == end as shown below. There is no precondition for isFull and isFull operates in constant time.\nfunction ISFULL() return START == END\t(1) end function isEmpty The isEmpty operation is very similar to the isFull operation except that we return the Boolean value of the condition start == -1 instead of start == end.\nfunction ISEMPTY() return START == -1\t(1) end function Size This size method returns the number of items in the queue. However, it is not as straightforward as it might sound. Actually, there are several cases that we must consider, based on the fact that both start and end can “wrap around” the end of the array:\nstart == -1—the queue is empty, and size = 0, start == end—the queue is full, and size equals the capacity of the array, start \u003c end—size = end – start, and start \u003e end—size = capacity of array - start + end + 1. Thus, in our function, we simply need to check four conditions.\nfunction SIZE() if START = -1\t(1) return 0\t(2) else if START == END\t(3) return capacity of MYQUEUE\t(4) else if START \u003c END\t(5) return END – START\t(6) else\treturn capacity of MYQUEUE – START + END\t(7) end if end function Notice that the conditions that are checked in lines 3 and 5 ensure that start must be greater than end. Therefore, we can simply use an else statement to capture the last case in line 7. Once again, this is a constant time function.\ndoubleCapacity The doubleCapacity operation doubles the size of the array holding our queue. If we started with an array of size 4, the doubleCapacity operation will result in an array of size 8 with the contents of our original array stored in it. Unfortunately, most programming languages (like Java) do not simply let you double the size of the array. A noted exception to this is Python, which does allow you to directly extend an array.\nIn a traditional programming language, the easiest way to accomplish the doubleCapacity operation is to complete the following steps:\nCreate a new array with twice the capacity of the existing array, Copy the contents of original array into the new array, Update the start and end variables to point at the correct elements, then Point the myQueue array at the new array. The pseudocode for the doubleCapacity operation is shown below.\nfunction DOUBLECAPACITY() NEWQUEUE = new array of MYQUEUE capacity * 2\t(1) LENGTH = SIZE()\t(2) for I = 0 to LENGTH - 1\t(3) NEWQUEUE[I] = DEQUEUE()\t(4) end for START = 0\t(5) END = LENGTH\t(6) MYQUEUE = NEWQUEUE\t(7) end function In the function, we create the new array in line 1 and then save the total number of items in the array for use later in line 2. Next, we use a for loop in lines 3 and 4 to copy the contents from myQueue into newQueue. Since the contents of myQueue are not necessarily stored neatly in the array (i.e., from $0$ to $n$), it is easier for us to use the existing size and dequeue functions to get access to each item in the queue in order. Once we have copied the items from myQueue to newQueue, we simply need to set the start and end variables in line 5 and 6, and then set myQueue = newQueue in line 7 to complete the process.\nThe doubleCapacity operation is not a constant time operation since copying the contents of the original array into the new array requires us to copy each item via a loop. This requires $N$ steps. Thus, we would say that doubleCapacity runs in “order $N$” time.\nhalveCapacity The halveCapacity operation is similar to the doubleCapacity operation except that we now have a precondition. We must make sure that when we reduce the space for storing the queue that we still have enough space to store all the items currently in the queue. For example, if we have 10 items in a queue with a capacity of 16, we can’t successfully perform halveCapacity. Doing so would only leave us a queue with a capacity of 8 and we would not be able to fit all 10 items in the new queue.\nThe pseudocode for the halveCapacity function is shown below, with the precondition being checked in line 2. Once we create newQueue to be half the capacity of myQueue in line 4, the remainder of the function is exactly the same as the doubleCapacity function, since lines 5-10 are just concerned with copying the items from myQueue to newQueue and setting the associated variables.\nfunction HALVECAPACITY() if SIZE() \u003e MYQUEUE capacity / 2 then\t(2) throw exception\t(3) end if NEWQUEUE = new array of MYQUEUE capacity / 2\t(4) LENGTH = SIZE()\t(5) for I = 0 to LENGTH - 1\t(6) NEWQUEUE[I] = DEQUEUE()\t(7) end for START = 0\t(8) END = LENGTH % length of NEWQUEUE\t(9) MYQUEUE = NEWQUEUE\t(10) end function Like the doubleCapacity operation, halveCapacity is not a constant time operation since copying the contents of the original array requires us to loop $N$ times. So, halveCapacity runs in “order $N$” time.\ntoString The toString function returns a string that concatenates the strings representing all the items stored in an array. In most programming languages, each object class must implement the toString operation. For instance, in the queue below where each item is a character, if we called myQueue.toString(), we would expect to be returned the string \"Wildcats\".\nNotice that we must read the queue array from start to end to get the proper output string.\nIn the pseudocode below we first create an empty string called output in line 1. Then, we create a loop in line 2 that counts using i the number of items in the queue from 0 to the size of the queue. However, we can’t use this counter i to directly index into the array, since start and end may be almost anywhere in the array. Thus, we use i to compute next in line 3, which we will use as our index into the array. Our index i should begin with start and finish with the end value, which can also be computed as start + size() – 1 modulo the capacity of myQueue. We then use the index next in line 4 to select the appropriate element of myQueue to append to our output string. Once the loop ends, we simply return our output string.\nfunction TOSTRING()\rOUTPUT = \"\"\t(1)\rfor I = 0 to SIZE() - 1\t(2)\rNEXT = (START + I) % MYQUEUE capacity\t(3)\rOUTPUT = OUTPUT + MYQUEUE[next].TOSTRING()\t(4)\rend for\t(5)\rreturn OUTPUT\t(6)\rend function The toString function includes a loop that, at most, looks at each element in myQueue; therefore, toString executes in order $N$ time.",
    "description": "We have already seen the pseudocode for the two key operations for queues: enqueue and dequeue. However, there are several others that make the queue data structure much easier to use:\nenqueue—places an item on the end of the queue, dequeue—removes and returns the item at the start of the queue, peek—returns the item at the start of the queue without removing it, isEmpty—returns true if there are no items in the queue, isFull—returns true if our queue array is full, and size—returns the number of items in the queue.",
    "tags": [],
    "title": "Basic Operations",
    "uri": "/cc310/8-queues/4-basic-operations/"
  },
  {
    "breadcrumb": "Recursion",
    "content": "The most popular example of using recursion is calculating the factorial of a positive integer $N$. The factorial of a positive integer $N$ is just the product of all the integers from $1$ to $N$. For example, the factorial of $5$, written as $5!$, is calculated as $5 * 4 * 3 * 2 * 1 = 120$. The definition of the factorial function itself is recursive. $$\r\\text{fact}(N) = N * \\text{fact}(N - 1)\r$$ The corresponding pseudocode is shown below.\nfunction FACT(N) if N == 1 return 1 else return N * FACT(N-1) end if end functionThe recursive version of the factorial is slower than the iterative version, especially for high values of $N$. However, the recursive version is simpler to program and more elegant, which typically results in programs that are easier to maintain over their lifetimes.",
    "description": "The most popular example of using recursion is calculating the factorial of a positive integer $N$. The factorial of a positive integer $N$ is just the product of all the integers from $1$ to $N$. For example, the factorial of $5$, written as $5!$, is calculated as $5 * 4 * 3 * 2 * 1 = 120$. The definition of the factorial function itself is recursive. $$\r\\text{fact}(N) = N * \\text{fact}(N - 1)\r$$ The corresponding pseudocode is shown below.",
    "tags": [],
    "title": "Example: Factorials",
    "uri": "/cc310/6-recursion/4-example--factorials/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " Two of the most powerful concepts in object orientation are encapsulation and information hiding.\nEncapsulation is capturing both data and behavior into a single object. Information hiding is restricting access to some of the data and behavior of an object. Encapsulation enables information hiding, and information hiding allows us to simplify the interface used to interact with an object. Instead of needing to know everything about a particular class of objects in order to use or interact with those objects. This will make our programs less complex and easier to implement and test. It also makes it easier for you to change the internal implementations of methods without affecting the rest of your program. As long as the method behaves in the same way (i.e., produces the same outputs given a given set of inputs), the rest of your program will not be affected. Thus, we see two key parts of any class:\nThe interface to the class. Those methods and attributes that can be seen and called by an external object. The implementation of the class. The internal representation of the attributes and implementation of methods to achieve the desired behavior. Real World Example Encapsulation and information hiding are actually all around us. Take for example, a soda vending machine. There are many internal parts to the machine. However, as a user, we care little about how the machine works or what it does inside. We need to simply know how to insert money or swipe our card and press a couple of buttons to get the soda we desire. If a repair is needed and an internal motor is replaced, we don’t care whether they replaced the motor with the exact same type of motor or the new model. As long as we can still get our soda by manipulating the same payment mechanisms and buttons, we are happy. You and I care only about the interface to the machine, not the implementation hiding inside.\nPrivate and Public To implement information hiding in our classes, we use visibility. In general, attributes and methods can either be public or private. If we want and attribute or method to be part of the class interface, we define them as public. If we want to hide a attribute or method from external objects, we defined them as private. An external object may access public attributes and call public methods, which is similar to using the payment mechanism or the buttons on a soda machine. However, the internals of how the object works is hidden by private attributes and methods, which are equivalent to the internal workings of the soda machine.\nBest Practices To implement information hiding, we recommend that you declare all attributes of a class as private. Any attribute whose value should be able to be read or changed by an external object should create special “getter” and “setter” methods that access those private variables. This way, you can make changes to the implementation of the attributes without changing how it is accessed in the external object.",
    "description": "Two of the most powerful concepts in object orientation are encapsulation and information hiding.\nEncapsulation is capturing both data and behavior into a single object. Information hiding is restricting access to some of the data and behavior of an object. Encapsulation enables information hiding, and information hiding allows us to simplify the interface used to interact with an object. Instead of needing to know everything about a particular class of objects in order to use or interact with those objects.",
    "tags": [],
    "title": "Information Hiding",
    "uri": "/cc310/02-oop-review/04-info-hiding/"
  },
  {
    "breadcrumb": "Programming by Contract and Introduction to Performance",
    "content": " Another concept related to preconditions and postconditions is the loop invariant. A loop invariant is a statement should be true after each iteration of a loop, provided the loop’s preconditions are all true before the start of the loop. Yes, that’s right—we can think of a loop as a miniature method within a method, with its own set of preconditions and postconditions.\nExample - Maximum For this example, let’s consider a method maximum(numbers) that gets an array of numbers as input, and returns the maximum value stored in that list. So, we can start by listing the preconditions of the method:\nnumbers is an array containing at least one numerical value, either a floating point or an integer Thankfully, that one precondition covers all of our bases. Likewise, we can define our postcondition pretty easily as well:\nThe method returns the maximum value stored in the numbers array The numbers array is not modified by the method There we go! Hopefully it is easy to see how the preconditions and postconditions help us build a better definition of what operations should be performed by the method.\nMethod Pseudocode Now that we’ve built our method’s preconditions and postconditions, let’s quickly write the method in pseudocode so we can see what it would look like.\nfunction MAXIMUM(NUMBERS) MAX = NUMBERS[0] loop I from 1 to length of NUMBERS if NUMBERS[I] \u003e MAX MAX = NUMBERS[I] end if end loop return MAX end function We’ve seen methods like this several times already, since calculating the maximum value from an array of values is a very common task. This time, however, let’s discuss the preconditions, postconditions and invariants of the loop inside of this method.\nPreconditions First, we can establish an important precondition at the beginning of the loop. In this case, the precondition that best describes the value stored in MAX is:\nMAX contains the maximum value stored in NUMBERS up to and including index $0$. In this way, we’ve directly tied our precondition to the values that exist in the method already, and we’ve accurately described the value that MAX is currently storing.\nTip Confused? Don’t worry if this doesn’t make sense right now - you won’t be expected to write your own preconditions and invariants at this point. We’re just introducing the concepts so you’ll understand how they work when you see them later in the projects in this course\nLoop Invariant Next, we can determine what the loop invariant should be. This is a statement that should be true after each iteration of the loop, provided the precondition is true. Usually we want to try and relate it to the precondition somehow, and how it changes after each iteration of the loop. So, let’s consider the following loop invariant:\nMAX contains the maximum value stored in NUMBERS up to and including index $I$. Hmm, that’s almost exactly the same as the precondition, isn’t it? That’s what we’re going for here. In this way, we can easily describe what the loop does after each iteration based on how it updates the value in MAX, keeping the loop invariant true. We call that “maintaining the loop invariant.”\nPostcondition Finally, we can define the postcondition of the loop. This is pretty simple, since it is the same as the loop invariant, but this time we can say that I is equal to the end of the loop. So, our postcondition is simply:\nMAX contains the maximum value stored in NUMBERS up to and including the last index. That’s all there is to it! By defining a precondition, invariant, and postcondition for our loop, we can very accurately describe exactly what that loop should do. On the next page, we’ll see how we can put all of those together to show that our method works correctly.",
    "description": "Another concept related to preconditions and postconditions is the loop invariant. A loop invariant is a statement should be true after each iteration of a loop, provided the loop’s preconditions are all true before the start of the loop. Yes, that’s right—we can think of a loop as a miniature method within a method, with its own set of preconditions and postconditions.\nExample - Maximum For this example, let’s consider a method maximum(numbers) that gets an array of numbers as input, and returns the maximum value stored in that list.",
    "tags": [],
    "title": "Invariants",
    "uri": "/cc310/3-programming-by-contract-and-introduction-to-performance/4-invariants/"
  },
  {
    "breadcrumb": "Python Review",
    "content": "\rNow that we’ve written our first Python program, we must run the program to see the fruits of our labors. There are many different ways to do this using the Codio platform. We’ll discuss each of them in detail here.\nTerminal Codio includes a built-in Linux terminal, which allows us to perform actions directly on a command-line interface just like we would on an actual computer running Linux. We can access the Terminal in many ways:\nSelecting the Tools menu, then choosing the Terminal option Pressing SHIFT + ALT + T in any Codio window (you can customize this shortcut in your Codio user preferences) Pressing the Open Terminal icon in the file tree Selecting the Open Terminal option from the Run menu (it is the first menu to the right of the Help menu) Additionally, some pages may already open a terminal window for us in the left-hand pane, as this page so helpfully does. As we can see, we’re never very far away from a terminal.\nNew to Linux? No worries! We’ll give you everything you need to know to run your Python programs in this course.\nIf you’d like to learn a bit more about the Linux terminal and some of the basic commands, feel free to check out this great video on YouTube:\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/oxuRxtrO2Ag?autoplay=0\u0026controls=1\u0026end=0\u0026loop=0\u0026mute=0\u0026start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\" \u003e\u003c/iframe\u003e \u003c/div\u003e Let’s go to the terminal window and navigate to our program. When we first open the Terminal window, it should show us a prompt that looks somewhat like this one:\nThere is quite a bit of information there, but we’re interested in the last little bit of the last line, where it says ~/workspace. That is the current directory, or folder, our terminal is looking at, also known as our working directory. We can always find the full location of our working directory by typing the pwd command, short for “Print Working Directory,” in the terminal. Let’s try it now!\nEnter this command in the terminal:\npwd and we should see output similar to this:\nIn that output, we’ll see that the full path to our working directory is /home/codio/workspace. This is the default location for all of our content in Codio, and it’s where everything shown in the file tree to the far left is stored. When working in Codio, we’ll always want to store our work in this directory.\nNext, let’s use the ls command, short for “LiSt,” to see a list of all of the items in that directory:\nls We should see a whole list of items appear in the terminal. Most of them are directories containing examples for the chapters this textbook, including the HelloWorld.py file that we edited in the last page. Thankfully, the directories are named in a very logical way, making it easy for us to find what we need. For example, to find the directory for Chapter 1 that contains examples for Python, look for the directory with the name starting with 1p. In this case, it would be 1p-hello.\nFinally, we can use the cd command, short for “Change Directory,” to change the working directory. To change to the 1p-hello directory, type cd into the terminal window, followed by the name of that directory:\ncd 1p-hello We are now in the 1p-hello directory, as we can see by observing the ~/workspace/1p-hello on the current line in the terminal. Finally, we can do the ls command again to see the files in that directory:\nls We should see our HelloWorld.py file! If it doesn’t appear, try using this command to get to the correct directory: cd /home/codio/workspace/1p-hello.\nOnce we’re at the point where we can see the HelloWorld.py file, we can move on to actually running the program.\nRunning in Terminal To run it, we just need to type the following in the terminal:\npython3 HelloWorld.py That’s all there is to it! We’ve now successfully run our first Python program. Of course, we can run the program as many times as we want by repeating the previous python3 command. If we make changes to the HelloWorld.py file that instruct the computer to do something different, we should see those changes the next time we run the file..\nProblems? If the python3 command doesn’t give you any output, or gives you an error message, that most likely means that your code has an error in it. Go back to the previous page and double-check that the contents of HelloWorld.py exactly match what is shown at the bottom of the page. You can also read the error message output by python3 to determine what might be going wrong in your file.\nAlso, make sure you use the python3 command and not just python. The python3 command references the newer Python 3 interpreter, while the python command is used for the older Python 2 interpreter. In this book, we’ll be using Python 3, so you’ll need to always make sure you use python3 when you run your code.\nWe’ll cover information about simple debugging steps on the next page as well. If you get stuck, now is a great time to go to the instructors and ask for assistance. You aren’t in this alone!\nTry It! See if you can change the HelloWorld.py file to print out a different message. Once you’ve changed it, use the python3 command to run the file again. Make sure you see the correct output!\nCodio Assessments Last, but not least, many of the Codio tutorials and projects in this program will include assessments that we must solve by writing code. Codio can then automatically run the program and check for specific things, such as the correct output, in order to give us a grade. For most of these questions, we’ll be able to make changes to our code as many times as we’d like to get the correct answer.\nAs we can see, there are many different ways to compile and run our code using Codio. Feel free to use any of these methods throughout this course.",
    "description": "Now that we’ve written our first Python program, we must run the program to see the fruits of our labors. There are many different ways to do this using the Codio platform. We’ll discuss each of them in detail here.\nTerminal Codio includes a built-in Linux terminal, which allows us to perform actions directly on a command-line interface just like we would on an actual computer running Linux. We can access the Terminal in many ways:",
    "tags": [],
    "title": "Running Code",
    "uri": "/cc310/01-review/04-run-code/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "Our find algorithm above will find the first instance of number in the array and return the index of that instance. However, we might also be interested in finding the last instance of number in array. Looking at our original find algorithm, it should be easy to find the last value by simply searching the array in reverse order, as shown in the following figure.\nWe will use the same example as above, except we will start searching backwards from the end of the array. In Step 1, we see that index is initialized to 7 and we compare array[7] against number, which are not the same. Thus, we continue to Step 2, where we decrement index to 6. Here array[6] is still not equal to number, so we continue in the loop. Finally, in Step 3, we decrement index to 5. Now array[5] contains the number 3, which is equal to our number and we return the current index value.\nLuckily for us, we can change our for loop index to decrement from the end of the array (size of array - 1) to the beginning (0). Thus, by simply changing line 3 in our original function, we can create a new function that searches for the last instance of number in array. The new function is shown below.\nfunction REVERSEFIND(NUMBER, ARRAY)\t(1) loop INDEX from size of ARRAY – 1 to 0 step -1\t(2) if ARRAY[INDEX] == NUMBER\t(3) return INDEX\t(4) end if\t(5) end for\t(6) return -1\t(7) end function\t(8)Obviously, the for loop in line 2 holds the key to searching our array in reverse order. We start at the end of the array by using the index size of array - 1 and then decrement the value of index (via the step -1 qualifier) each time through the loop until we reach 0. The remainder of the function works exactly like the find function.",
    "description": "Our find algorithm above will find the first instance of number in the array and return the index of that instance. However, we might also be interested in finding the last instance of number in array. Looking at our original find algorithm, it should be easy to find the last value by simply searching the array in reverse order, as shown in the following figure.\nWe will use the same example as above, except we will start searching backwards from the end of the array.",
    "tags": [],
    "title": "Searching for the Last Value",
    "uri": "/cc310/7-searching-and-sorting/4-searching-for-the-last-value/"
  },
  {
    "breadcrumb": "Sets",
    "content": "In this section, we will walk through the pseudocode for some basic set operations. We will build our set class using the doubly linked list class. In this way, we can build from the functionality that is already developed. So, in the set class, we will declare mySet as a doubly linked list and use that throughout our operations.\nmySet = new doubleLinkedList()Contains The first operation we will look at is the contains operation, which checks to see if a given object already exists in our set. This operation is generally very useful, which we will see in the operations below.\nThe pseudocode for the contains operation is shown below. We will use the list iterator built into our doubly linked list class to help us walk through the list searching for the object o. So, in line 1, we call the reset function and then the getNext operation in line 2 to get the first item in the mySet list.\nfunction contains(object o) returns Boolean mySet.reset()\t(1) obj = mySet.getNext()\t(2) while obj != null\t(3) if (obj == o)\t(4) return true\t(5) end if obj = mySet.getNext()\t(6) end while return false\t(7) end functionWe then enter a while loop in line 3, where we will stay until either we find the object in our list, or we reach the end of the list. Once inside the loop, we check to see if the object from the list is equal to the object we are searching for in line 4. If it is, we return true in line 5 and we are done. If they are not equal, we get the next object from mySet and return to the top of the loop. If we reach the end of the list without finding our object, we will exit the loop and return false in line 7.\nAdd The add operation is relatively straightforward. The only thing we need to check is whether or not the object is already in mySet. In this case, instead of raising an exception when we try to add a duplicate object, we will return true if we add the object and false if we do not. This is because often, the user only really cares that the object is in the set after calling add and does not care if it was already there.\nAs shown, the pseudocode for the add operation is fairly straightforward. In lines 1 and 2, we call the contains operation to determine if the object already exists in mySet and return the value false if it does. Otherwise, we simply call the list operation append to insert the object into the list.\nfunction add(object o) returns Boolean if (contains(o))\t(1) return false\t(2) else mySet.append(o)\t(3) return true\t(4) end if end functionRemove The remove operation is very similar to the contains operation, except this time we want to remove the item if it exists in the set. We can use the removeCurrent() operation to remove the current item that our iterator is pointing to from the list. Again, like the add operation, we will return false if the operation does not actually remove an item from the list. Otherwise, the operation will return true.\nfunction remove(object o) returns Boolean mySet.reset()\t(1) obj = mySet.getNext()\t(2) while obj != null\t(3) if (obj == o)\t(4) mySet.removeCurrent()\t(5) return true\t(6) end if obj = mySet.getNext()\t(7) end while return false\t(8) end functionIntersection The intersection operation creates a new set that has only elements that exist in both sets under consideration. In code, we basically accomplish this by looping through the elements in one set and then checking to see if they exist in the other set. If they do, then we include them in the intersection.\nTo follow that basic algorithm, the pseudocode below uses the list iterator operations to loop through and look at each element in mySet. We will create a new set, result, to hold the intersection of mySet and set2 in line 1. Then we get the first element from mySet by calling the list reset operation in line 2 and the getNext operation in line 3.\nfunction intersection(set2) returns set result = new set()\t(1) mySet.reset()\t(2) obj = mySet.getNext()\t(3) while obj != null\t(4) if (set2.contains(obj))\t(5) result.add(obj)\t(6) end if obj = mySet.getNext()\t(7) end while return result\t(8) end functionLines 4 – 7 implement the loop that walks through each element in mySet. If the current object is contained in set2 (line 5), the operation calls the add operation to insert obj into the result set. Line 7 gets the next element from mySet and loops back to the top.\nEventually, we will look at each element in mySet and fall out of the loop. When that happens, the intersection operation is complete, and it returns the result set in line 8\nUnion The union operation is similar to the intersection operation in that we will need to use the list iterator operations to walk through our two sets. The difference lies in what we include in the new result set. While we only walked through mySet in the intersection operation, picking only those objects that existed in set2, here we will walk through both sets adding all their elements to the result set.\nThe code starts in line 1 by creating our result set. Then, lines 2 and 3 reset the mySet iterator and get the first item from mySet. Lines 4 – 6 form the while loop that we use to walk through the entire set of objects in mySet. This time, however, we simply add every element we find in line 5 before getting the next object in line 6.\nfunction union(set2) returns set result = new set()\t(1) mySet.reset()\t(2) obj = mySet.getNext()\t(3) while obj != null\t(4) result.add(obj)\t(5) obj = mySet.getNext()\t(6) end while set2.reset()\t(7) obj = set2.getNext()\t(8) while obj != null\t(9) result.add(obj)\t(10) obj = set2.getNext()\t(11) end while return result\t(12) end functionLines 7 – 11 duplicate the loop function above, only using set2 instead of mySet. We don’t have to worry about adding duplicate items in line 10, since as we saw above, our add operation will not allow duplicates to be added to the set. Finally, we return the result set, which holds the union of mySet and set2.\nisSubset Instead of using the intersection operation directly to compute the isSubset operation, we will compute the value of isSubset directly to make it more efficient. If we use intersection directly, we will end up looping through the members of one of the sets at least two times (once to compute the intersection and once to check equality). Computing isSubset directly only loops through one of the sets once.\nThe isSubset operation below is very much like the intersection operation as we have a loop in lines 3 - 6 that checks each element of set2 and checks to see if it is in mySet. The difference between the two operations is that in the isSubset operation, we do not build a third result set. Instead, if any element in set2 is not found in mySet, then we return false since not all elements of set2 are contained in mySet. If we get all the way through the loop, we have checked that each element in set2 was found in mySet and we can return true; set2 is a subset of mySet.\nfunction isSubset(set2) returns boolean set2.reset()\t(1) obj = set2.getNext()\t(2) while obj != null\t(3) if (! mySet.contains(obj))\t(4) return false\t(5) end if obj = set2.getNext()\t(6) end while return true\t(7) end function",
    "description": "In this section, we will walk through the pseudocode for some basic set operations. We will build our set class using the doubly linked list class. In this way, we can build from the functionality that is already developed. So, in the set class, we will declare mySet as a doubly linked list and use that throughout our operations.\nmySet = new doubleLinkedList()Contains The first operation we will look at is the contains operation, which checks to see if a given object already exists in our set.",
    "tags": [],
    "title": "Set Operations",
    "uri": "/cc310/10-sets/4-set-operations/"
  },
  {
    "breadcrumb": "Lists",
    "content": " Linked Node To solve the disadvantages of arrays, we need a data structure that allows us to insert and remove items in an ordered collection in constant time, independently from the number of items in the data structure.\nThe solution lies in creating our own specialized data structure where each node contains the data of interest as well as a reference, or pointer to the next node in the list. Of course, we would also need to have a pointer to the first node in the list, which we call the head.\nThe figure below shows how we can construct a linked list data structure. The head entity shown in the figure is a variable that contains a pointer to the first node in the list, in this case the node containing -2. Each node in the list is an object that has two main parts: the data that it holds, and a pointer to the next item in the list.\nThe class representation of a singly linked list Node is shown below. As discussed above, we have two attributes: data, which holds the data of the node, and next, which is a reference or pointer to the next node. We also use a constructor and a standard toString operation to appropriately create a string representation for the data stored in the node.\nLinked List A list is represented by a special variable head that contains a pointer to the first item in the list. If the head is null (equal to 0), then we have an empty list, which is a list with no items in it.\nHowever, if we have items in the list, head will point to a node as shown in the figure below. This node has some data (in this case -2) and its own pointer that points to the next node in the list. As we can see in our example, head points to a sequence of five nodes that makes up our list. The node with the data 67 in it is the last item in the list since its pointer is null. We often refer to this condition as having a null pointer.\nWhile we will not show them explicitly in this module, each pointer is actually an address in memory. If we have a pointer to node X in our node, that means that we actually store the address of X in memory in our node.\nLinked List Class To capture the necessary details for a singly linked list, we put everything into a class. The singly linked list class has two attributes:\nlist—the pointer to the first node in the list, and size—an integer to keep track of the number of items in the list. Class SingleLinkedList Node head Integer size = 0 While we would normally create getter and setter methods for each attribute in the class, to simplify and clarify our pseudocode below we use “dot notation” to refer directly to the attributes in the node. The following table illustrates our usage in this module.\nUse Meaning node node.next node.next.next head head.next ",
    "description": "Linked Node To solve the disadvantages of arrays, we need a data structure that allows us to insert and remove items in an ordered collection in constant time, independently from the number of items in the data structure.\nThe solution lies in creating our own specialized data structure where each node contains the data of interest as well as a reference, or pointer to the next node in the list.",
    "tags": [],
    "title": "Singly Linked Lists",
    "uri": "/cc310/9-lists/4-singly-linked-lists/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "The next two data structures we’ll look at are stacks and queues. They are both very similar to lists in most respects, but each one puts a specific limitation on how the data structure operates that make them very useful in certain situations.\nStack 1\nA stack is one special version of a list. Specifically, a stack is a Last In, First Out or LIFO data structure.\nSo, what does that mean? Basically, we can only add elements to the end, or top of the stack. Then, when we want to get an element from the stack, we can only take the one from the top–the one that was most recently added.\nA great way to think of a stack is like a stack of plates, such as the one pictured below:\n2\nWhen we want to add a new plate to the stack, we can just set it on top. Likewise, if we need a plate, we’ll just take the top one off and use it.\nA stack supports three major unique operations:\npush - add an item to the top of the stack; pop - remove an item from the top of the stack; and peek - see what the top item on the stack is, but don’t remove it. Many stacks also include additional operations such as size and find as well.\nQueue 3\nA queue is another special version of a list, this time representing a First In, First Out or FIFO data structure.\nAs seen in the diagram above, new items are added to the back of the queue. But, when we need to take an item from a queue, we’ll take the item that is in the front, which is the one that was added first.\nWhere have we seen this before? A great example is waiting our turn in line at the train station,\n4\nIn many parts of the world, the term queueing is commonly used to refer to the act of standing in line. So, it makes perfect sense to use that same word to refer to a data structure.\nWhen to Use a Stack or a Queue As we can probably guess, we would definitely want to use a stack if we need our data structure to follow the last in, first out, or LIFO ordering. Similarly, we’d use a queue if we need first in, first out or FIFO ordering.\nIf we can’t be sure that one or the other of those orderings will work for us, then we can’t really use a stack or a queue in our program.\nWhy Not Just Use Lists? Of course, one of the biggest questions that comes from this is “why not just use lists for everything?” Indeed, lists can be used as both a queue and a stack, simply by consistently inserting and removing elements from either the beginning or the end of the list as needed. So why do we need to have separate data structures for a queue and a stack?\nThere are two important reasons. First, if we know that we only need to access the most recently added element, or the element added first, it makes sense to have a special data structure for just that usage. In this way, it is clear to anyone else reading our program that we will only be using the data in that specific way. Behind the scenes, of course, we can just use a list to represent a queue or a stack, but in our design documents and in our code, it might be very helpful to know if we should think of it like a stack or a queue.\nThe other reason has to do with performance. By knowing exactly how we need to use the data, we can design data structures that are specifically created to perform certain operations very quickly and efficiently. A generic list data structure may not be as fast or memory efficient as a structure specifically designed to be used as a stack, for example.\nAs we learn about each of these data structures throughout this course, we’ll explore how each data structure works in terms of runtime performance and memory efficiency.\nFile:Lifo stack.png. (2017, August 7). Wikimedia Commons, the free media repository. Retrieved 23:14, February 7, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Lifo_stack.png\u0026oldid=254596945. ↩︎\nFile:Tallrik - Ystad-2018.jpg. (2019, December 31). Wikimedia Commons, the free media repository. Retrieved 23:17, February 7, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Tallrik_-_Ystad-2018.jpg\u0026oldid=384552503. ↩︎\nFile:Data Queue.svg. (2014, August 15). Wikimedia Commons, the free media repository. Retrieved 23:21, February 7, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Data_Queue.svg\u0026oldid=131660203. ↩︎\nFile:People waiting a train of Line 13 to come 02.JPG. (2016, November 28). Wikimedia Commons, the free media repository. Retrieved 23:23, February 7, 2020 from https://commons.wikimedia.org/w/index.php?title=File:People_waiting_a_train_of_Line_13_to_come_02.JPG\u0026oldid=223382692. ↩︎",
    "description": "The next two data structures we’ll look at are stacks and queues. They are both very similar to lists in most respects, but each one puts a specific limitation on how the data structure operates that make them very useful in certain situations.\nStack 1\nA stack is one special version of a list. Specifically, a stack is a Last In, First Out or LIFO data structure.\nSo, what does that mean?",
    "tags": [],
    "title": "Stacks and Queues",
    "uri": "/cc310/03-intro-dsa/04-stacks-queues/"
  },
  {
    "breadcrumb": "Hash Tables",
    "content": "Before we can start describing the basic hash table functions, we first need to create a way to handle key-value pairs. We generally refer to any piece of data that has two parts as a tuple. In the case of key-value pairs, our tuple would look like (key, value). Some languages, such as Python, provide built-in support for creating tuples, while others such as Java and C# require us to create our own tuple class, which is easy to do. All we really need our tuple class to do is to allow us to:\ncreate a tuple consisting of two objects, access either of the two parts of the tuple, check two tuples for equality, and convert the tuple to a string. The pseudocode for the Tuple class is given below. Each of the operations is simple and thus we do not discuss them individually. However, notice that the class has two attributes, key and value, that are created in the constructor. The getKey and getValue operations are used often in the code below to provide access to the internals of the tuples.\nclass Tuple\tobject key = null object value = null function Tuple(object k, object v) key = k value = v end function function getKey() returns string return key end function function getValue() returns object return value end function function toString() returns string return \"(\" + key.toString() + \",\" + value.toString() + \")\" end function function equals(Object o) returns boolean if o is not an instance of Tuple: return false end if Tuple t = (Tuple)o return (o.key == key) AND (o.value == value) end function",
    "description": "Before we can start describing the basic hash table functions, we first need to create a way to handle key-value pairs. We generally refer to any piece of data that has two parts as a tuple. In the case of key-value pairs, our tuple would look like (key, value). Some languages, such as Python, provide built-in support for creating tuples, while others such as Java and C# require us to create our own tuple class, which is easy to do.",
    "tags": [],
    "title": "Tuples",
    "uri": "/cc310/11-hash-tables/4-tuples/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome! This page is the main page for Stacks",
    "description": "Welcome! This page is the main page for Stacks",
    "tags": [],
    "title": "Stacks",
    "uri": "/cc310/5-stacks/"
  },
  {
    "breadcrumb": "Programming by Contract and Introduction to Performance",
    "content": " If we have defined the correct preconditions, postconditions, and invariants for our code, we can then use those to prove that our code correctly performs its intended operation.\nIn this course, we won’t ask you to do any of this yourself, but it is important to understand what is going on in the background and how this process works. We can use the concepts of preconditions and postconditions when grading your code using our Autograder—in fact, that’s really how it works!\nProving Correctness To prove correctness of a method, we can generally follow this process:\nEstablish (or assume) that the method’s preconditions are all true Use the preconditions and the code to demonstrate that any invariants within the code are always true If the code contains a loop, we can repeat this process for preconditions and postconditions of the loop Use the preconditions and invariants to show that the postcondition is true Let’s do this for our maximum() method described on the previous page. Here is the pseudocode once again:\nfunction MAXIMUM(NUMBERS) MAX = NUMBERS[0] loop I from 1 to length of NUMBERS if NUMBERS[I] \u003e MAX MAX = NUMBERS[I] end if end loop return MAX end function Here are the associated conditions we established as well:\nMethod Precondition: NUMBERS is an array containing at least one numerical value, either a floating point or an integer Loop Precondition: MAX contains the maximum value stored in NUMBERS up to and including index $0$. Loop Invariant: MAX contains the maximum value stored in NUMBERS up to and including index $I$. Loop Postcondition: MAX contains the maximum value stored in NUMBERS up to and including the last index. Method Postconditions: The method returns the maximum value stored in the NUMBERS array, and the NUMBERS array is not modified by the method\nNow that we have that information, we can discuss the correctness of the method.\nA Simple Proof To begin, we assume that the method’s preconditions are true. Therefore, we know that NUMBERS is an array containing at least one numerical value. Earlier in this chapter, we learned that we can’t assume that the method works if the preconditions are false, so we can always begin our proof by assuming they are true.\nNext, we have to use the code as well as the method’s preconditions to establish that the loop’s preconditions are true. In the code, we see that we set the value of MAX equal to the first element in the NUMBERS array. So, since there is only that value in the NUMBERS array up to and including index $0$, it is easy to say that it is indeed the maximum value. So, we’ve shown that our loop’s precondition is true.\nAfter that, we have to show that the loop invariant is true after each iteration of the loop. A proper proof would involve a technique called proof by induction, which is more advanced than we want to cover in this course. However, a simple way to think about it is to say that the value in MAX contains the largest value in the list that we’ve seen so far. On each loop iteration, we look at one more value. If it is larger than MAX, then it becomes the new MAX value. Otherwise, we know that the maximum value we’ve seen so far hasn’t changed. So, we can show that our loop invariant is always true after each loop iteration.\nFinally, once we reach the end of the loop, we’ve looked at every element including the last index, and found the MAX value, so it is easy to see that our loop postcondition is true.\nThen, we can quickly use that loop postcondition to understand that the MAX value is really the largest in the NUMBERS array, which means that the first part of our method’s postcondition is also true.\nBut wait! What about the second part, that insists that we did not modify the contents of the numbers array? Thankfully, we can quickly look at our code and determine that we are not assigning a value into the array, nor do we call any functions on the array, so it is easy to show that our code has not modified it in any way.\nThere we go! This is a quick example for how we can use preconditions, postconditions, and invariants to help understand our code and whether it works correctly.\nOn the next page, we’ll learn about unit testing and how we can write our own code to verify that our code works correctly.",
    "description": "If we have defined the correct preconditions, postconditions, and invariants for our code, we can then use those to prove that our code correctly performs its intended operation.\nIn this course, we won’t ask you to do any of this yourself, but it is important to understand what is going on in the background and how this process works. We can use the concepts of preconditions and postconditions when grading your code using our Autograder—in fact, that’s really how it works!",
    "tags": [],
    "title": "Correctness",
    "uri": "/cc310/3-programming-by-contract-and-introduction-to-performance/5-correctness/"
  },
  {
    "breadcrumb": "Python Review",
    "content": "Codio also includes an integrated debugger, which is very helpful when we want to determine if there is an error in our code. We can also use the debugger to see what values are stored in each variable at any point in our program.\nTo use the debugger, find the Debug Menu at the top of the Codio window. It is to the right of the Run Menu we’ve already been using. On that menu, we should see an option for Python - Debug File. Select that option to run our program in the Codio debugger.\nAs we build more complex programs in this course, we’ll be able to configure our own debugger configurations that allow us to test multiple files and operations.\nThe Codio debugger only works with input from a file, not from the terminal. So, to use the debugger, we’ll need to make sure the input we’d like to test is stored in a file, such as input.txt, before debugging. We can then give that file as an argument to our program in our debugger configuration, and write our program to read input from a file if one is provided as an argument.\nLearning how to use a debugger is a hands-on process, and is probably best described in a video. You can find more information in the Codio documentation to get up to speed on working in the Codio debugger.\nCodio Documentation - Debugger\nWe can always use the debugger to help us find problems in our code.\nVisualizer 1\nCodio now includes support for Python Tutor, allowing us to visualize what is happening in our code. We can see that output in the second tab that is open to the left.\nUnfortunately, students are not able to open the visualizer directly, so it must be configured by an instructor in the Codio lesson. If you find a page in this textbook where you’d like to be able to visualize your code, please let us know!\nhttps://www.codio.com/blog/python-tutor-codio-visualizer ↩︎",
    "description": "Codio also includes an integrated debugger, which is very helpful when we want to determine if there is an error in our code. We can also use the debugger to see what values are stored in each variable at any point in our program.\nTo use the debugger, find the Debug Menu at the top of the Codio window. It is to the right of the Run Menu we’ve already been using.",
    "tags": [],
    "title": "Debugging",
    "uri": "/cc310/01-review/05-debugging/"
  },
  {
    "breadcrumb": "Hash Tables",
    "content": " The HashTable class has three attributes that provide the basic data structure and parameters we need to efficiently manage our table.\nsize - captures the number of tuples stored in the table. It is initialized to 0 in line 7 of the constructor. loadFactor - is the load factor used to determine when to increase the capacity of the array. It is initialized to 0.75 in line 8 of the constructor. hashTable - is an array of doubly linked lists. The array is actually created in line 4 of the constructor and the doubly linked lists for each location in the array are created in the loop in lines 5 and 6 of the constructor. class HashTable int size\t(1) double loadFactor = 0.75\t(2) doubleLinkedList[] hashTable\t(3) function HashTable() hashTable = new doubleLinkedList[16]\t(4) for i = 0 to hashTable.length\t(5) hashTable[i] = new doubleLinkedList()\t(6) end for size = 0\t(7) loadFactor = 0.75\t(8) end function Compute Index We assume we are using the language-specific hash code function to actually generate our hash code. However, we need to convert that number (typically a very large integer) to an index for our array, which has a limited capacity. Therefore, we use the modulo function in line 1 to convert the hash code into the range of 0 to the capacity of the array. The computeIndex operation runs in constant time.\nfunction computeIndex(object key) returns integer\rreturn hashCode(key) % getCapacity() (1)\rend function Put The put operation is an important hash table operation, whose goal is to place a key-value pair into the right linked list. We start by calling computeIndex to find which linked list we should store the key-value pair in, which we can access using hashTable[index]. Next, we check to see if the key has already been stored in the table by iterating through the list found at that location in the table. If the key has already been stored, we should update the value in that tuple to be the new value in line 6 and return on line 7. If the key isn’t found, then we actually store the key-value pair in the table by calling the append operation for the hashTable[index] linked list on line 9. Notice, we create a new Tuple using the key and value input parameters before we call append. Since we successfully added the new tuple, we increment the size attribute to keep track of the number of tuples stored in the table.\nfunction put(object key, object value) index = computeIndex(key)\t(1) hashTable[index].reset()\t(2) current = hashTable[index].getNext()\t(3) while current != null\t(4) if current.key == key (5) current.value = value\t(6) return (7) end if current = hashTable[index].getNext()\t(8) end while hashTable[index].append(new Tuple(key, value))\t(9) size = size + 1 (10) if size/capacity \u003e loadFactor\t(11) doubleCapacity()\t(12) end if end function Since we have added a new tuple to the table, we need to check to see if the size of the table exceeds our load factor. Therefore, in line 11, we check to see if the value of size/capacity exceeds our loadFactor. If it does, we call the doubleCapacity operation to double the capacity of our array and rehash the table. The doubleCapacity operation is defined below.\nSince we are looping through a list of elements in the hash table, it can be difficult to analyze the running time of this method. So, we have to look at both the best case and worst case scenario. In the best case, the linked list is empty, so the entire operation runs in constant time. As long as we have a good hash function and the keys are equally distributed across the hash table, this should be the case.\nHowever, if the hash function is poor, it could cause all of the elements in the hash table to be placed in the same list. In that case, the operation would run on the order of $N$ time, since it would have to iterate across all elements in the list.\nGet The get operation is another important hash table operation, whose goal is to retrieve (without deleting) a key-value pair from the table. Like the put operation, the first thing we need to do is to compute the index of the key we are looking for in line 1. Once we know the index, we call the reset operation on the hashTable[index] linked list so we can call the getNext iterator function in line 3. Lines 4 -7 are a loop that walks through each key-value pair in the linked list. If we find the key we are looking for in line 5, we return true and the operation ends. If we do not find the key, we call the getNext function to get the next element in the linked list. If we end up going through the entire loop until current != null becomes false, we fall out of the loop and return null in line 8, indicating that we did not find key in the table.\nfunction get(object key) returns object index = computeIndex(key)\t(1) hashTable[index].reset()\t(2) current = hashTable[index].getNext()\t(3) while current != null\t(4) if current.key == key (5) return current.value\t(6) end if current = hashTable[index].getNext()\t(7) end while return null\t(8) end function As discussed above, although we do end up looping through one of the linked lists in the hash table, these lists are much, much smaller than the overall size of the hash table under most normal circumstances. Thus, we say that the get operation runs in constant time in the best case.\nRemove The remove operation is much like the get operation above, except that when we find the key we are searching for, we remove the key-value pair from the appropriate linked-list and return the value to the calling function. The only real difference in the operations lies in the loop intervals in lines 6 and 7. Here, when we find the key in the list, we call the removeCurrent operation to remove the key-value pair from the linked list and then decrement size by 1. Line 8 then returns current.value.\nfunction remove(object key) returns object index = computeIndex(key)\t(1) hashTable[index].reset()\t(2) current = hashTable[index].getNext()\t(3) while current != null\t(4) if current.key == key\t(5) hashTable[index].removeCurrent()\t(6) size = size – 1\t(7) return current.value\t(8) end if current = hashTable[index].getNext()\t(9) end while return null\t(10) end function Like the get operation above, we loop through one of the linked lists in the hash table. However, given the relatively small size of the list, we assume the remove operation runs in constant time in the best case.\nContains Key The containsKey operation returns a Boolean value based on whether we find the requested key in the table. Since the get operation already finds the key-value pair associated with a given key, we simply call get and then compute whether the key-value pair returned from get exists to compute the containsKey return value. The containsKey operation runs in constant time in the best case.\nfunction containsKey(object key) returns boolean return get(key) != null (1) end function Contains Value The containsValue operation is not as simple as containsKey since we don’t already have an operation to use to search for a value in our hash table. Since we are not given a key to search for, we cannot use the computeIndex to tell us which linked list to search for our value. Therefore, we need to start at the beginning of our array and loop through each element, searching each of the linked lists stored there for our value.\nLine 1 is our outside loop that walks through each linked list stored in our array. Within that loop, we follow the same search process we used in the get operation to search through hashTable[i]. We set up the iterator in lines 2 and 3 and then walk through the linked list in the loop in lines 4-7. The only difference in this search process is what we are searching for. In line 5, instead of checking if the keys are equal, we check to see if the values are equal. If they are, we return true. However, if we do not find the value somewhere in the table, we must search through every key-value pair in the table, thus the time complexity for containsValue is order $N$.\nfunction containsValue(object value) returns boolean for i = 0 to getCapacity()\t(1) hashTable[i].reset()\t(2) current = hashTable[i].getNext()\t(3) while current != null\t(4) if current.value == value\t(5) return true\t(6) current = hashTable[i].getNext()\t(7) end while end for return false\t(8) end function Get Size The getSize function is very simple. It simply returns the HashTable class’ size attribute.\nfunction getSize() returns integer return size (1) end function Get Capacity Like the getSize function, getCapacity simply returns the length of the hashTable array.\nfunction getCapacity() returns integer return length of the hashTable array (1) end function Is Empty The isEmpty operation simply returns the Boolean value of whether or not the size attribute is 0.\nfunction isEmpty() returns boolean return size == 0 (1) end function Copy The copy operation is similar to the containsValue operation in that it must walk through the entire hash table to get all the key-value pairs in the table and put them into the new hash table. Line 1 creates the new empty hash table, which we call copy.\nThe for loop in line 2 walks through the hashTable array, allowing us to access each linked list using hashTable[i]. Within the loop we use the linked list iterator functions (lines 3, 4, and 7) to walk through each key-value pair in the linked lists. For each key-value pair, we call copy.put to insert that key-value pair into the copy hash table. Once we have completed both loops, we return the copy in line 8. Like the containsValue operation, since we walk through each key-value pair in the hash table, the copy operation runs in order $N$ time.\nfunction copy() returns HashTable HashTable copy = new HashTable()\t(1) for i = 0 to getCapacity()\t(2) hashTable[i].reset()\t(3) current = hashTable[i].getNext()\t(4) while current != null\t(5) copy.put(current.key, current.value)\t(6) current = hashTable[i].getNext()\t(7) end while end for return copy\t(8) end function To String The toString operation is almost identical to the copy operation above, except that instead of inserting each key-value pair into a second hash table, we append the string representation of each key-value pair to an output string. In fact, the only differences to the pseudocode come in lines 1, 6, and 7. Line 1 creates a new empty string and line 8 returns that string after walking through the hash table. Finally, line 6 is where we append the current key-value pair’s string representation to the output string. We also append a comma to separate the key-value pairs in output. Like the copy operation, the toString operation runs in order $N$ time.\nfunction toString() returns string string output = null\t(1) for i = 0 to getCapacity()\t(2) hashTable[i].reset()\t(3) current = hashTable[i].getNext()\t(4) while current != null\t(5) output += current.toString() + \", \"\t(6) current = hashTable[i].getNext()\t(7) end while end for return output\t(8) end function Double Capacity The doubleCapacity operation is similar to the same operations for the array-based stack and queue implementations that we covered earlier. First, we create a new array with twice the capacity of the existing hashTable. Next, we “rehash” each of the key-value pairs in hashTable into the new table. Finally, we point the hashTable attribute at the new table.\nThe implementation of this process is captured in the following pseudocode. In line 1, we double the size of capacity. It is important to update capacity first so we can use the new value when creating the new hash table array. It is especially important to use this new capacity when calculating the indexes for key-value pairs in the new table.\nfunction doubleCapacity() capacity = capacity * 2 (1) doubleLinkedList[] newTable = new doubleLinkedList[getCapacity()]\t(2) for i = 0 to getCapacity()\t(3) newTable[i] = new doubleLinkedList()\t(4) end for for i = 0 to getCapacity() / 2\t(5) hashTable[i].reset()\t(6) current = hashTable[i].getNext()\t(7) while current != null\t(8) index = computeIndex(current.key)\t(9) newTable[index].append(current)\t(10) current = hashTable[i].getNext()\t(11) end while end for hashTable = newTable\t(12) end function Line 2 creates a new array called newTable with twice the capacity of the existing table. In lines 3 and 4, we create a new doubly linked list for each element of newTable. Then, in lines 5 – 11 we employ the same looping structure used above in copy and toString to walk through each key-value pair in hashTable. Then for each key-value pair, we compute its new index and then append the key-value pair to the linked list at hashTable[index]. Once we have completed the copying process, we fall out of the loop. Our final action is to point the hashTable attribute at newTable. Like the copy and toString operations, the run time of doubleCapacity is order $N$.\nIterator Operations While we do not present the iterator operations here, they are useful operations for hash tables. They are implemented similarly to the other iterator functions we have studied, except that in order to walk through the entire hash table we need to use nested loops where the outside loop walks through the array and the internal loop walks through each linked list. This is very similar to the looping structure in doubleCapacity above.",
    "description": "The HashTable class has three attributes that provide the basic data structure and parameters we need to efficiently manage our table.\nsize - captures the number of tuples stored in the table. It is initialized to 0 in line 7 of the constructor. loadFactor - is the load factor used to determine when to increase the capacity of the array. It is initialized to 0.75 in line 8 of the constructor.",
    "tags": [],
    "title": "Hash Table Operations",
    "uri": "/cc310/11-hash-tables/5-hash-table-operations/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " Polymorphism Polymorphsim is a concept that describes the fact that similar objects tend to behave in similar ways, even if they are not exactly alike. For example, if we might have a set of shapes such as a square, a circle, and a rhombus. While each shape shares certain attributes like having an area and a perimeter. However, each shape is also unique and may have differing number of sides and angles between those sides, or in the case of a circle, a diameter. We describe this relationship by saying a circle (or rectangle, or rhombus) “is a” shape as shown in the figure below.\nInheritance Inheritance is a mechanism that captures polymorphism by allowing classes to inherit the methods and attributes from another class. The basic purpose of inheritance to to reuse code in a principled and organized manner. We generally call the inheriting class the subclass or child class, while the class it inherits from is called the superclass or parent class.\nBasically, when class ‘A’ inherits from class ‘B’, all the methods and attributes of class ‘A’ are automatically copied to class ‘B’. Class ‘B’ can then add additional methods or attributes to extend class ‘A’, or overwrite the implementations of methods in class ‘A’ to specialize it.\nWhen programming, we use inheritance to implement polymorphism. In our shape example, we would have a generic (or abstract) Shape class, which is inherited by a set of more specific shape classes (or specializations) as shown below.\nIn this example, the Shape class defines the ‘color’ attribute and the ‘getArea’ and ‘getCircumference’ methods, which are inherited by the Rectangle, Circle, and Rhombus classes. Each of the subclasses define additional attributes that are unique to the definition of each shape type.\nNotice that although the Shape class defines the signatures for the ‘getArea’ and ‘getCircumference’ methods, it cannot define the implementation of the methods, since this is unique to each subclass shape. Thus, each subclass shape will specialize the Shape class by implementing their own ‘getArea’ and ‘getCircumference’ methods.\nMultiple Inheritance So far, we have discussed Single inheritance, which occurs when a class has only one superclass. However, theoretically, a class may inherit from more than one superclass, which is termed multiple inheritance. While a powerful mechanism, multiple inheritance also introduces complexity into understanding and implementing programs. And, there is always the possibility that attributes and methods from the various superclasses contradict each other in the subclass.",
    "description": "Polymorphism Polymorphsim is a concept that describes the fact that similar objects tend to behave in similar ways, even if they are not exactly alike. For example, if we might have a set of shapes such as a square, a circle, and a rhombus. While each shape shares certain attributes like having an area and a perimeter. However, each shape is also unique and may have differing number of sides and angles between those sides, or in the case of a circle, a diameter.",
    "tags": [],
    "title": "Inheritance",
    "uri": "/cc310/02-oop-review/05-inheritance/"
  },
  {
    "breadcrumb": "Performance",
    "content": " Unsorted Linked List The next data structure we learned about is the linked list. Specifically, we will look at the doubly linked list in this example, but in most instances the performance of a singly linked list is comparable.\nWith a linked list, the process of inserting an element at either the beginning or the end is a constant time operation since we maintain both a head and a tail reference. All we must do is create a new node and update a few references and we are good to go.\nHowever, if we would like to access a specific element somewhere in the list, we will have to iterate through the list starting from either the head or the tail until we find the element we need. So, that operation runs in order $N$ time. This is the major difference between linked lists and arrays: with an array, we can directly access items using the array index, but with linked lists we must iterate to get to that element. This becomes important in the next section when we discuss the performance of a sorted linked list.\nSimilarly, the process of finding an element also requires iterating through the list, which is an operation that runs in order $N$ time.\nFinally, if we want to find and delete an element, that also runs in order $N$ time since we must search through the list to find the element. Once we have found the element, the process of deleting that element is a constant time operation. So, if we use our list iterator methods in an efficient manner, the actual run time may be more efficient than this analysis would lead us to believe.\nSorted Linked List We have not directly analyzed the performance of a sorted linked list in this course, but hopefully the analysis makes sense based on what we have learned before. Since the process of iterating through a linked list runs in order of $N$ time, every operation required to build a sorted linked list is limited by that fact.\nFor example, if we want to insert an element into a list in sorted order, we must simply iterate through the list to find the correct location to insert it. Once we’ve found it, the process of inserting is actually a constant time operation since we don’t have to shift any elements around, but because we can’t use binary search on a linked list, we don’t have any way to take advantage of the fact that the list is sorted.\nThe same problem occurs when we want to search for a particular element. Since we cannot use binary search to jump around between various elements in the list, we are limited to a simple linear search process, which runs in order of $N$ time.\nLikewise, when we want to search and delete an element from the list, we must once again iterate through the entire list, resulting in an operation that runs in order $N$ time.\nSo, is there any benefit to sorting a linked list? Based on this analysis, not really! The purpose of sorting a collection is simply to make searching for a particular element faster. However, since we cannot use array indices to jump around a list like we can with an array, we do not see much of an improvement.\nHowever, in the real world, we can improve some of these linear algorithms by “short-circuiting” them. When we “short-circuit” an algorithm, we provide additional code that allows the algorithm to return early if it realizes that it will not succeed.\nFor example, if we are searching for a particular element in a sorted list, we can add an if statement to check and see if the current element is greater than the element we are searching for. If the list is sorted in ascending order, we know that we have gone past the location where we expected to find our element, so we can just return without checking the rest of the list. While this does not change the mathematical analysis of the running time of this operation, it may improve the real-world empirical analysis of the operation.\nLinked List Stack (LIFO) and Linked List Queue (FIFO) We already saw how to use the operations from a linked list to implement both a stack and a queue. Since those data structures restrict the operations we can perform a bit, it turns out that we can use a linked list to implement a stack and a queue with comparable performance to an array implementation.\nFor example, inserting, accessing, and removing elements in a stack or a queue based on a doubly linked list are all constant time operations, since we can use the head and tail references in a doubly linked list to avoid the need to iterate through the entire list to perform those operations. In fact, the only time we would have to iterate through the entire list is when we want to find a particular element in the stack or the queue. However, since we cannot sort a stack or a queue, finding an element runs in order $N$ time, which is comparable to an array implementation.\nBy limiting the actions we want to perform with our linked list, we can get a level of performance similar to an array implementation of a stack or a queue. It is a useful outcome that demonstrates the ability of different data structures to achieve similar outcomes.",
    "description": "Unsorted Linked List The next data structure we learned about is the linked list. Specifically, we will look at the doubly linked list in this example, but in most instances the performance of a singly linked list is comparable.\nWith a linked list, the process of inserting an element at either the beginning or the end is a constant time operation since we maintain both a head and a tail reference.",
    "tags": [],
    "title": "Lists",
    "uri": "/cc310/12-performance/5-lists/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "We looked at an iterative version of the find function above. But what would it take to turn that function into a recursive function? While for this particular function, there is not a lot to be gained from the recursive version, it is still instructive to see how we would do it. We will find recursive functions more useful later on in the module.\nIn this case, to implement a recursive version of the function, we need to add a third parameter, index, to tell us where to check in the array. We assume that at the beginning of a search, index begins at 0. Then, if number is not in location index in the array, index will be incremented before making another recursive call. Of course, if number is in location index, we will return the number of index. The pseudocode for the findR function is shown below.\nfunction FINDR (NUMBER, ARRAY, INDEX) (1) if INDEX \u003e= size of ARRAY then\t(2) return -1\t(3) else if ARRAY[INDEX] == NUMBER\t(4) return INDEX\t(5) else\t(6) return FINDR (NUMBER, ARRAY, INDEX + 1)\t(7) end if\t(8) end function\t(9)First, we check to see if index has moved beyond the bounds of the array, which would indicate that we have searched all the locations in array for number. If that is the case, then we return -1 in line 3 indicating that we did not find number in array. Next, we check to see if number is found in array[index] in line 4. If it is, the we are successful and return the index. However, if we are not finished searching and we have not found number, then we recursively call findR and increment index by 1 to search the next location.\nAn example of using the findR function is shown below. The top half of the figure shows the state of the data in the initial call to the findR function (instance 1). The bottom half of the figure shows the recursive path through the function. The beginning of instance 1 shows the if statement in line 2. In instance 1, since we have not searched the entire array (line 2) and array[0] is not equal to number (line 4), we fall down to the else part function and execute line 7, the recursive call. Since index is 0 in instance 1, we call instance 2 of the function with an index of 1.\nIn instance 2, the same thing happens as in instance 1 and we fall down to the else part of the if statement. Once again, we call a new instance of findR, this time with index set at 2. Now, in instance 3, array[index] is equal to number in line 4 and so we execute the return index statement in line 5. The value of index (2) is returned to instance 2, which, in line 7, simply returns the value of 2 to instance 1. Again, in line 7, instance 1 returns that same value (2) to the original calling function.\nNotice that the actual process of searching the array is the same for both the iterative and recursive functions. It is only the implementation of that process that is different between the two.",
    "description": "We looked at an iterative version of the find function above. But what would it take to turn that function into a recursive function? While for this particular function, there is not a lot to be gained from the recursive version, it is still instructive to see how we would do it. We will find recursive functions more useful later on in the module.\nIn this case, to implement a recursive version of the function, we need to add a third parameter, index, to tell us where to check in the array.",
    "tags": [],
    "title": "Recursive Linear Search",
    "uri": "/cc310/7-searching-and-sorting/5-recursive-linear-search/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": " Another linear data structure is known as a set. A set is very similar to a list, but with two major differences:\nA set cannot contain duplicate elements. Each element must be unique in the set. A set does not necessarily keep track of the ordering of the elements within the set. In fact, the term set comes from mathematics. We’ve probably seen sets already in a math class.\nBeyond the typical operations to add and remove elements from a set, there are several operations unique to sets:\nunion - find the elements that are contained in one or both of the sets given; intersection - find the elements only contained in both sets given; set difference - remove all elements from a set that are also contained in another set; and subset - test if all elements in one set are also contained in another set. Again, many of these operations may be familiar from their use in various math classes.\nSet Operations and Boolean Logic In addition, we can easily think of set operations as boolean logic operators. For example, the set operation union is very similar to the boolean operator or, as seen in the diagram below.\n1\nAs long as an item is contained in one set or the other, it is included in the union of the sets.\nSimilarly, the same comparison works for the set operation intersection and the boolean and operator.\n2\nOnce again, if an item is contained in the first set and the second set, it is contained in the intersection of those sets.\nWhen to Use a Set A set is a great choice when we know that our program should prevent duplicate items from being added to a data structure. Likewise, if we know we’ll be using some of the specific operations that are unique to sets, then a set is an excellent choice.\nOf course, if we aren’t sure that our data structure will only store unique items, we won’t be able to use a set.\nFile:Venn0111.svg. (2019, November 15). Wikimedia Commons, the free media repository. Retrieved 02:37, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Venn0111.svg\u0026oldid=375571745. ↩︎\nFile:Venn0001.svg. (2019, November 15). Wikimedia Commons, the free media repository. Retrieved 02:37, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Venn0001.svg\u0026oldid=375571733. ↩︎",
    "description": "Another linear data structure is known as a set. A set is very similar to a list, but with two major differences:\nA set cannot contain duplicate elements. Each element must be unique in the set. A set does not necessarily keep track of the ordering of the elements within the set. In fact, the term set comes from mathematics. We’ve probably seen sets already in a math class.",
    "tags": [],
    "title": "Sets",
    "uri": "/cc310/03-intro-dsa/05-sets/"
  },
  {
    "breadcrumb": "Lists",
    "content": " Given the structure of our linked list, we can easily insert a new node at any location in the list. However, for our purposes we are generally interested in inserting new nodes at the beginning of the list, at some specific location in the list, or in the appropriate order if the list is sorted.\nInserting at the Beginning Inserting a node at the beginning of a list is straightforward. We just have to be careful about the order we use when swapping pointers. In the prepend code below, line 1 creates the new node to be stored in the list. Next, line 2 assigns the pointer in the new node to point to the pointer held by the head. If there was an item already in the list, head will point to the previous first item in the list. If the list was empty, head will have been null and thus the node.next will become null as well. Line 3 assigns head to point to the new node and line 4 increments our size variable.\nfunction prepend(data) node = new Node(data)\t(1) node.next = head (2) head = node\t(3) size = size + 1\t(4) end function We show this process in the following example. The figure below shows the initial state as we enter the prepend operation. Our list has three items in it, an “a”, “W”, and “Q” and we want to add the new node “M” in front of item “a”.\nThe figure below shows the effect of the first step of the operation. This step creates a new node for “M” and changes next to point at the same node as the pointer held by head, which is the address of the first item in the list, “a”.\nThe result of performing line 3 in the operation is shown below. In line 3 we simply change head to point to our new node, instead of node “a”. Notice now that the new node has been fully inserted into the list.\nAnd, if we redraw our diagram a bit, we get a nice neat list!\nSince there are no loops in the prepend operation, prepend runs in constant time.\nInserting in the Middle Inserting a node at a given index in the linked list is a little more difficult than inserting a node at the beginning of the list. First, we have to find the proper location to insert the new node before we can actually insert it. However, since we are given an index number, we simply need to follow the linked list to the appropriate index and then perform the insertion.\nWe do have a precondition to meet before we proceed, however. We need to make sure that the index provided to the operation is not less than 0 and that it is not greater than the size of the list, which is checked in line 2. If the precondition is not satisfied, we raise an exception in line 3.\nfunction insertAt(data, index)\t(1) if index \u003c 0 or index \u003e size\t(2) raise exception\t(3) elseif index == 0\t(4) prepend(data)\t(5) else curr = head.next\t(6) prev = head\t(7) node = new Node(data)\t(8) for i = 1 to index – 1\t(9) prev = curr\t(10) curr = curr.next\t(11) end for\t(12) prev.next = node\t(13) node.next = curr\t(14) size = size + 1\t(15) end if end function Lines 4 and 5 check to see if the index is 0, which means that we want to insert it as the first item in the list. Since this is the same as the prepend operation we’ve already defined, we simply call that operation. While this may not seem like a big deal, it is actually more efficient and helps us to simplify the code in the rest of the operation.\nThe operation uses curr to keep track of which node in the list we are currently looking at, thus we initialize curr to point at the first node in the list in line 6. To allow us to swap pointers once we find the appropriate place in the list, we keep track of the node previous to curr as well by using the variable pre. This variable is initialized to head in line 7, and line 8 creates the new node we will insert into our list. After line 8, our list, node, and previous pointers would look like the following (assuming the index passed in was 2).\nAt this point we start our walk through the list using the for loop in lines 9 - 12. Specifically, with an index of 2 we will actually go through the loop exactly one time, from 1 to 1. Each time through the loop, lines 10 and 11 will cause curr and prev to point at the next nodes in the list. At the end of one time through our loop, our example will be as shown below.\nNow, the only thing left to do is update the next pointer of node “3” to point at node (line 13), and node.next to point at curr node (line 14), while line 15 increments the size attribute. The updated list is shown below.\nThe insertAt operation, while being quite flexible and useful, can potentially loop through each node in the list. Therefore, it runs in order $N$ time.\nInserting in Order When we want to insert an item into an ordered list, we need to find the right place in the list to actually insert the new node. Essentially, we need to search the list to find two adjacent nodes where the first node’s data is less than or equal to data and the second node’s data is greater than data. This process requires a linear search of the list.\nfunction insertOrdered(data) curr = head\t(1) index = 0\t(2) while curr != NULL AND curr.data \u003c data\t(3) index = index + 1\t(4) curr = curr.next\t(5) end while insertAt(data, index)\t(6) end function Notice that we do not have a precondition since we will search the list for the appropriate place to insert the new node, even if the list is currently empty. In line 1, we create a curr variable to point to the current node we are checking in the list, while in line 2 we initialize an index variable to keep track of the index of curr in the list.\nNext, lines 3 – 5 implement a loop that searches through the list to find a node where the data in that node is greater than or equal to the data we are trying to put into the list. We also check to see if we are at the end of the list. Inside the loop, we increment index and point curr to the next node in the list.\nOnce we find the appropriate place in the list, we simply call the insertAt operation to perform the actual insertion. Using the insertAt operation provides a nice, easy to understand operation. However, we do suffer a little in efficiency since both operations loop through the list to the location where we want to insert the new data node. However, since the insertAt call is not embedded within the loop, our insertOrdered operation still runs in order $N$ time.\nSince the previous example inserts the number 2 into the list (which falls between -1 and 3), the results of running the insertOrdered operation will be the same output as the result of the insertAt operation as shown above.",
    "description": "Given the structure of our linked list, we can easily insert a new node at any location in the list. However, for our purposes we are generally interested in inserting new nodes at the beginning of the list, at some specific location in the list, or in the appropriate order if the list is sorted.\nInserting at the Beginning Inserting a node at the beginning of a list is straightforward.",
    "tags": [],
    "title": "Singly Linked Lists - Insertion",
    "uri": "/cc310/9-lists/5-singly-linked-lists---insertion/"
  },
  {
    "breadcrumb": "Recursion",
    "content": " In the previous examples we saw recursive functions that call themselves one time within the code. This type of recursion is called linear recursion, where head and tail recursion are two specific types of linear recursion.\nIn this section we will investigate another type of recursion called tree recursion, which occurs when a function calls itself two or more times to solve a single problem. To illustrate tree recursion, we will use a simple recursive function MAX, which finds the maximum of $N$ elements in an array. To calculate the maximum of $N$ elements we will use the following recursive algorithm.\nCompute the maximum of the first $N/2$ elements and store in MAX1. Compute the maximum of the last $N/2$ elements and store in MAX2. Compare MAX1 and MAX2 to find the maximum of all elements. Our process recursively decomposes the problem by searching for the maximum in the first $N/2$ elements and the second $N/2$ elements until we reach the base case. In this problem, the base case is when we either have 1 or 2 elements in the array. If we just have 1, we return that value. If we have 2, we return the larger of those two values. An overview of the process is shown below.\nThe pseudocode for the algorithm is shown below.\nfunction MAX(VALUES, START, END) print \"Called MAX with start = \" + START + \", end = \" + END if END – START = 0 return VALUES[START] else if END – START = 1 if VALUES(START) \u003e VALUES(END) return VALUES[START] else return VALUES[END] end if else MIDDLE = ROUND((END – START) / 2) MAX1 = MAX(VALUES, START, START + MIDDLE – 1) MAX2 = MAX(VALUES, START + MIDDLE, END) if MAX1 \u003e MAX2 return MAX1 else return MAX2 end if end if end function The following block shows the output from the print line in the MAX function above. The initial call to the function is MAX(VALUES, 0, 15).\nCalled MAX with start = 0, end = 7 Called MAX with start = 0, end = 3 Called MAX with start = 0, end = 1 Called MAX with start = 2, end = 3 Called MAX with start = 4, end = 7 Called MAX with start = 4, end = 5 Called MAX with start = 6, end = 7 Called MAX with start = 8, end = 15 Called MAX with start = 8, end = 11 Called MAX with start = 8, end = 9 Called MAX with start = 10, end = 11 Called MAX with start = 12, end = 15 Called MAX with start = 12, end = 13 Called MAX with start = 14, end = 15 As you can see, MAX decomposes the array each time it is called, resulting in 14 instances of the MAX function being called. If we had performed head or tail recursion to compare each value in the array, we would have to have called MAX 16 times. While this may not seem like a huge savings, as the value of $N$ grows, so do the savings.",
    "description": "In the previous examples we saw recursive functions that call themselves one time within the code. This type of recursion is called linear recursion, where head and tail recursion are two specific types of linear recursion.\nIn this section we will investigate another type of recursion called tree recursion, which occurs when a function calls itself two or more times to solve a single problem. To illustrate tree recursion, we will use a simple recursive function MAX, which finds the maximum of $N$ elements in an array.",
    "tags": [],
    "title": "Tree Recursion",
    "uri": "/cc310/6-recursion/5-tree-recursion/"
  },
  {
    "breadcrumb": "Stacks",
    "content": "The following table shows an example of how to use the above operations to create and manipulate a stack. It assumes the steps are performed sequentially and the result of the operation is shown.\nStep Operation Effect 1 Constructor Creates an empty stack. 2 isFull() Returns false since top is not equal to the capacity of the stack. 3 isEmpty() Returns true since top is equal to -1 4 push(1) Increments top by 1 and then places item $1$ onto the top of the stack 5 push(2) Increments top by 1 and then places item $2$ onto the top of the stack 6 push(3) Increments top by 1 and then places item $3$ onto the top of the stack 7 peek() Returns the item $3$ on the top of the stack but does not remove the item from the stack. top is unaffected by peek 8 pop() Returns the item $3$ from the top of the stack and removes the item from the stack. top is decremented by 1. 9 pop() Returns the item $2$ from the top of the stack and removes the item from the stack. top is decremented by 1. 10 pop() Returns the item $1$ from the top of the stack and removes the item from the stack. top is decremented by 1. 11 isEmpty() Returns true since top is equal to -1 ",
    "description": "The following table shows an example of how to use the above operations to create and manipulate a stack. It assumes the steps are performed sequentially and the result of the operation is shown.\nStep Operation Effect 1 Constructor Creates an empty stack. 2 isFull() Returns false since top is not equal to the capacity of the stack. 3 isEmpty() Returns true since top is equal to -1 4 push(1) Increments top by 1 and then places item $1$ onto the top of the stack 5 push(2) Increments top by 1 and then places item $2$ onto the top of the stack 6 push(3) Increments top by 1 and then places item $3$ onto the top of the stack 7 peek() Returns the item $3$ on the top of the stack but does not remove the item from the stack.",
    "tags": [],
    "title": "Using Operations",
    "uri": "/cc310/5-stacks/5-using-operations/"
  },
  {
    "breadcrumb": "Queues",
    "content": "The following table shows an example of how to use the above operations to create and manipulate a queue. It assumes the steps are performed sequentially and the result of the operation is shown.\nStep Operation Effect 1 Constructor Creates an empty queue of capacity 3. 2 isFull() Returns false since start is not equal to end 3 isEmpty() Returns true since start is equal to -1. 4 enqueue(1) Places item 1 onto queue at the end and increments end by 1. 5 enqueue(2) Places item 2 onto queue at the end and increments end by 1. 6 enqueue(3) Places item 3 onto queue at the end and sets end to end+1 modulo the size of the array (3). The result of the operation is 0, thus end is set to 0. 7 peek() Returns the item 1 on the start of the queue but does not remove the item from the queue. start and end are unaffected by peek. 8 isFull() Returns true since start is equal to end 9 dequeue() Returns the item 1 from the start of the queue. start is incremented by 1, effectively removing 1 from the queue. 10 dequeue() Returns the item 2 from the start of the queue. start is incremented by 1, effectively removing 2 from the queue. 11 enqueue(4) Places item 4 onto queue at the end and increments end. 12 dequeue() Returns the item 3 from the start of the queue. start is set to start+1 modulo the size of the array (3). The result of the operation is 0, thus start is set to 0. 13 dequeue() Returns the item 4 from the start of the queue. start is incremented by 1, and since start == end, they are both reset to -1 and 0 respectively. 14 isEmpty() Returns true since start is equal to -1. ",
    "description": "The following table shows an example of how to use the above operations to create and manipulate a queue. It assumes the steps are performed sequentially and the result of the operation is shown.\nStep Operation Effect 1 Constructor Creates an empty queue of capacity 3. 2 isFull() Returns false since start is not equal to end 3 isEmpty() Returns true since start is equal to -1. 4 enqueue(1) Places item 1 onto queue at the end and increments end by 1.",
    "tags": [],
    "title": "Using Operations",
    "uri": "/cc310/8-queues/5-using-operations/"
  },
  {
    "breadcrumb": "Sets",
    "content": " One of the most common uses of set operations is in database systems. While we will not create a full database system here, we will show you the basics of how they work using our set operations. Assume you have three sets of people:\n$$\r\\text{Students} = \\{ \\text{\"Vanessa\"}, \\text{\"Travis\"}, \\text{\"Lu\"}, \\text{\"Cole\"}, \\text{\"Jordan\"}, \\text{\"Elaine\"}, \\text{\"Caleb\"} \\} \\\\\r\\text{Family} = \\{ \\text{\"Amy\"}, \\text{\"Scott\"}, \\text{\"Vanessa\"}, \\text{\"Lauren\"}, \\text{\"Zachary\"}, \\text{\"Jordan\"}, \\text{\"Caleb\"} \\} \\\\\r\\text{Workers} = \\{\\text{\"Lauren\"}, \\text{\"Amy\"}, \\text{\"Felix\"}, \\text{\"Zachary\"}, \\text{\"Quinn\"}, \\text{\"Jordan\"}, \\text{\"Gabrielle\"} \\}\r$$ The goal of our application is to be able to answer the following types of questions about the data.\nHow many students are there? How many workers are there? How many workers are students too? How many in my family do not go to school? Who works and goes to school? Who works or goes to school? Who works and does not go to school? Who in my family does not go to school? Who in my family does not work or go to school? The first step in our program is to add all the data to sets as shown below.\nSet students = new Set() students.add(\"Vanessa\") students.add(\"Travis\") students.add(\"Lu\") students.add(\"Cole\") students.add(\"Jordan\") students.add(\"Elaine\") students.add(\"Caleb\") Set family = new Set() family.add(\"Amy\") family.add(\"Scott\") family.add(\"Vanessa\") family.add(\"Lauren\") family.add(\"Zachary\") family.add(\"Jordan\") family.add(\"Caleb\") Set workers = new Set() workers.add(\"Lauren\") workers.add(\"Amy\") workers.add(\"Felix\") workers.add(\"Zachary\") workers.add(\"Quinn\") workers.add(\"Jordan\") workers.add(\"Gabrielle\") Once we have all the data in sets, we can use our set operations to find the information we are after. If we wanted to get a count of students and workers to answer questions 1 and 2, we can use the getter operation getSize in the following expressions.\nstudents.getSize() workers.getSize() Question 3 is a little more interesting. Obviously, we will use the getSize operation again, but we can’t use it directly on an existing set. We need to compute the set that holds only people who are both in the worker and student sets. Luckily, we have the intersection operation to help us do this. We simply need to compute the intersection of the workers and students and then take the size of that set as shown below.\nworkers.intersection(students).getSize() Question 4 asks who is in the family set but is not in the student set. We can use the difference operation to compute this set. Again, we use the getSize operation to obtain the size.\nfamily.difference(students).getSize() Question 5 asks a slightly different question than question 3. It asks “who” works and goes to school, not just the number. Now, we compute the set of student-workers the same way, we just use the toString operation to produce a list of people in the set instead of just reporting the size.\nworkers.intersection(students).toString() Question 6 asks who works or goes to school. To answer this question, we need a set of people which includes anyone who is either a worker or a student. This requires the union operation. We can compute the union of the two sets as follows.\nworkers.union(students).toString() Question 7 wants to know who works and does not go to school. Again, this is everyone in workers who is not in students. This uses the difference operation as shown below.\nworkers.difference(students).toString() Question 8 is similar and asks who in the family does not go to school. Obviously, we can use the previous expression and just replace the workers set with the family set.\nfamily.difference(students).toString() Finally, question 9 asks who in the family does not work or go to school. This is basically asking who is in the family set that is not in the work set or the school set. There are actually a couple of ways to approach this. We could take the difference between the family and the workers and then take the difference between the resulting set and the students as shown below.\nfamily.difference(workers).difference(students).toString() Alternatively, we could take the difference between the family and the union of the worker and student sets. This solution is shown below.\nfamily.difference(workers.union(students)).toString() If we put all this into a program with the appropriate statements to write the solutions to the console, we would get the following output.\nHow many students are there? 7 How many workers are there? 7 How many workers are students too? 1 Who in my family does not go to school? 4 Who works and goes to school? Jordan Who works or goes to school? Lauren, Amy, Felix, Zachary, Quinn, Gabrielle, Vanessa, Travis, Lu, Cole, Jordan, Elaine, Caleb Who works and does not go to school? Lauren, Amy, Felix, Zachary, Quinn, Gabrielle Who in my family does not go to school? Amy, Scott, Lauren, Zachary Who in my family does not work or go to school? Scott As you can see, we can use set operations to quickly and easily compute solutions to database type applications. While we don’t often create special set-based solutions to data applications like this, we do use existing database applications that work on the same principle.",
    "description": "One of the most common uses of set operations is in database systems. While we will not create a full database system here, we will show you the basics of how they work using our set operations. Assume you have three sets of people:\n$$\r\\text{Students} = \\{ \\text{\"Vanessa\"}, \\text{\"Travis\"}, \\text{\"Lu\"}, \\text{\"Cole\"}, \\text{\"Jordan\"}, \\text{\"Elaine\"}, \\text{\"Caleb\"} \\} \\\\\r\\text{Family} = \\{ \\text{\"Amy\"}, \\text{\"Scott\"}, \\text{\"Vanessa\"}, \\text{\"Lauren\"}, \\text{\"Zachary\"}, \\text{\"Jordan\"}, \\text{\"Caleb\"} \\} \\\\\r\\text{Workers} = \\{\\text{\"",
    "tags": [],
    "title": "Using Sets",
    "uri": "/cc310/10-sets/5-using-sets/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome! This page is the main page for Recursion",
    "description": "Welcome! This page is the main page for Recursion",
    "tags": [],
    "title": "Recursion",
    "uri": "/cc310/6-recursion/"
  },
  {
    "breadcrumb": "Introduction",
    "content": " Resources Slides K-State IT Help Desk - Email helpdesk@ksu.edu K-State Online Canvas Help Instructure Canvas Guides Codio Documentation Codio Support K-State Libraries K-State CS Support K-State CS Advising K-State Engineering Student Services K-State Office of Student Life K-State Report It Video Script As you work on the materials in this course, you may run into questions or problems and need assistance. This video reviews the various types of help available to you in this course.\nFirst and foremost, anytime you have a questions or need assistance in the Computational Core program, please send an email to the appropriate help group for this course. In this case, it would be cc410-help, or cc410-help@ksuemailprod.onmicrosoft.com. That email goes to the instructors and GTAs, and is your best chance to get a quick response. We’ll respond to your email within one business day.\nBeyond email, there are a few resources you should be aware of. First, if you have any issues working with K-State Canvas, K-State IT resources, or any other technology related to the delivery of the course, your first source of help is the K-State IT Helpdesk. They can easily be reached via email at helpdesk@ksu.edu. Beyond them, there are many online resources for using Canvas, all of which are linked in the resources section below the video. As a last resort, you may also want to email the help group, but in most cases we may simply redirect you to the K-State helpdesk for assistance.\nSimilarly, if you have any issues using the Codio platform, you are welcome to refer to their online documentation. Their support staff offers a quick and easy chat interface where you can ask questions and get feedback within a few minutes.\nIf you have issues with the technical content of the course, specifically related to completing the tutorials and projects, there are several resources available to you. First and foremost, make sure you consult the vast amount of material available in the course modules, including the links to resources. Usually, most answers you need can be found there.\nIf you are still stuck or unsure of where to go, the next best thing is to post your question as an email to the help group. As discussed earlier, the instructors and GTAs will do their best to help you as soon as they can.\nOf course, as another step you can always exercise your information-gathering skills and use online search tools such as Google to answer your question. While you are not allowed to search online for direct solutions to assignments or projects, you are more than welcome to use Google to access programming resources such as StackOverflow, language documentation, and other tutorials. I can definitely assure you that programmers working in industry are often using Google and other online resources to solve problems, so there is no reason why you shouldn’t start building that skill now.\nNext, we have grading and administrative issues. This could include problems or mistakes in the grade you received on a project, missing course resources, or any concerns you have regarding the course and the conduct of myself and your peers. Since this is an online course, you’ll be interacting with us on a variety of online platforms, and sometimes things happen that are inappropriate or offensive. There are lots of resources at K-State to help you with those situations. First and foremost, please email me directly as soon as possible and let me know about your concern, if it is appropriate for me to be involved. If not, or if you’d rather talk with someone other than me about your issue, I encourage you to contact either your academic advisor, the CS department staff, College of Engineering Student Services, or the K-State Office of Student Life. Finally, if you have any concerns that you feel should be reported to K-State, you can do so at https://www.k-state.edu/report/. That site also has links to a large number of resources at K-State that you can use when you need help.\nFinally, if you find any errors or omissions in the course content, or have suggestions for additional resources to include in the course, email the help group. There are some extra credit points available for helping to improve the course, so be on the lookout for anything that you feel could be changed or improved.\nSo, in summary, reviewing the existing course content should always be your first stop when you have a question or run into a problem, since most issues can be solved there. If you are still stuck, email cc410-help to ask for assistance, and we’ll get back to you within a business day. For issues with Canvas or Codio, you are also welcome to refer directly to the resources for those platforms. For grading questions and errors in the course content or any other issues, please email cc410-help or the instructors directly for assistance.\nOur goal in this program is to make sure that you have the resources available to you to be successful. Please don’t be afraid to take advantage of them and ask questions whenever you want.",
    "description": "Resources Slides K-State IT Help Desk - Email helpdesk@ksu.edu K-State Online Canvas Help Instructure Canvas Guides Codio Documentation Codio Support K-State Libraries K-State CS Support K-State CS Advising K-State Engineering Student Services K-State Office of Student Life K-State Report It Video Script As you work on the materials in this course, you may run into questions or problems and need assistance. This video reviews the various types of help available to you in this course.",
    "tags": [],
    "title": "Where to Find Help",
    "uri": "/cc310/00-introduction/03-where-to-find-help/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " For object a to be able to call a method in object b, object a must have a reference (a pointer, or the address of) object b. In many cases, objects a and b will be in a long-term relationship so that one or both objects will need to store the reference to the other in an attribute. When an object holds a reference to another object in an attribute, we call this a link. Examples of such relationships include a driver owning a car, a person living at an address, or a worker being employed by a company.\nAs we discussed earlier, objects are instances of classes. To represent this in a UML class diagram, we use the notion of an association, which is shown as a line connecting to two classes. More precisely, a link is an instance of an association. The figure belows shows three examples of an association between class A and class B.\nThe top example shows the basic layout of an association in UML. The line between the two classes denotes the association itself. The diagram specifies that ClassA is associated with ClassB and vice versa. We can name the association as well as place multiplicities on the relationships. The multiplicities show exactly how many links an object of one class must have to objects of the associated class. The general form a multiplicity is n .. m, which means that an object must store at least n, but no more than m references to other objects of the associated class; if only one number is given such as n, then the object must store exactly n references to objects in the associated class.\nThere are two basic types of associations.\nTwo-way - both classes store references to the other class. One-way - only one class stores a reference to its associated class. The middle example shows a two-way association between ClassA and ClassB. Furthermore, each object of ClassA must have a link to exactly three objects of ClassB, while each ClassB object must have a link with exactly one ClassA object. (Note that the multiplicity that constrains ClassA is located next to ClassB, while the multiplicity that constrains ClassB is located next to ClassA.)\nThe bottom example shows a one-way association between ClassA and ClassB. In this case, ClassA must have links to either zero or one objects of ClassB. Since it is a one-way association, ClassB will have no links to objects of ClassA.",
    "description": "For object a to be able to call a method in object b, object a must have a reference (a pointer, or the address of) object b. In many cases, objects a and b will be in a long-term relationship so that one or both objects will need to store the reference to the other in an attribute. When an object holds a reference to another object in an attribute, we call this a link.",
    "tags": [],
    "title": "Associations",
    "uri": "/cc310/02-oop-review/06-associations/"
  },
  {
    "breadcrumb": "Recursion",
    "content": " Next, we will look at calculating Fibonacci numbers using a tree recursive algorithm. Fibonacci numbers are given by the following recursive formula. $$\rf_n = f_{n-1} + f_{n-2}\r$$ Notice that Fibonacci numbers are defined recursively, so they should be a perfect application of tree recursion! However, there are cases where recursive functions are too inefficient compared to an iterative version to be of practical use. This typically happens when the recursive solutions to a problem end up solving the same subproblems multiple times. Fibonacci numbers are a great example of this phenomenon.\nCalculating Fibonacci Numbers To complete the definition, we need to specify the base case, which includes two values for the first two Fibonacci numbers: FIB(0) = 0 and FIB(1) = 1. The first Fibonacci numbers are $0, 1, 1, 2, 3, 5, 8, 13, 21 …$.\nProducing the code for finding Fibonacci numbers is very easy from its definition. The extremely simple and elegant solution to computing Fibonacci numbers recursively is shown below.\nfunction FIB(N)\rif N == 0\rreturn 0\relse if N == 1\rreturn 1\relse\rreturn FIB(N-1) + FIB(N-2)\rend if\rend function The following pseudocode performs the same calculations for the iterative version.\nfunction FIBIT(N)\rFIB1 = 1\rFIB2 = 0\rfor (I = 2 to N)\rFIB = FIB1 + FIB2\rFIB2 = FIB1\rFIB1 = FIB\rend loop\rend function While this function is not terribly difficult to understand, there is still quite a bit of mental gymnastics required to see how this implements the computation of Fibonacci numbers and even more to prove that it does so correctly. However, as we will see later, the performance improvements of the iterative solution are worth it.\nIf we analyze the computation required for the 6th Fibonacci number in both the iterative and recursive algorithms, the truth becomes evident. The recursive algorithm calculates the 5th Fibonacci number by recursively calling FIB(4) and FIB(3). In turn, FIB(4) calls FIB(3) and FIB(2). Notice that FIB(3) is actually calculated twice! This is a problem. If we calculate the 36th Fibonacci number, the values of many Fibonacci numbers are calculated repeatedly, over and over.\nTracing the Program To clarify our ideas further, we can consider the recursive tree resulting from the trace of the program to calculate the 6th Fibonacci number. Each of the computations highlighted in the diagram will have been computed previously.\nIf we count the recomputations, we can see how we calculate the 4th Fibonacci number twice, the 3rd Fibonacci number three times, and the 2nd Fibonacci five times. All of this is due to the fact the we do not consider the work done by other recursive calls. Furthermore, the higher our initial number, the worse the situation grows, and at a very rapid pace.\nMemoization To avoid recomputing the same Fibonacci number multiple times, we can save the results of various calculations and reuse them directly instead of recomputing them. This technique is called memoization, which can be used to optimize some functions that use tree recursion.\nTo implement memoization, we simply store the values the first time we compute them in an array. The following pseudocode shows an efficient algorithm that uses an array, called FA, to store and reuse Fibonacci numbers.\nfunction FIBOPT(N) if N == 0 return 0 else if N == 1 return 1 else if FA[N] == -1 FA[N] = FIBOPT(N-1) + FIBOPT(N-2) return FA[N] else return FA[N] end if end function We assume that each element in FA has been initialized to -1. We also assume that N is greater than 0 and that the length of FA is larger than the Fibonacci number N that we are trying to compute. (Of course, we would normally put these assumptions in our precondition; however, since we are focusing on the recursive nature of the function, we will not explicitly show this for now.) The cases where N == 0 and N == 1 are the same as we saw in our previous FIB function. There is no need to store these values in the array when we can return them directly, since storing them in the array takes additional time. The interesting cases are the last two. First, we check to see if FA[N] == -1, which would indicate that we have not computed the Fibonacci number for N yet. If we have not yet computed N’s Fibonacci number, we recursively call FIBOPT(N-1) and FIBOPT(N-2) to compute its value and then store it in the array and return it. If, however, we have already computed the Fibonacci for N (i.e., if FA[N] is not equal to -1), then we simply return the value stored in the array, FA[N].\nAs shown in our original call tree below, using the FIBOPT function, none of the function calls in red will be made at all. While the function calls in yellow will be made, they will simply return a precomputed value from the FA array. Notice that for N = 6, we save 14 of the original 25 function calls required for the FIB function, or a $56\\%$ savings. As N increases, the savings grow even more.",
    "description": "Next, we will look at calculating Fibonacci numbers using a tree recursive algorithm. Fibonacci numbers are given by the following recursive formula. $$\rf_n = f_{n-1} + f_{n-2}\r$$ Notice that Fibonacci numbers are defined recursively, so they should be a perfect application of tree recursion! However, there are cases where recursive functions are too inefficient compared to an iterative version to be of practical use. This typically happens when the recursive solutions to a problem end up solving the same subproblems multiple times.",
    "tags": [],
    "title": "Example: Fibonacci Numbers",
    "uri": "/cc310/6-recursion/6-example--fibonacci-numbers/"
  },
  {
    "breadcrumb": "Hash Tables",
    "content": " In this section, we walk through the pseudocode for some basic set operations built on our hash table class above. In this new version of the set class, we declare mySet as a hash table and use that throughout our operations.\nmySet = new HashTable() When using a hash table to implement sets, one of the most important choices we must make is what to use for a key. This is really difficult in the case of sets since we do not know exactly what types of objects may be put into the set. Our only real option at this point is just to use the entire object as our key. Our choice to use a default hash function in our hash table turns out to be a good one (at least in modern languages such as Python, Java, and C#), since most default hash functions work on any type of objects.\nNext, we discuss the implementation of the important set operations using hash tables.\nContains The contains operation is straightforward since we are using the entire object as the key. We simply return the value from the hash table containsKey operation, which performs the exact function we need.\nfunction contains(object o) returns boolean return mySet.containsKey(o) (1) end function Add The add operation maps almost exactly to the hash table put operation except that the put operation does not return a boolean value. So, we first check to see if the key is already contained in the hash table. If so, we just return false, since we don’t need to add the value to the set. Otherwise, we add a new tuple to the hash table, and then return true.\nfunction add(object o) returns boolean if mySet.containsKey(o) return false end if mySet.put(o, o) return true end function Remove The set remove operation maps almost exactly to the hash table remove operation, so we just call it and then check to see if the result is not null. If it is null, we will return false since the element was not in the set; otherwise we return true.\nfunction remove(object o) returns boolean return mySet.remove(o) != null end function Intersection The intersection operation creates a new set that has only elements which exist in both sets under consideration. In code, we basically accomplish this by looping through the elements in one set and then checking to see if they exist in the other set. If they do, then we include them in the intersection.\nThe pseudocode follows that basic algorithm using the hash table iterator to loop through and look at each element in set1. We start by creating a new set, result, to hold the intersection of set1 and set2 in line 1. Then we get the first element pair from set1 by calling the hash table reset operation in line 2 and the getNext operation in line 3.\nfunction intersection(set1, set2) returns set result = new Set()\t(1) set1.reset()\t(2) current = set1.getNext()\t(3) while current != null\t(4) if set2.contains(current.getKey())\t(5) result.add(current.getKey())\t(6) end if current = set1.getNext()\t(7) end while return result\t(8) end function Lines 4 – 7 implement the loop that walks through each element in set1. If the current element is contained in set2 (line 5), the operation calls the add operation to insert the key of the current element into the result set. Line 7 gets the next element from set1 and loops back to the top. Eventually, we look at each element in set1 and fall out of the loop. When that happens, the intersection operation is complete, and it returns the result set in line 8.\nUnion The union operation is similar to the intersection operation in that we need to use the hash table iterator operations to walk through our sets. The difference lies in what we include in the new result set. While we only walked through set1 in the intersection operation, picking only those objects that existed in set2, here we start by copying all elements from set2 into the result set and then walk through set1 adding each of its elements to the result set as well. (Here we don’t need to worry about adding duplicates since the add operation takes care of that for us.)\nThe code starts in line 1 by making a copy of set2 and assigning it to our new result set. Then, lines 2 and 3 reset the set1 iterator and get the first item from set1. Lines 4 – 6 form the while loop that we use to walk through each element in set1. This time, however, we simply add every element we find in line 5 before getting the next object in line 6. Once the loop exists we are done and we return the result set in line 7.\nfunction union(set1, set2) returns set result = set2.copy()\t(1) set1.reset()\t(2) current = set1.getNext()\t(3) while current != null\t(4) result.add(current.getKey())\t(5) current = set1.getNext()\t(6) end while return result\t(7) end function isSubset The isSubset operation below is very much like the intersection operation above as we have a loop in lines 3 - 6 that checks each element of set1 and checks to see if it is in set2. The difference between the two operations is that in the isSubset operation, we do not build a third result set. Instead, if any element in set1 is not found in set2, then we return false since not all elements of set1 are contained in set2. If we get all the way through the loop, we have checked that each element in set1 was found in set2 and we can return true; set1 is a subset of set2.\nfunction isSubset (set1, set2) returns boolean set1.reset()\t(1) current = set1.getNext()\t(2) while current != null\t(3) if set2.contains(current.getKey())\t(4) return false\t(5) end if current = set1.getNext()\t(6) end while return true\t(7) end function ",
    "description": "In this section, we walk through the pseudocode for some basic set operations built on our hash table class above. In this new version of the set class, we declare mySet as a hash table and use that throughout our operations.\nmySet = new HashTable() When using a hash table to implement sets, one of the most important choices we must make is what to use for a key. This is really difficult in the case of sets since we do not know exactly what types of objects may be put into the set.",
    "tags": [],
    "title": "Hash Table Based Sets",
    "uri": "/cc310/11-hash-tables/6-hash-table-based-sets/"
  },
  {
    "breadcrumb": "Performance",
    "content": " Hash Tables Analyzing the performance of a hash table is a bit trickier than the other data structures, mainly due to how a hash table tries to use its complex structure to get a “best of both worlds” performance outcome.\nFor example, consider the insert operation. In the best case, the hash table has a capacity that is large enough to guarantee that there are not any hash collisions. Each entry in the array of the hash table will be an empty list and inserting an element into an empty list is done in constant time, so the whole operation runs in the order of constant time.\nThe worst case for inserting an item into a hash table would be when every element has the same hash, so every element in the hash table is contained in the same list. In that case, we must iterate through the entire list to make sure the key has not already been used, which would be in the order of $N$ time.\nThankfully, if we properly design our hash table such that the capacity is much larger than our expected size, and the hash function we use to hash our keys results in a properly distributed hash, this worst case scenario should happen very rarely, if ever. Therefore, our expected performance should be closer to constant time.\nOne important thing to remember, however, is that each operation in a hash table requires computing the hash of the key given as input. Therefore, while some operations may run in constant time, if the action of computing the hash is costly, the overall operation may run very slowly.\nThe analysis of the operation to access a single element in a hash table based on a given key is similar. If the hash table elements are distributed across the table, then each list should only contain a single element. In that case, we can just compute the hash of the key and determine if that key has been used in a single operation, which runs in the order of constant time.\nIn the worst case, however, we once again have the situation where all the elements have been placed in the same linked list. We would need to iterate through each element to find the one we are looking for. In that case, the operation would run in the order of $N$ time.\nThe operation for finding a specific element in a hash table is a bit unique. In this case, we are discussing looking for a particular value, not necessarily a particular key. That operation is discussed in the previous paragraph. For the operation, the only possible way forward is to iterate through each list in the hash table and perform a linear search for the requested value, which will always run in order $N$ time.\nFinally, if we want to delete a single element from a hash table based on a given key, the analysis is the same as inserting or finding an element. In the best case, it runs in the order of constant time, but the worst case runs in the order of N time since we must iterate through an entire list of $N$ elements.\nEven though a hash table has some very poor performance in the worst case, as discussed earlier those worst case situations are very rare, and as long as we are careful about how we manage the capacity of our hash table and how we compute the hash of our objects, we can expect to see operations running in near constant time during normal usage.",
    "description": "Hash Tables Analyzing the performance of a hash table is a bit trickier than the other data structures, mainly due to how a hash table tries to use its complex structure to get a “best of both worlds” performance outcome.\nFor example, consider the insert operation. In the best case, the hash table has a capacity that is large enough to guarantee that there are not any hash collisions. Each entry in the array of the hash table will be an empty list and inserting an element into an empty list is done in constant time, so the whole operation runs in the order of constant time.",
    "tags": [],
    "title": "Hash Tables",
    "uri": "/cc310/12-performance/6-hash-tables/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": " The last of the linear data structures may seem linear from the outside, but inside it can be quite a bit more complex.\nThe map data structure is an example of a key-value data structure, also known as a dictionary or associative array. In the simplest case, a map data structure keeps track of a key that uniquely identifies a particular value, and stores that value along with the key in the data structure.\nThen, to retrieve that value, the program must simply provide the same key that was used to store it.\nIn a way, this is very similar to how we use an array, since we provide an array index to store and retrieve items from an array. The only difference is that the key in a map can be any data type! So it is a much more powerful data structure.\nIn fact, this data structure is one of the key ideas behind modern databases, allowing us to store and retrieve database records based on a unique primary key attached to each row in the database.\nMap Operations A map data structure should support the following operations:\nput - places a new value in the map using the given key, get - retrieves a value from the map using the given key, entries - gets all of the values in the map, keys - gets all of the keys in the map, containsKey - determines if the given key is in use in the map, and containsValue - determines if the given value is stored in the map. Later in this course, we’ll devote an entire module to learning how to build our own map data structures and explore these operations in more detail.\nHash Table 1\nOne of the most common ways to implement the map data structure is through the use of a hash table. A hash table uses an array to store the values in the map, and uses a special function called a hash function to convert the given key to a simple number. This number represents the array index for the value. In that way, the same key will always find the value that was given.\nBut what if we have two keys that produce the same array index? In that case, we’ll have to add some additional logic to our map to handle that situation.\nWhen to Use a Map Maps are great data structures when we need to store and retrieve data using a specific key. Just like we would store data in a database or put items in a numbered box to retrieve later, we can use a map as a general purpose storage and retrieval data structure.\nOf course, if our data items don’t have unique keys assigned to them, then using a map may not be the best choice of data structure. Likewise, if each key is a sequential integer, we may be able to use an array just as easily.\nFile:Hash table 3 1 1 0 1 0 0 SP.svg. (2019, August 21). Wikimedia Commons, the free media repository. Retrieved 02:46, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Hash_table_3_1_1_0_1_0_0_SP.svg\u0026oldid=362787583. ↩︎",
    "description": "The last of the linear data structures may seem linear from the outside, but inside it can be quite a bit more complex.\nThe map data structure is an example of a key-value data structure, also known as a dictionary or associative array. In the simplest case, a map data structure keeps track of a key that uniquely identifies a particular value, and stores that value along with the key in the data structure.",
    "tags": [],
    "title": "Maps",
    "uri": "/cc310/03-intro-dsa/06-maps/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "We may also want to search through a data structure to find an item with a specific property. For example, we could search for the student with the maximum age, or the minimum GPA. For this example, let’s consider the case where we’d like to find the minimum value in an array of integers.\nSearching for the minimum number in an unordered array is a different problem than searching for a specific number. First of all, we do not know what number we are searching for. And, since the array is not ordered, we will have to check each and every number in the array.\nThe input parameters of our new function will be different from the find function above, since we do not have a number to search for. In this case, we only have an array of numbers as an input parameter. The output parameter, however, is the same. We still want to return the index of the minimum number in the array. In this case, we will return -1 if there is no minimum number, which can only happen if there is no data in the array when we begin.\nPreconditions:\nThe data in the array can be sorted Postconditions:\nThe function returns the minimum number of the data in the array The function returns -1 if the array is empty Our preconditions and postconditions are also simple. Our precondition is simply that we have an array whose data can be sorted. This is important, because it means that we can compare two elements in the array and determine which one has a smaller value. Otherwise, we couldn’t determine the minimum value at all!\nOur postcondition is that we return the minimum number of the data in the array, or -1 if the array is empty.\nThe function findMin is shown below. First, we check to see if the array is empty. If it is, we simply return -1 in line 3. If not, we assume the location 0 contains the minimum number in the array, and set min equal to 0 in line 5. Then we loop through each location in the array (starting with 1) in line 6 and set min equal to the minimum of the array data at the current index and the data at min. (Note: if the array only has a single number in it, the for loop will not actually execute since index will be initialized to 1, which is already larger than the size of the array – 1, which is 0.) Once we complete the loop, we will be guaranteed that we have the index of the minimum number in the array.\nfunction FINDMIN(ARRAY) (1) if ARRAY is empty then\t(2) return -1\t(3) end if\t(4) MIN = 0\t(5) loop INDEX from 1 to size of ARRAY - 1\t(6) if ARRAY[INDEX] \u003c ARRAY[MIN] (7) MIN = INDEX\t(8) end if\t(9) end for\t(10) return MIN\t(11) end function\t(12)Next, we will walk through the algorithm using our example array in the figure below. Step 1 shows the initial time through the loop. In line 5, min is set to 0 by default and in line 6, index is set equal to 1. Line 7 then computes whether array[1] \u003c array[0]. In this case, it is and we set min = 1 (which is reflected in the next step where min has the value 1).\nStep 2 will end up comparing array[2] \u003c array[1], since min is now 1 and index has been incremented to 2 via the for loop. In this case, array[2] is less than array[1] so we update min again, this time to 2.\nStep 3 follows the same process; however, this time the value in array[3] is 55, which is greater than the current minimum of 3 in array[2]. Therefore, min is not updated. Step 4 finds the minimum value in the array of -3 at index 4 and so updates min to 4. However, steps 5, 6, and 7 do not find new minimum values. Thus, when the loop exits after Step 6, min is set to 4 and this value is returned to the calling program in line 11.",
    "description": "We may also want to search through a data structure to find an item with a specific property. For example, we could search for the student with the maximum age, or the minimum GPA. For this example, let’s consider the case where we’d like to find the minimum value in an array of integers.\nSearching for the minimum number in an unordered array is a different problem than searching for a specific number.",
    "tags": [],
    "title": "Searching for a Minimum",
    "uri": "/cc310/7-searching-and-sorting/6-searching-for-a-minimum/"
  },
  {
    "breadcrumb": "Sets",
    "content": "In this module, we introduced a new data structure, the Set. A set is a collection of values that does not contain any duplicate items. For simplicity, we showed an implementation of a set using a doubly linked list, but we could easily use an array to store a set as well.\nSets also include several unique operations, such as union, intersection, and difference. We looked at the pseudocode for some of these operations, but a few of them are left as exercises for us to complete in the project for this module.\nWhile we rarely use sets in practice, the concepts we learned are instrumental in the development of more complex data storage techniques such as relational databases.",
    "description": "In this module, we introduced a new data structure, the Set. A set is a collection of values that does not contain any duplicate items. For simplicity, we showed an implementation of a set using a doubly linked list, but we could easily use an array to store a set as well.\nSets also include several unique operations, such as union, intersection, and difference. We looked at the pseudocode for some of these operations, but a few of them are left as exercises for us to complete in the project for this module.",
    "tags": [],
    "title": "Sets Summary",
    "uri": "/cc310/10-sets/6-sets-summary/"
  },
  {
    "breadcrumb": "Lists",
    "content": "The process of removing a node from a linked list is fairly straightforward. First, we find the node we want to remove from the list and then change the next pointer from the previous node in the list to the next node in the list. This effectively bypasses the node we want to remove. For instance, if we want to remove node “3” from the following list,\nwe simply change the next pointer in the “-2” node to point to node “18” instead of node “3”. Since no other nodes are pointing at node “3” it is effectively removed from our list as shown below. We then return the data in that node to the requesting function. Eventually, the garbage collector will come along and realize that nothing is referencing node “3” and put it back into available memory.\nInfo Garbage Collector Many programming languages, including Java and Python, automatically manage memory for us. So, as we create or delete objects in memory, a special subroutine called the garbage collector will find and remove any objects that we are no longer using. This will help free up memory so we can use it again.\nOther languages, such as C, require us to do that manually. So, whenever we stop using objects, we would have to also remember to free the memory used by that object. Thankfully, we don’t have to worry about that in this course!\nRemoving at the Beginning Removing an item at the beginning of a list is extremely simple. After checking our precondition in line 1, which ensures that the list is not empty, we create a temporary copy of the data in the first node in line 3 so we can return it later in line 6. However, the actual removal of the first node simply requires us to point head to the second node in the list (line 4), which is found at head.next. This effectively skips over the first node in the list. Finally, we decrement our size variable in line 5 to keep it consistent with the number of nodes now in the list. Since there are no loops, removeFirst runs in constant time.\nfunction removeFirst() returns data if size == 0\t(1) raise exception\t(2) end if temp = head.data\t(3) head = head.next (4) size = size – 1\t(5) return temp\t(6) end functionRemoving in the Middle Removing a node at a specific index in the list is more difficult than simply removing the first node in the list since we have to walk through the list to find the node we want to remove before we can actually remove it. In addition, while walking through the list, we must keep track of the current node as well as the previous node, since removing a node requires us to change the previous node in the list.\nIn our removeAt operation below, we first check our precondition in line 1 to ensure that the index provided is a valid index in the list. If it is, we check to see if index is 0 in line 3 and call the removeFirst operation in line 4 if it is.\nfunction removeAt(index) returns data if index \u003c 0 OR index \u003e size – 1\t(1) raise exception\t(2) else if index == 0\t(3) return removeFirst() (4) else curr = head.next\t(5) prev = head\t(6) for i = 1 to index - 1 (7) prev = curr\t(8) curr = curr.next\t(9) end for prev.next = curr.next\t(10) size = size – 1\t(11) return curr.data\t(12) end if end functionBefore we start our walk through the list using the for loop in lines 7 - 9, we declare two variables in lines 5 and 6:\ncurr points to the current node in our walk, and prev points to the node before curr in the list. Lines 7 – 9 are the for loop that we use to walk through the list to find the node at index. We simply update the values of prev and curr each time through the loop to point to the next node in the list.\nOnce we complete the for loop, curr is pointing at the node we want to remove and prev points at the previous node. Thus, we simply set prev.next = curr.next to bypass the curr node, decrement our size attribute by 1 to retain consistency, and return the data associated with the curr node.\nLike the insertAt operation, the removeAt operation uses a loop and thus runs in order $N$ time.\nRemoving Instances of a Node If we want to remove all occurrences of a specific node from the list, we take the data we want to remove from the list and then search all nodes in the list, removing any whose data matches the data from the input node. We will return the number of nodes removed from the list.\nfunction removeData(data) curr = head\t(1) index = 0\t(2) while (curr != null) (3) if (curr.data == data) (4) removeAt(index)\t(5) end if index = index + 1\t(6) curr = curr.next\t(7) end while\tend functionTo simplify this operation, we will call the removeAt operation to actually remove the node from the list, leaving this operation to simply find the nodes whose data match the input data. We will use two variables in this operation:\ncurr will point to the current node we are checking, and index will keep track of the index of the curr node so we can use the removeAt operation. The main part of the operation is a while loop (lines 3 – 7) that walks through the list, node by node. For each node in the list, we check if its data matches the input data in line 5, and then call removeAt to remove it from the list if it does. Then, each time through the loop, we increment index in line 7 and then point curr to the next node in the list in line 8. When our loop exits, we have removed all the nodes whose data matched the input data.\nSince we walk through the entire list, the removeData operation runs in order $N$ time.",
    "description": "The process of removing a node from a linked list is fairly straightforward. First, we find the node we want to remove from the list and then change the next pointer from the previous node in the list to the next node in the list. This effectively bypasses the node we want to remove. For instance, if we want to remove node “3” from the following list,\nwe simply change the next pointer in the “-2” node to point to node “18” instead of node “3”.",
    "tags": [],
    "title": "Singly Linked Lists - Removal",
    "uri": "/cc310/9-lists/6-singly-linked-lists---removal/"
  },
  {
    "breadcrumb": "Queues",
    "content": " Queues are useful in many applications. Classic real-world software which uses queues includes the scheduling of tasks, sharing of resources, and processing of messages in the proper order. A common need is to schedule tasks to be executed based on their priority. This type of scheduling can be done in a computer or on an assembly line floor, but the basic concept is the same.\nLet’s assume that we are putting windshields onto new cars in a production line. In addition, there are some cars that we want to rush through production faster than others. There are actually three different priorities:\nHigh priority: these cars have been ordered by customers who are waiting for them. Medium priority: these cars have been ordered as “fleet cars” for specific companies. Low priority: these cars are cars used to fill dealer inventories. Ideally, as cars come to the windshield station, we would be able to put their windshields in and send them to the next station before we received the next car. However, this is rarely the case. Since putting on windshields often requires special attention, cars tend to line up to get their windows installed. This is when their priority comes into account. Instead of using a simple queue to line cars up first-come, first-served in FIFO order, we would like to jump high priority cars to the head of the line.\nWhile we could build a sophisticated queueing mechanism that would automatically insert cars in the appropriate order based on priority and then arrival time, we could also use a queue to handle each set of car priorities. A figure illustrating this situation is shown below. As cars come in, they are put in one of three queues: high priority, medium priority, or low priority. When the windshield station completes a car it then takes the next car from the highest priority queue.\nThe interesting part of the problem is the controller at the windshield station that determines which car will be selected to be worked on next. The controller will need to have the following interface:\nfunction receiveCar(car, priority) // receives a car from the previous station and places into a specific queue function bool isEmpty() // returns true if there are no more cars in the queue function getCar() returns car // retrieves the next car based on priority Using this simple interface, we will define a class to act as the windshield station controller. It will receive cars from the previous station and get cars for the windshield station.\nWe start by defining the internal attributes and constructor for the Controller class as follows, using the Queue functions defined earlier in this module. We first declare three separate queues, one each for high, medium, and low priority cars. Next, we create the constructor for the Controller class. The constructor simply initializes our three queues with varying capacities based on the expected usage of each of the queues. Notice, that the high priority queue has the smallest capacity while the low priority queue has the largest capacity.\nclass Controller declare HIGH as a Queue declare MEDIUM as a Queue declare LOW as a Queue function Controller() HIGH = new Queue(4) MEDIUM = new Queue(6) LOW = new Queue(8) end function Next, we need to define the interface function as defined above. We start with the receiveCar function. There are three cases based on the priority of the car. If we look at the first case for priority == high, we check to see if the high queue is full before calling the enqueue function to place the car into the high queue. If the queue is full, we raise an exception. We follow the exact same logic for the medium and low priority cars as well. Finally, there is a final else that captures the case where the user did not specific either high, medium, or low priority. In this case, an exception is raised.\nfunction receiveCar(CAR, PRIORITY) if PRIORITY == high if HIGH.isFull() raise exception else HIGH.enqueue(CAR) end if else PRIORITY == medium if MEDIUM.isFull() raise exception else MEDIUM.enqueue(CAR) end if else PRIORITY == low if LOW.isFull() raise exception else LOW.enqueue(CAR) end if else raise exception end if end function Now we will define the isEmpty function. While we do not include an isFull function due to the ambiguity of what that would mean and how it might be useful, the isEmpty function will be useful for the windshield station to check before they request another call via the getCar function.\nAs you can see below, the isEmpty function simply returns the logical AND of each of the individual queue’s isEmpty status. Thus, the function will return true if, and only if, each of the high, medium, and low queues are empty.\nfunction isEmpty() return HIGH.isEmpty() and MEDIUM.isEmpty() and LOW.isEmpty() end function Finally, we are able to define the getCar function. It is similar in structure to the receiveCar function in that it checks each queue individually. In the case of getCar, the key to the priority mechanism we are developing is in the order we check the queues. In this case, we check them in the expected order from high to low. If the high queue is not empty, we get the car from that queue and return it to the calling function. If the high queue is empty, then we check the medium queue. Likewise, if the medium queue is empty, we check the low queue. Finally, if all of the queues are empty, we raise an exception.\nfunction getCar() if not HIGH.isEmpty() return HIGH.dequeue() else not MEDIUM.isEmpty() return MEDIUM.dequeue() else not LOW.isEmpty() return LOW.dequeue() else raise exception end if end function ",
    "description": "Queues are useful in many applications. Classic real-world software which uses queues includes the scheduling of tasks, sharing of resources, and processing of messages in the proper order. A common need is to schedule tasks to be executed based on their priority. This type of scheduling can be done in a computer or on an assembly line floor, but the basic concept is the same.\nLet’s assume that we are putting windshields onto new cars in a production line.",
    "tags": [],
    "title": "Using a Queue",
    "uri": "/cc310/8-queues/6-using-a-queue/"
  },
  {
    "breadcrumb": "Stacks",
    "content": " Stacks are useful in many applications. Classic real-world software that uses stacks includes the undo feature in a text editor, or the forward and back features of web browsers. In a text editor, each user action is pushed onto the stack as it is performed. Then, if the user wants to undo an action, the text editor simply pops the stack to get the last action performed, and then undoes the action. The redo command can be implemented as a second stack. In this case, when actions are popped from the stack in order to undo them, they are pushed onto the redo stack.\nMaze Explorer Another example is a maze exploration application. In this application, we are given a maze, a starting location, and an ending location. Our first goal is to find a path from the start location to the end location. Once we’ve arrived at the end location, our goal becomes returning to the start location in the most direct manner.\nWe can do this simply with a stack. We will have to search the maze to find the path from the starting location to the ending location. Each time we take a step forward, we push that move onto a stack. If we run into a dead end, we can simply retrace our steps by popping moves off the list and looking for an alternative path. Once we reach the end state, we will have our path stored in the stack. At this point it becomes easy to follow our path backward by popping each move off the top of the stack and performing it. There is no searching involved.\nWe start with a maze, a startCell, a goalCell, and a stack as shown below. In this case our startCell is 0,0 and our end goal is 1,1. We will store each location on the stack as we move to that location. We will also keep track of the direction we are headed: up, right, down, or left, which we’ll abbreviate as u,r,d,and l.\nIn our first step, we will store our location and direction 0,0,u on the stack.\nFor the second step, we will try to move “up”, or to location 1,0. However, that square in the maze is blocked. So, we change our direction to r as shown below.\nAfter turning right, we attempt to move in that direction to square 0,1, which is successful. Thus, we create a new location 0,1,u and push it on the stack. (Here we always assume we point up when we enter a new square.) The new state of the maze and our stack are shown below.\nNext, we try to move to 1,1, which again is successful. We again push our new location 1,1,u onto the stack. And, since our current location matches our goalCell location (ignoring the direction indicator) we recognize that we have reached our goal.\nOf course, it’s one thing to find our goal cell, but it’s another thing to get back to our starting position. However, we already know the path back given our wise choice of data structures. Since we stored the path in a stack, we can now simply reverse our path and move back to the start cell. All we need to do is pop the top location off of the stack and move to that location over and over again until the stack is empty. The pseudocode for following the path back home is simple.\nloop while !MYSTACK.ISEMPTY() NEXTLOCATION = MYSTACK.POP() MOVETO(NEXTLOCATION) end while ",
    "description": "Stacks are useful in many applications. Classic real-world software that uses stacks includes the undo feature in a text editor, or the forward and back features of web browsers. In a text editor, each user action is pushed onto the stack as it is performed. Then, if the user wants to undo an action, the text editor simply pops the stack to get the last action performed, and then undoes the action.",
    "tags": [],
    "title": "Using a Stack",
    "uri": "/cc310/5-stacks/6-using-a-stack/"
  },
  {
    "breadcrumb": "Python Review",
    "content": " A variable in a programming language is an abstraction that allows storing one value in each instant of time, but this value can change along with the program execution. A variable can be represented as a box holding a value. If the variable is a container, e.g., a list (or array or vector), a matrix, a tuple, or a set of values, each box in the container contains a single value.\nCharacteristics A variable is characterized by:\nAn identifier or name. The name represents the most important information since it allows us to identify the variable inside the program. This name has to be unique inside the program and it allows us to identify the variable. In order to improve program legibility, and facilitate debugging, and understanding it is important to choose a representative name for the variable that clearly represents the function of the variable. Representative names could be results, number_of_nodes, number_of_edges. For writing variable names composed of two or more words in Python we can use underscores to separate the words. A single value, i.e. the value that is stored in the variable. The value of the variable can be modified during program execution but at each instant of time, the variable holds a single value. A data type. The data type characterizes the set of values that the variable can take. For example, the integer type contains numbers without a decimal part. The decimal or floating point type contains numbers with a decimal part. In mathematics, we call these real numbers. The string type (text) characterizes character sequences, and the Boolean type contains true or false values and is used to hold the result of the conditions. In some untyped languages, like Scratch and Python, the data type is deduced from the value that contains the variable. Since the value can change, its type can also change. For example, a variable can contain an integer value at the beginning of the program, a value that is subsequently changed to a real number. In other programming languages, such as Java, the type must be explicitly indicated at the time of declaration and cannot change. A memory address, which is the memory address, in the RAM of the computer, where the value is stored. We won’t work directly with memory addresses in this course, but we may see them when using a visualizer or debugger to execute our programs. Other Features Depending on the programming language, we could also specify for a variable:\nVisibility. An area of visibility or purpose, which is where inside the program the variable is visible. In Python and Java, visibility can be specified at the global level, i.e. visible in all the program, or local, i.e. visible at the individual procedure level. A lifetime. The lifetime of a variable is closely related to its visibility: when the program performs an instruction outside the purpose of the variable, i.e. outside the scope of a variable, the variable itself ends its life. Variable Operations A programming language allows to perform two basic operations with a variable:\nReading the value of a variable. This value can be used in expression allowing to relate variables by means of operators. The basic operators are: Arithmetic operators: such as addition +, and subtraction -. They allow performing basic arithmetic operations with numbers. Comparison operators: such as less than \u003c, and greater than \u003e. Usually, they allow to comparing two operands, each of which could be a variable. The result of the comparison is either the Boolean value true or the Boolean value false. Logic operators: such as and , or, and not. This operator allows us to relate logical conditions together to create more complex statements. String operators: such union or concatenation of strings of characters. For example, we can use the plus symbol + to concatenate the strings “Hello” and the string “world” to produce the string “Hello world”. These operators allow us to manipulate strings. Writing or storing a value inside a variable. This can be performed by an assignment operation such as a = b. Variables in Flowcharts \u0026 Pseudocode The table below lists the flowchart blocks used to represent variables, as well as the corresponding pseudocode:\nOperation Flowchart Pseudocode Declare X = 0 Assign X = 5 Declare \u0026 Assign X = 5 Notice that variables must be assigned a value when declared in pseudocode. By default, most programming languages automatically assign the value $0$ to a new integer variable, so we’ll use that value in our pseudocode as well.\nLikewise, variables in a flowchart are given a type, whereas variables in pseudocode are not. Instead, the data type of those variables can be inferred by the values stored in them.\nVariables in Python Variables in Python are simply defined by giving them a value. The type of the variable in inferred from the data stored in it at any given time, and a variable’s type may change throughout the program as different values are assigned to it.\nTo define a variable, we can simply use an assignment statement to give it a value:\nx = 5 y = 3.5 Casting We can also convert, or cast, data between different types. When we do this, the results may vary a bit due to how computers store and calculate numbers. So, it is always best to fully test any code that casts data between data types to make sure it works as expected.\nTo cast, we can simply use the new type as a function and place the value to be converted in parentheses:\nx = 1.5 y = int(x) This will convert the floating point value stored in x to an integer value stored in y.",
    "description": "A variable in a programming language is an abstraction that allows storing one value in each instant of time, but this value can change along with the program execution. A variable can be represented as a box holding a value. If the variable is a container, e.g., a list (or array or vector), a matrix, a tuple, or a set of values, each box in the container contains a single value.",
    "tags": [],
    "title": "Variables",
    "uri": "/cc310/01-review/06-variables/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome! This page is the main page for Searching and Sorting",
    "description": "Welcome! This page is the main page for Searching and Sorting",
    "tags": [],
    "title": "Searching and Sorting",
    "uri": "/cc310/7-searching-and-sorting/"
  },
  {
    "breadcrumb": "Performance",
    "content": " We can examine the performance of the algorithms we use in a similar manner. Once again, we are concerned with both the memory usage and processing time of the algorithm. In this case, we are concerned with the amount of memory required to perform the algorithm that is above and beyond the memory used to store the data in the first place.\nWhen analyzing searching and sorting algorithms, we’ll assume that we are using arrays as our data structure, since they give us the best performance for accessing and swapping random elements quickly.\nSearching There are two basic searching algorithms: linear search and binary search.\nFor linear search, we are simply iterating through the entire data structure until we find the desired item. So, while we can stop looking as soon as it is found, in the worst case we will have to look at all the elements in the structure, meaning the algorithm runs in order $N$ time.\nBinary search, on the other hand, takes advantage of a sorted array to jump around quickly. In effect, each element we analyze allows us to eliminate half of the remaining elements in our search. With as few as 8 steps, we can search through an array that contains 64 elements. When we analyze this algorithm, we find that it runs in order $\\text{lg}(N)$ time, which is a vast improvement over binary search.\nOf course, this only works when we can directly access elements in the middle of our data structure. So, while a linked list gives us several performance improvements over an array, we cannot use binary search effectively on a linked list.\nIn terms of memory usage, since both linear search and binary search just rely on the original data structures for storing the data, the extra memory usage is constant and consists of just a couple of extra variables, regardless of how many elements are in the data structure.\nSorting We have already discussed how much of an improvement binary search is over a linear search. In fact, our analysis showed that performing as few as 7 or 8 linear searches will take more time than sorting the array and using binary search. Therefore, in many cases we may want to sort our data. There are several different algorithms we can use to sort our data, but in this course we explored four of them: selection sort, bubble sort, merge sort, and quicksort.\nThe selection sort algorithm involves finding the smallest or largest value in an array, then moving that value to the appropriate end, and repeating the process until the entire array is sorted. Each time we iterate through the array, we look at every remaining element. In the module on sorting, we showed (through some clever mathematical analysis) that this algorithm runs in the order of $N^2$ time.\nBubble sort is similar, but instead of finding the smallest or largest element in each iteration, it focuses on just swapping elements that are out of order, and eventually (through repeated iterations) sorting the entire array. While doing so, the largest or smallest elements appear to “bubble” to the appropriate end of the array, which gives the algorithm its name. Once again, because the bubble sort algorithm repeatedly iterates through the entire data structure, it also runs on the order of $N^2$ time.\nBoth selection sort and bubble sort are inefficient as sorting algorithms go, yet their main value is their simplicity. They are also very nice in that they do not require any additional memory usage to run. They are easy to implement and understand and make a good academic example when learning about algorithms. While they are not used often in practice, later in this module we will discuss a couple of situations where we may consider them useful.\nMerge sort is a very powerful divide and conquer algorithm, which splits the array to be sorted into progressively smaller parts until each one contains just one or two elements. Then, once those smaller parts are sorted, it slowly merges them back together until the entire array is sorted. We must look at each element in the array at least once per “level” of the algorithm in the diagram above, so overall this algorithm runs in the order of $N * \\text{lg}(N)$ time. This is quite a bit faster than selection sort and bubble sort. However, most implementations of merge sort require at least a second array for storing data as it is merged together, so the additional memory usage is also on the order of $N$.\nQuicksort is a very clever algorithm, which involves selecting a “pivot” element from the data, and then dividing the data into two halves, one containing all elements less than the pivot, and another with all items greater than the pivot. Then, the process repeats on each half until the entire structure is sorted. In the ideal scenario, shown in the diagram above, quicksort runs on the order of $N * \\text{lg}(N)$ time, similar to merge sort. However, this depends on the choice of the pivot element being close to the median element of the structure, which we cannot always guarantee. Thankfully, in practice, we can just choose a random element (such as the last element in the structure) and we’ll see performance that is close to the $N * \\text{lg}(N)$ target.\nHowever, if we choose our pivot element poorly, the worst case scenario shown in the diagram above can occur, causing the run time to be on the order of $N^2$ instead. This means that quicksort has a troublesome, but rare, worst case performance scenario.",
    "description": "We can examine the performance of the algorithms we use in a similar manner. Once again, we are concerned with both the memory usage and processing time of the algorithm. In this case, we are concerned with the amount of memory required to perform the algorithm that is above and beyond the memory used to store the data in the first place.\nWhen analyzing searching and sorting algorithms, we’ll assume that we are using arrays as our data structure, since they give us the best performance for accessing and swapping random elements quickly.",
    "tags": [],
    "title": "Algorithms",
    "uri": "/cc310/12-performance/7-algorithms/"
  },
  {
    "breadcrumb": "Python Review",
    "content": " The conditional statement, also known as the If-Then statement, is used to control the program’s flow by checking the value of a Boolean statement and determining if a block of code should be executed based on that value. This is the simplest conditional instruction. If the condition is true, the block enclosed within the statement is executed. If it is false, then the code in the block is skipped.\nA more advanced conditional statement, the If-Then-Else or If-Else statement, includes two blocks. The first block will be executed if the Boolean statement is true. If the Boolean statement is false, then the second block of code will be executed instead.\nSimple conditions are obtained by means of the relational operators, such as \u003c, \u003e, and ==, which allow you to compare two elements, such as two numbers, or a variable and a number, or two variables. Compound conditions are obtained by composing two or more simple conditions through the logical operators and, or, and not.\nBoolean Logic Review Recall that the Boolean logic operators and, or, and not can be used to construct more complex Boolean logic statements.\nOr For example, consider the statement x \u003c= 5. This could be broken down into two statements, combined by the or operation: x \u003c 5 or x == 5. The table below, called a truth table, gives the result of the or operation based on the values of the two operands:\nOperand 1 Operand 2 Operand 1 or Operand 2 False False False False True True True False True True True True As shown above, the result of the or operation is True if at least one of the operands is True.\nAnd Likewise, to express the mathematical condition 3 \u003c a \u003c 5 we can use the logical operator and by dividing the mathematical condition into two logical conditions: a \u003e 3 and a \u003c 5. The table below gives the result of the and operation based on the values of the two operands:\nOperand 1 Operand 2 Operand 1 or Operand 2 False False False False True False True False False True True True As shown above, the result of the and operation is True if both of the operands are True.\nNot Finally, the not logical operator is used to reverse, or invert, the value of a Boolean statement. For example, we can express the logical statement x \u003c 3 as not (x \u003e= 3), using the not operator to invert the value of the statement. The table below gives the result of the not operation based on the value of its operand:\nOperand not Operand False True True False In propositional logic, the completeness theorem shows that all other logical operators can be obtained by appropriately combining the and, or and not operators. So, by just understanding these three operators, we can construct any other Boolean logic statement.\nConditionals in Flowcharts \u0026 Pseudocode The table below lists the flowchart blocks used to represent conditional statements, as well as the corresponding pseudocode:\nOperation Flowchart Pseudocode If-Then if A \u003c 5 then\nA = 5\nend if If-Then-Else if A \u003c 5 then\nA = 5\nelse\nA = 10\nend if Conditionals in Practice The mechanism for determining which block an If-Then-Else statement executes is the following:\nIf the initial condition is true, execute the instructions enclosed between if and else If the initial condition is false, execute the instructions between the else and the end of the block To understand how a conditional statement works, let’s look at this example of a simple If-Then-Else statement. Consider the following flowchart:\nIn this case, if a is less than zero, the output message will be “The value of a is less than zero”. Otherwise, if a is not less than zero (that is, if a is greater than or equal to zero), the output message will be “The value of a is greater than or equal to zero”.\nNesting We can also nest conditional statements together, making more complex programs.\nConsider the following flowchart:\nIn this case, if a is less than zero the output message will be “The value of a is less than zero”. Otherwise (that is, if a is not less than zero so if a is greater than or equal to zero) the block checks whether a is equal to zero; if so, the output message will be “The value of a is equal to zero”. Otherwise (that is, if the first condition is false, i.e. a \u003e= 0 and the second condition is false, i.e. is nonzero; the two conditions must be both true as if they were bound by a logical and, and they are the same as the condition a \u003e 0) the output message will be “The value of a is greater than zero”.\nConditionals in Python To see how conditional statements look in Python, let’s recreate them from the flowcharts shown above.\nif a \u003c 5: a = 5 if a \u003c 5: a = 5 else: a = 10 if a \u003c 0: print(\"The value of a is less than zero\") elif a == 0: print(\"The value of a is equal to zero\") else: print(\"The value of a is greater than zero\") As we can see in the examples above, we must carefully indent each block of code to help set it apart from the other parts of the program. In addition, each line containing if, elif and else must end in a colon :.",
    "description": "The conditional statement, also known as the If-Then statement, is used to control the program’s flow by checking the value of a Boolean statement and determining if a block of code should be executed based on that value. This is the simplest conditional instruction. If the condition is true, the block enclosed within the statement is executed. If it is false, then the code in the block is skipped.",
    "tags": [],
    "title": "Conditionals",
    "uri": "/cc310/01-review/07-conditionals/"
  },
  {
    "breadcrumb": "Recursion",
    "content": "There are some problems where an iterative solution is difficult to implement and is not always immediately intuitive, while a recursive solution is simple, concise and easy to understand. A classic example is the problem of the Tower of Hanoi.\nThe Tower of Hanoi is a game that lends itself to a recursive solution. Suppose we have three towers on which we can put discs. The three towers are indicated by a letter, A, B, or C.\nNow, suppose we have $N$ discs all of different sizes. The discs are stacked on tower A based on their size, smaller discs on top. The problem is to move all the discs from one tower to another by observing the following rules:\nwe can move only one disc at a time, and we must move the disc that is at the top of a tower first, and a larger disc can never be put on top of a smaller disc. To try to solve the problem let’s start by considering a simple case: we want to move two discs from tower A to tower C. As a convenience, suppose we number the discs in ascending order by assigning the number 1 to the larger disc. The solution in this case is simple and consists of the following steps:\nmove disc 2 from tower A to tower B, move disc 1 from tower A to tower C, and move disc 2 from Tower B to tower C. The following figure shows how the algorithm works.\nIt is a little more difficult with three discs, but after a few tries the proper algorithm emerges. With our knowledge of recursion, we can come up with a simple and concise solution. Since we already know how to move two discs from one place to another, we can solve the problem recursively.\nMove discs 3 and 2 from tower A to B. Move disc 1 from tower A to C. Move discs 3 and 2 from tower B to C. In formulating our solution, we assumed that we could move two discs from one tower to another, since we have already solved that part of the problem above. In step 1, we use this solution to move the top two discs from tower A to B. Then, in step 3, we again use that solution to move two discs from tower B to C. This process can now easily be generalized to the case of N discs as described below.\nMove the first N-1 discs from tower A to B. Move disc 1 from tower A to C. Move N -1 discs from tower B to C. The algorithm is captured in the following pseudocode. Here N is the total number of discs, ORIGIN is the tower where the discs are currently located, and DESTINATION is the tower where they need to be moved. Finally, TEMP is a temporary tower we can use to help with the move. All the parameters are integers.\nfunction HANOI(N, ORIGIN, DESTINATION, TEMP) if N \u003e= 0 HANOI(N-1, ORIGIN, TEMP, DESTINATION) Move disc N from ORIGIN to DESTINATION HANOI(N-1, TEMP, DESTINATION, ORIGIN) end if return end functionThe function moves the $N$ discs from the source tower to the destination tower using a temporary tower. To do this, it calls itself to move the first $N-1$ discs from the source tower to the temporary tower. It then moves the bottom disc from the source tower to the destination tower. The function then moves the $N-1$ discs present in the temporary tower into the destination tower.\nThe list of movements to solve the three-disc problem is shown below.\nmove disc 3 from ORIGIN to DESTINATION move disc 2 from ORIGIN to TEMP move disc 3 from DESTINATION to TEMP move disc 1 from ORIGIN to DESTINATION move disc 3 from TEMP to ORIGIN move disc 2 from TEMP to DESTINATION Iterative solutions to the Tower of Hanoi problem do exist, but it took many researchers several years to find an efficient solution. The simplicity of finding the recursive solution presented here should convince you that recursion is an approach you should definitely keep in your bag of tricks!",
    "description": "There are some problems where an iterative solution is difficult to implement and is not always immediately intuitive, while a recursive solution is simple, concise and easy to understand. A classic example is the problem of the Tower of Hanoi.\nThe Tower of Hanoi is a game that lends itself to a recursive solution. Suppose we have three towers on which we can put discs. The three towers are indicated by a letter, A, B, or C.",
    "tags": [],
    "title": "Example: Tower of Hanoi",
    "uri": "/cc310/6-recursion/7-example--tower-of-hanoi/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " In Python, we can break our programs up into individual functions, which are individual routines that we can call in our code. Let’s review how to create functions in Python.\nFunctions in Flowcharts \u0026 Pseudocode The table below lists the flowchart blocks used to represent functions, as well as the corresponding pseudocode:\nOperation Flowchart Pseudocode Declare Function function FOO(X)\nX = X + 5\nreturn X\nend function Call Function X = FOO(5) Functions in Python Declaring Functions In general, a function definition in Python needs a few elements. Let’s start at the simplest case:\ndef foo(): print(\"Foo\") return Let’s break this example function definition down to see how it works:\nFirst, we use the keyword def at the beginning of this function definition. That keyword tells Python that we’d like to define a new function. We’ll need to include it at the beginning of each function definition. Next, we have the name of the function, foo. We can name a function using any valid identifier in Python. In general, function names in Python always start with a lowercase letter, and use underscores between the words in the function name if it contains multiple words. Following the function name, we see a set of parentheses () that list the parameters for this function. Since there is nothing included in this example, the function foo does not require any parameters. Finally, we see a colon : indicating that the indented block of code below this definition is contained within the function. In this case, the function will simply print Foo to the terminal. The function ends with the return keyword. Since we aren’t returning a value, we aren’t required to include a return keyword in the function. However, it is helpful to know that we may use that keyword to exit the function at any time. Once that function is created, we can call it using the following code:\nfoo() Parameters and Return In a more complex case, we can declare a function that accepts parameters and returns a value, as in this example:\ndef count_letters(input, letter): output = 0 for i in range(0, len(input)): if input[i] == letter: output += 1 return output In this example, the function accepts two parameters: input, which could be a string, and letter, which could be a single character. However, since Python does not enforce a type on these parameters, they could actually be any value. We could add additional code to this function that checks the type of each parameter and raises a TypeError if they are not the expected type.\nWe can use the parameters just like any other variable in our code. To return a value, we use the return keyword, followed by the value or variable containing the value we’d like to return.\nTo call a function that requires parameters, we can include values as arguments in the parentheses of the function call:\nsum += count_letters(\"The quick brown fox jumped over the lazy dog\", \"e\") ",
    "description": "In Python, we can break our programs up into individual functions, which are individual routines that we can call in our code. Let’s review how to create functions in Python.\nFunctions in Flowcharts \u0026 Pseudocode The table below lists the flowchart blocks used to represent functions, as well as the corresponding pseudocode:\nOperation Flowchart Pseudocode Declare Function function FOO(X)\nX = X + 5\nreturn X\nend function Call Function X = FOO(5) Functions in Python Declaring Functions In general, a function definition in Python needs a few elements.",
    "tags": [],
    "title": "Functions",
    "uri": "/cc310/02-oop-review/07-functions/"
  },
  {
    "breadcrumb": "Hash Tables",
    "content": "In this module, we introduced the concept of a hash table, which is a data structure that provides efficient insertion and retrieval operations. We introduced the three essential elements of hash tables:\nAn array that holds buckets where key-value pairs are stored, A hash function that maps a key to a specific array index, and A set of buckets that allow the hash table to store multiple key-value pairs whose keys map to the same index in the array. We then discussed how to implement a hash table class. In our implementation, we chose to use built-in, language-specific hash code functions to generate the indexes into our array. We also used doubly linked lists to implement our buckets as linked lists are very flexible and provide constant time insertion operations. To demonstrate the effectiveness of hash tables, we re-implemented our set class using hash tables instead of linked lists. In many ways, the re-implementation was almost identical to the linked list implementation since many of the operations found in hash tables are almost identical to those found in linked lists. We also noted that the biggest advantage of implementing sets with hash tables is the (almost!) constant time retrieval operations provided by hash tables.",
    "description": "In this module, we introduced the concept of a hash table, which is a data structure that provides efficient insertion and retrieval operations. We introduced the three essential elements of hash tables:\nAn array that holds buckets where key-value pairs are stored, A hash function that maps a key to a specific array index, and A set of buckets that allow the hash table to store multiple key-value pairs whose keys map to the same index in the array.",
    "tags": [],
    "title": "Hash Tables Summary",
    "uri": "/cc310/11-hash-tables/7-hash-tables-summary/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "We’ve examined many different versions of a linear search algorithm. We can find the first occurrence of a number in an array, the last occurrence of that number, or a value with a particular property, such as the minimum value. Each of these are examples of a linear search, since we look at each element in the container sequentially until we find what we are looking for.\nSo, what would be the time complexity of this process? To understand that, we must consider what the worst-case input would be. For this discussion, we’ll just look at the find function, but the results are similar for many other forms of linear search. The pseudocode for find is included below for reference.\nfunction FIND(NUMBER, ARRAY)\t(1) loop INDEX from 0 to size of ARRAY - 1 (2) if ARRAY[INDEX] == NUMBER\t(3) return INDEX\t(4) end if\t(5) end for\t(6) return -1\t(7) end function\t(8)How would we determine what the worst-case input for this function would be? In this case, we want to come up with the input that would require the most steps to find the answer, regardless of the size of the container. Obviously, it would take more steps to find a value in a larger container, but that doesn’t really tell us what the worst-case input would be.\nTherefore, the time complexity for a linear search algorithm is clearly proportional to the number of items that we need to search through, in this case the size of our array. Whether we use an iterative algorithm or a recursive algorithm, we still need to search the array one item at a time. We’ll refer to the size of the array as $N$.\nHere’s the key: when searching for minimum or maximum values, the search will always take exactly $N$ comparisons since we have to check each value. However, if we are searching for a specific value, the actual number of comparisons required may be fewer than $N$.\nTo build a worst-case input for the find function, we would search for the situation where the value to find is either the last value in the array, or it is not present at all. For example, consider the array we’ve been using to explore each linear search algorithm so far.\nWhat if we are trying to find the value 55 in this array? In that case, we’ll end up looking at 4 of the 8 elements in the array. This would take $N/2$ steps. Can we think of another input that would be worse?\nConsider the case where we try to find 0 instead. Will that be worse? In that case, we’ll need to look at all 8 elements in the array before we find it. That requires $N$ steps!\nWhat if we are asked to find 1 in the array? Since 1 is not in the array, we’ll have to look at every single element before we know that it can’t be found. Once again, that requires $N$ steps.\nWe could say that in the worst-case, a linear search algorithm requires “on the order of $N$” time to find an answer. Put another way, if we double the size of the array, we would also need to double the expected number of steps required to find an item in the worst case. We sometimes call this linear time, since the number of steps required grows at the same rate as the size of the input.\nCan We Do Better? Our question now becomes, “Is a search that takes on the order of $N$ time really all that bad?”. Actually, it depends. Obviously, if $N$ is a small number (less than 1000 or so) it may not be a big deal, if you only do a single search. However, what if we need to do many searches? Is there something we can do to make the process of searching for elements even easier?\n^[File:FileStack retouched.jpg. (2019, January 17). Wikimedia Commons, the free media repository. Retrieved 22:12, March 23, 2020 from https://commons.wikimedia.org/w/index.php?title=File:FileStack_retouched.jpg\u0026oldid=335159723.]\nLet’s consider the real world once again for some insights. For example, think of a pile of loose papers on the floor. If we wanted to find a specific paper, how would we do it?\nIn most cases, we would simply have to perform a linear search, picking up each paper one at a time and seeing if it is the one we need. This is pretty inefficient, especially if the pile of papers is large.\n^[File:Istituto agronomico per l’oltremare, int., biblioteca, schedario 05.JPG. (2016, May 1). Wikimedia Commons, the free media repository. Retrieved 22:11, March 23, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Istituto_agronomico_per_l%27oltremare,_int.,_biblioteca,_schedario_05.JPG\u0026oldid=194959053.]\nWhat if we stored the papers in a filing cabinet and organized them somehow? For example, could we sort the papers by title in alphabetical order? Then, when we want to find a particular paper, we can just skip to the section that contains files with the desired first letter and go from there. In fact, we could even do this for the second and third letter, continuing to jump forward in the filing cabinet until we found the paper we need.\nThis seems like a much more efficient way to go about searching for things. In fact, we do this naturally without even realizing it. Most computers have a way to sort files alphabetically when viewing the file system, and anyone who has a collection of items has probably spent time organizing and alphabetizing the collection to make it easier to find specific items.\nTherefore, if we can come up with a way to organize the elements in our array, we may be able to make the process of finding a particular item much more efficient. In the next section, we’ll look at how we can use various sorting algorithms to do just that.",
    "description": "We’ve examined many different versions of a linear search algorithm. We can find the first occurrence of a number in an array, the last occurrence of that number, or a value with a particular property, such as the minimum value. Each of these are examples of a linear search, since we look at each element in the container sequentially until we find what we are looking for.\nSo, what would be the time complexity of this process?",
    "tags": [],
    "title": "Linear Search Time Complexity",
    "uri": "/cc310/7-searching-and-sorting/7-linear-search-time-complexity/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": " 1\nThe other type of data structure we can use in our programs is the non-linear data structure.\nBroadly speaking, non-linear data structures allow us to store data across multiple dimensions, and there may be multiple paths through the data to get from one item to another. In fact, much of the information stored in the data structure has to do with the paths between elements more than the elements themselves.\nNon-Linear Data Structure Hierarchy Just like linear data structures, there are several different types of non-linear data structures. In this case, each one is a more specialized version of the previous one, hence the hierarchy shown above. On the next few pages, we’ll explore each one just a bit to see what they look like.\nFile:6n-graf.svg. (2020, January 12). Wikimedia Commons, the free media repository. Retrieved 02:53, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:6n-graf.svg\u0026oldid=386942400. ↩︎",
    "description": "1\nThe other type of data structure we can use in our programs is the non-linear data structure.\nBroadly speaking, non-linear data structures allow us to store data across multiple dimensions, and there may be multiple paths through the data to get from one item to another. In fact, much of the information stored in the data structure has to do with the paths between elements more than the elements themselves.",
    "tags": [],
    "title": "Non-Linear Structures",
    "uri": "/cc310/03-intro-dsa/07-non-linear/"
  },
  {
    "breadcrumb": "Stacks",
    "content": " The pseudocode for finding the initial path using the stack is shown below. We assume the enclosing class has already defined a stack called myStack and the datatype called Cell, which represents the squares in the maze. The algorithm also uses three helper functions as described below:\ngetNextCell(maze, topCell): computes the next cell based on our current cell’s location and direction; incrementDirection(topCell): increments a cell’s direction attribute following the clockwise sequence of up, right, down, left, and then finally done, which means that we’ve tried all directions; and valid(nextCell): determines if a cell is valid. A cell is invalid if it is “blocked”, is outside the boundaries of the maze, or is in the current path (i.e., if it exists in the stack). The parameters of findPath are a 2-dimensional array called maze, the startCell and the endCell. The algorithm begins by pushing the startCell onto myStack. The cell at the top of the stack will always represent our current cell, while the remaining cells in the stack represent the path of cells taken to reach the current cell.\nNext, we enter a loop, where we will do the bulk of the work. We peek at the cell on the top of the stack in order to use it in our computations. If the topCell is equal to our goalCell, then we are done and return true indicating that we have found a path to the goal.\nIf we are not at our goal, we check to see if we have searched all directions from the current cell. If that is the case, then the direction attribute of the topCell will have been set to done. If the direction attribute of topCell is equal to done, then we pop the topCell of the stack, effectively leaving that cell and returning to the next cell in the stack. This is an algorithmic technique called backtracking.\nfunction FINDPATH(MAZE, STARTCELL, GOALCELL) MYSTACK.PUSH(STARTCELL); loop while !MYSTACK.ISEMPTY() TOPCELL = MYSTACK.PEEK() if TOPCELL equals GOALCELL return true if TOPCELL.GETDIRECTION() = done then MYSTACK.POP() else NEXTCELL = GETNEXTCELL(MAZE, TOPCELL) INCREMENTDIRECTION(TOPCELL)\tif VALID(MAZE, NEXTCELL) then if MYSTACK.ISFULL() then MYSTACK.DOUBLECAPACITY(); end if MYSTACK.PUSH(NEXTCELL) end if end if end while return false end functionHowever, if we have not searched in all directions from topCell, we will try to explore a new cell (nextCell) adjacent to the topCell. Specifically, nextCell will be the adjacent cell in the direction stored by the direction attribute. We then increment the direction attribute of the topCell so if we end up backtracking, we will know which direction to try next.\nBefore we push the nextCell onto the stack, we must first check to see if it’s a valid cell by calling the helper function valid. A cell is valid if it is open to be explored. A cell is invalid if it is “blocked,” is outside the boundaries of the maze, or is in the current path (i.e., if it exists in the stack). To help us determine if a cell is in the stack, we will need to extend our stack operations to include a find operation that searches the stack while leaving its contents intact. You will get to implement this operation in your project.\nIf nextCell is valid, we then check to make sure that the stack is not already full. If it is, we simply call doubleCapacity and continue on our way. Then we push nextCell onto myStack so it will become our next topCell on the next pass through the loop.\nAfter we have explored all possible paths through the maze, the loop will eventually end, and the operation will return false indicating no path was found. While this is not the most efficient path finding algorithm, it is a good example of using stacks for backtracking. Also, if we do find a path and return, the path will be saved in the stack. We can then use the previous pseudocode for retracing our steps and going back to the startCell.",
    "description": "The pseudocode for finding the initial path using the stack is shown below. We assume the enclosing class has already defined a stack called myStack and the datatype called Cell, which represents the squares in the maze. The algorithm also uses three helper functions as described below:\ngetNextCell(maze, topCell): computes the next cell based on our current cell’s location and direction; incrementDirection(topCell): increments a cell’s direction attribute following the clockwise sequence of up, right, down, left, and then finally done, which means that we’ve tried all directions; and valid(nextCell): determines if a cell is valid.",
    "tags": [],
    "title": "Path Finding Algorithm",
    "uri": "/cc310/5-stacks/7-path-finding-algorithm/"
  },
  {
    "breadcrumb": "Programming by Contract and Introduction to Performance",
    "content": "The performance of our algorithms is very important, since the difference between good algorithms and bad algorithms on very large data sets can often be measured in terms of days of execution time. Thus, efficiency will be one of the key issues we will look at when designing algorithms.\nFor example, one simple problem involves finding the largest sum of contiguous elements in an array. So, if we have the array:\n[−2, 1, −3, 4, −1, 2, 1, −5, 4]we could find that the contiguous sequence of:\n[4, −1, 2, 1]sums to $6$, which is the largest sum of any contiguous subsequences of this array.\nA simple solution to this problem might involve finding all possible subsequences of the array and adding them, which could take a very long time. In fact, if the array contains $n$ elements, it might take $n^3$ steps to solve it. However, with a little ingenuity, we can actually solve this problem using many fewer steps, even as few as $n$ steps itself.\nWhen we try to solve a problem, it is often helpful to look at multiple solutions to the problem and compare them before choosing our final design. Just the act of trying to find multiple ways to solve the same problem stimulates creativity and promotes mental elasticity and speed of thought. Selecting a solution from several different choices following rigorous and objective criteria enables us to improve fundamental life skills such as simply knowing how to make decisions! In fact, the very attempt at solving a problem in a variety of ways forces us to look our problems from different perspectives, which is the catalyst of all scientific discoveries.\nThroughout this section, we will develop two solutions to the problem of finding the maximum max and minimum min of a list of N numbers (defined as list[N]) as an example. We will develop both solutions and then evaluate their performances in terms of both execution time and memory space.",
    "description": "The performance of our algorithms is very important, since the difference between good algorithms and bad algorithms on very large data sets can often be measured in terms of days of execution time. Thus, efficiency will be one of the key issues we will look at when designing algorithms.\nFor example, one simple problem involves finding the largest sum of contiguous elements in an array. So, if we have the array:",
    "tags": [],
    "title": "Performance of Algorithms",
    "uri": "/cc310/3-programming-by-contract-and-introduction-to-performance/7-performance-of-algorithms/"
  },
  {
    "breadcrumb": "Lists",
    "content": "isEmpty The list isEmpty operation is rather straightforward. We simply need to return the truth of whether head.next has a null pointer. Obviously, isEmpty runs in constant time.\nfunction isEmpty() returns boolean return head == NULL (1) end functionpeek The peek operation is designed to return the data from the last node inserted into the list, which is the node pointed at by head. This is easy to do; however, we must ensure that we check to see if the list is empty in line 1 before we return the head.data in line 3. Due to its simple structure, the run time of the peek operation is constant.\nfunction peek() returns data if isEmpty()\t(1) raise exception\t(2) end if return head.data\t(3) end functionpeekEnd The peekEnd operation is designed to return the first node inserted into the list, which is now the last node in the list. Like the peek operation, we must ensure the list is not empty in line 1 before actually searching for the end of the list. Lines 3 – 5 walk through the list using a while statement until curr.next is null, signifying that curr is pointing at the last node in the queue. Finally, line 6 simply returns the data in the last node. Since peekEnd must walk through the entire list to find the last node, it runs in order $N$ time.\nfunction peekEnd() returns data if isEmpty()\t(1) raise exception\t(2) end if curr = head (3) while curr.next != null\t(4) curr = curr.next\t(5) end while return curr.data\t(6) end function",
    "description": "isEmpty The list isEmpty operation is rather straightforward. We simply need to return the truth of whether head.next has a null pointer. Obviously, isEmpty runs in constant time.\nfunction isEmpty() returns boolean return head == NULL (1) end functionpeek The peek operation is designed to return the data from the last node inserted into the list, which is the node pointed at by head. This is easy to do; however, we must ensure that we check to see if the list is empty in line 1 before we return the head.",
    "tags": [],
    "title": "Singly Linked Lists - Other Operations",
    "uri": "/cc310/9-lists/7-singly-linked-lists---other-operations/"
  },
  {
    "breadcrumb": "Queues",
    "content": "The following example shows how the Controller class would work, given specific calls to receiveCar and getCar.\nStep Operation Effect 1 Constructor Creates 3 priority queues. 2 getCar() Raises an exception since all three queues will be empty. 3 receiveCar(a, low) Places car a into the low queue. 4 receiveCar(b, low) Places car b into the low queue. 5 receiveCar(f, high) Places car f into the high queue. 6 receiveCar(d, medium) Places car d into the medium queue. 7 receiveCar(g, high) Raises an exception since the high queue is already full. 8 receiveCar(e, medium) Places car e into the medium queue. 9 getCar() Returns car f from the high queue. 10 getCar() Returns car d from the medium queue. 11 getCar() Returns car e from the medium queue. 12 getCar() Returns car a from the low queue. 13 getCar() Returns car b from the low queue. 14 getCar() Raises an exception since there are no more cars available in any of the three queues. 15 isEmpty() Returns true since all three queues are empty. ",
    "description": "The following example shows how the Controller class would work, given specific calls to receiveCar and getCar.\nStep Operation Effect 1 Constructor Creates 3 priority queues. 2 getCar() Raises an exception since all three queues will be empty. 3 receiveCar(a, low) Places car a into the low queue. 4 receiveCar(b, low) Places car b into the low queue. 5 receiveCar(f, high) Places car f into the high queue. 6 receiveCar(d, medium) Places car d into the medium queue.",
    "tags": [],
    "title": "Windshield Station Example",
    "uri": "/cc310/8-queues/7-windshield-station-example/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome! This page is the main page for Queues",
    "description": "Welcome! This page is the main page for Queues",
    "tags": [],
    "title": "Queues",
    "uri": "/cc310/8-queues/"
  },
  {
    "breadcrumb": "Performance",
    "content": "There are many different algorithms we can use to sort our data, and some of them can be shown mathematically to be more efficient, even in the worst case. So, how should we choose which algorithm to use?\nIn practice, it really comes down to a variety of factors, based on the amount of data we expect our program to handle, the randomness of the data, and more. The only way to truly know which algorithm is the best is to empirically test all of them and choose the fastest one, but even that approach relies on us predicting the data that our program will be utilizing.\nInstead, here are some general guidelines we can use to help us select a sorting algorithm to use in our program.\nIf we know that the data will be nearly sorted, with only a few elements out of place, we can use bubble sort to quickly fix those issues. Unlike many other sorting algorithms, it is very easy to modify the bubble sort code to terminate when the data is properly sorted after just a few iterations. While it is rare to find a data set that is nearly sorted, it is an interesting case to be aware of. If we think our data will be truly random, or if we are not sure we have enough memory to store the data twice, we can use quicksort effectively. Since the data is random, we should avoid the worst case scenario that can happen when using quicksort. In most cases quicksort is one of the fastest sorting algorithms when used on real-world data. In addition, quicksort does not have any additional memory requirements, so it can be used in place without creating a copy of the data. If we are not sure what features our data will have, but we know we’ll have enough memory to store the data twice, then merge sort is a good choice. Merge sort guarantees that the performance will be on the order of N lg(N) regardless of how the data is structured, but it typically requires more memory usage. Interestingly, if we are dealing with a large set of data that will not fit in memory itself, merge sort is also a good choice. Merge sort was originally designed for sorting data stored on multiple removable disks or tapes. Each disk was sorted individually, and then two disks could be merged in sorted order on two more disks. Over time, the entire data set could be sorted by using just a few extra disks, even if it could not all be loaded into the computer at the same time. Of course, the choice of which sorting algorithm to use is one of the most important decisions a programmer can make, and it is a great example of the fact that there are multiple ways to write a program that performs a particular task. Each possible program comes with various performance and memory considerations, and in many cases, there may not be a correct option. Instead, we must rely on our own knowledge and insight to choose the method that we feel would work best in any given situation.",
    "description": "There are many different algorithms we can use to sort our data, and some of them can be shown mathematically to be more efficient, even in the worst case. So, how should we choose which algorithm to use?\nIn practice, it really comes down to a variety of factors, based on the amount of data we expect our program to handle, the randomness of the data, and more. The only way to truly know which algorithm is the best is to empirically test all of them and choose the fastest one, but even that approach relies on us predicting the data that our program will be utilizing.",
    "tags": [],
    "title": "Choosing an Algorithm",
    "uri": "/cc310/12-performance/8-choosing-an-algorithm/"
  },
  {
    "breadcrumb": "Recursion",
    "content": "Iteration and recursion have the same expressive power, which means that any problem that has a recursive solution also has an iterative solution and vice versa. There are also standard techniques that allow you to transform a recursive program into an equivalent iterative version. The simplest case is for tail recursion, where the recursive call is the last step in the function. There are two cases of tail recursion to consider when converting to an iterative version.\nIf the recursive function does not have any parameters or the parameters are passed by reference, the conversion is very simple. We just use a simple while loop. If the recursive function uses parameters passed by value, the conversion is a little more complicated. In general, if the last statement a function f(x) executes is a call to itself, f(y) with parameter y, the recursive call can be replaced by an assignment statement, x = y, and by looping back to the beginning of function f. The approach above only solves the conversion problem in the case of tail recursion. However, as an example, consider our original FACT function and its iterative version FACT2. Notice that in FACT2 we had to add a variable fact to keep track of the actual computation.\nfunction FACT(N) if N == 1 return 1 else return N * FACT(N-1) end if end functionfunction FACT2(N) fact = 1 while N \u003e 0 fact = fact * N N = N - 1 end while return fact end functionThe conversion of non-tail recursive functions typically uses two loops to iterate through the process, effectively replacing recursive calls. The first loop executes statements before the original recursive call, while the second loop executes the statements after the original recursive call. The process also requires that we use a stack to save the parameter and local variable values each time through the loop. Within the first loop, all the statements that precede the recursive call are executed, and then, before the loop terminates, the values of interest are pushed onto the stack. The second loop starts by popping the values saved on the stack and then executing the remaining statements that come after the original recursive call. This is typically much more difficult than the conversion process for tail recursion.",
    "description": "Iteration and recursion have the same expressive power, which means that any problem that has a recursive solution also has an iterative solution and vice versa. There are also standard techniques that allow you to transform a recursive program into an equivalent iterative version. The simplest case is for tail recursion, where the recursive call is the last step in the function. There are two cases of tail recursion to consider when converting to an iterative version.",
    "tags": [],
    "title": "Converting Recursion to Iteration",
    "uri": "/cc310/6-recursion/8-converting-recursion-to-iteration/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": " 1\nThe most general version of a non-linear data structure is the graph, as shown in the diagram above. A graph is a set of nodes that contain data, as well as a set of edges that link two nodes together. Edges themselves may also contain data.\nGraphs are great for storing and visualizing not just data, but also the relationships between data. For example, each node in the graph could represent a city on the map, with the edges representing the travel time between the two cities. Or we could use the nodes in a graph to represent the people in a social network, and the edges represent connections or friendships between two people. There are many possibilities!\nWhen to Use a Graph Graphs are a great choice when we need to store data and relationships between the data, but we aren’t sure exactly what structures or limitations are present in the data. Since a graph is the most general and flexible non-linear data type, it has the most ability to represent data in a wide variety of ways.\nFile:Directed acyclic graph 2.svg. (2016, May 3). Wikimedia Commons, the free media repository. Retrieved 03:05, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Directed_acyclic_graph_2.svg\u0026oldid=195167720. ↩︎",
    "description": "1\nThe most general version of a non-linear data structure is the graph, as shown in the diagram above. A graph is a set of nodes that contain data, as well as a set of edges that link two nodes together. Edges themselves may also contain data.\nGraphs are great for storing and visualizing not just data, but also the relationships between data. For example, each node in the graph could represent a city on the map, with the edges representing the travel time between the two cities.",
    "tags": [],
    "title": "Graphs",
    "uri": "/cc310/03-intro-dsa/08-graphs/"
  },
  {
    "breadcrumb": "Lists",
    "content": " If we implement a stack using a singly linked list, we can simplify many things about the implementation. First of all, we can totally remove the isFull, doubleCapacity, and halveCapacity operations since we can grow and shrink our list-based stack as needed. The rest of the operations can be implemented directly with list operations. The front of the list will be the top of the stack since the operations to insert and remove items from the front of list are very efficient.\nTo implement our stack, we assume we have declared a linked list object named list.\nPush As expected, the push operation is almost trivial. We simply call the list prepend operation to insert the data into the front of the list.\nfunction push(data) list.prepend(data) end function Pop Like push, the pop operation is also easily implemented using the removeFirst operation of our linked list. As long as the list is not empty, we simply return the data from the first item when we remove it from the list.\nfunction pop() returns data if list.isEmpty() then throw exception end if return list.removeFirst().data end function isEmpty The isEmpty operation is even easier. It is implemented by simply returning the results of the list isEmpty operation.\nfunction isEmpty() return boolean return list.isEmpty() end function Peek The stack peek operation is also straightforward. To implement the peek operation we simply return the results from the list peek operation, which returns the data from the first node in the list.\nfunction peek() returns data return list.peek() end function As we can see, each of the major operations for a stack is implemented easily using list operations that run in constant time. This makes list-based stacks extremely efficient data structures to use.",
    "description": "If we implement a stack using a singly linked list, we can simplify many things about the implementation. First of all, we can totally remove the isFull, doubleCapacity, and halveCapacity operations since we can grow and shrink our list-based stack as needed. The rest of the operations can be implemented directly with list operations. The front of the list will be the top of the stack since the operations to insert and remove items from the front of list are very efficient.",
    "tags": [],
    "title": "List-Based Stacks",
    "uri": "/cc310/9-lists/8-list-based-stacks/"
  },
  {
    "breadcrumb": "Python Review",
    "content": " Loops are another way we can control the flow of our program, this time by repeating steps based on a given criteria. A computer is able to repeat the same instructions many times. There are several ways to tell a computer to repeat a sequence of instructions:\nRepeat an infinite number of times, e.g. while true. This construct is useful in software applications such as servers that will offer a service. The service is supposed to be available forever. Repeat a specific number of times, e.g. Repeat 10 times or for i = 1 to 10. This loop can be used when you know the number of repetitions. There are also loops that allow you to repeat as many times as there are elements of a collection, such as for each item in list Repeat according to a condition. The number of repetitions depends on the condition. Most programming languages support the while loop, which repeats while the condition is true. In repeat while loops, the number of repetitions depends on the occurrence of a condition: the cycle repeats if the condition is true. Loops can also be nested, just like conditional statements.\nLoops in Flowcharts \u0026 Pseudocode The table below lists the flowchart blocks used to represent loop statements, as well as the corresponding pseudocode:\nOperation Flowchart Pseudocode While Loop loop while A \u003c 5\nA = A + 1\nend loop For Loop loop I from 1 to 10\nA = A + I\nend loop For Loop with Step loop I from 1 to 10 step by 2\nA = A + I\nend loop For Each Loop loop each I in LIST\nA = A + I\nend loop Loops in Python To see how loops look in Python, let’s recreate them from the flowcharts shown above.\nwhile a \u003c 5: a = a + 1 for i in range(1, 11): a = a + i for i in range(1, 11, 2): a = a + i for i in list: a = a + i As we can see in the examples above, we must carefully indent each block of code to help set it apart from the other parts of the program. In addition, each line containing for and while must end in a colon :. Finally, notice that the range() function in Python does not include the second parameter in the output. So, to get the numbers $1$ through $10$, inclusive, we must use range(1, 11) in our code.",
    "description": "Loops are another way we can control the flow of our program, this time by repeating steps based on a given criteria. A computer is able to repeat the same instructions many times. There are several ways to tell a computer to repeat a sequence of instructions:\nRepeat an infinite number of times, e.g. while true. This construct is useful in software applications such as servers that will offer a service.",
    "tags": [],
    "title": "Loops",
    "uri": "/cc310/01-review/08-loops/"
  },
  {
    "breadcrumb": "Programming by Contract and Introduction to Performance",
    "content": " Let’s start by considering one number from the list at a time.\nBase Case When we have received just one number, this number is both the maximum and the minimum. In the initial state, you have max holding the maximum, and min holding the minimum. The invariant is the following:\nThe variable max holds the maximum of all the numbers considered so far The variable min holds the minimum of all the numbers considered so far The algorithm is depicted by the following flowchart and pseudocode:\nprint \"Enter a Number:\" input X MAX = X MIN = X The Next Number Then, our program will enter a loop to read 10 more numbers from the user. So, we’ll need to perform the following process during each iteration of the loop:\ncompare the value in max with this new number and update the max value if the new number is greater. In this way, the invariant is preserved. compare the value in min with this new number and update the min value if the new number is smaller. In this way, the invariant is preserved. This part of the program is depicted by the following flowchart and pseudocode:\nloop I from 1 to 10 print \"Enter a Number:\" input X if X \u003e MAX MAX = X end if if X \u003c MIN MIN = X end if end loop After you’ve considered the second number, you end up in the same situation at the beginning: you have a maximum and a minimum value of the numbers input by the user so far. You have found an invariant if you verify that the preconditions before executing an iteration of the loops are the same as the conditions at the end of the loop, known as postconditions:\nLoop preconditions: The variable max holds the maximum value among all the numbers considered so far The variable min holds the minimum value among all the numbers considered so far The new input considered is a number Loop postconditions: The variable max holds the maximum value among all the numbers considered so far The variable min holds the minimum value among all the numbers considered so far Loop invariant: The variable max holds the maximum value among all the numbers considered so far The variable min holds the minimum value among all the numbers considered so far You can then generalize the solution for the nth input: when you consider the nth number, compare it with the values in max and min, updating them if necessary. In each step, we can show that the invariant holds.\nA full flowchart of this program can be found by clicking the following link:\nMin Max Flowchart\nIt is helpful to have this diagram available in a second browser tab for review on the next few pages.",
    "description": "Let’s start by considering one number from the list at a time.\nBase Case When we have received just one number, this number is both the maximum and the minimum. In the initial state, you have max holding the maximum, and min holding the minimum. The invariant is the following:\nThe variable max holds the maximum of all the numbers considered so far The variable min holds the minimum of all the numbers considered so far The algorithm is depicted by the following flowchart and pseudocode:",
    "tags": [],
    "title": "Max and Min - Linear",
    "uri": "/cc310/3-programming-by-contract-and-introduction-to-performance/8-max-and-min---linear/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " Python allows us to specify default values for parameters in a function definition. In that way, if those parameters are not provided, the default value will be used instead. So, it may appear that there are multiple functions with the same name that accept a different number of parameters. This is called function overloading.\nFunction Overloading using Default Values For example, we could create a function named max() that could take either two or three parameters:\ndef main(): max(2, 3) max(3, 4, 5) def max(x, y, z=None): if z is not None: if x \u003e= y: if x \u003e= z: print(x) else: print(z) else: if y \u003e= z: print(y) else: print(z) else: if x \u003e= y: print(x) else: print(y) # main guard if __name__ == \"__main__\": main() In this example, we are calling max() with both 2 and 3 arguments from main(). When we only provide 2 arguments, the third parameter will be given the default value None, which is a special value in Python showing that the variable is empty. Then, we can use if z is not None as part of an If-Then statement to see if we need to take that variable into account in our code.\nThis example also introduces a new keyword, is. The is keyword in Python is used to determine if two variables are exactly the same object, not just the same value. In this case, we want to check that z is exactly the same object as None, not just that it has the same value. In Python, it is common to use the is keyword when checking to see if an optional parameter is given the value None. We’ll see this keyword again in a later chapter as we start dealing with objects.\nKeyword Arguments Python also allows us to specify function arguments using keywords that match the name of the parameter in the function. In that way, we can specify the arguments we need, and the function can use default values for any unspecified parameters. Here’s a quick example:\ndef main(): args(1) # 6 args(1, 5) # 9 args(1, c=5) # 8 args(b=7, a=2) # 12 args(c=5, a=2, b=3) # 10 def args(a, b=2, c=3): print(str(a + b + c)) # main guard if __name__ == \"__main__\": main() In this example, the args() method has one required parameter, a. It can either be provided as the first argument, known as a positional argument, or as a keyword argument like a=2. The other parameters, b and c, can either be provided as positional arguments or keyword arguments, but they are not required since they have default values.\nAlso, we can see that when we use keyword arguments we do not have to provide the arguments in the order they are defined in the function’s definition. However, any arguments provided without keywords must be placed at the beginning of the function call, and will be matched positionally with the first parameters defined in the function.\nVariable Length Parameters Finally, Python allows us to define a single parameter that is a variable length parameter. In essence, it will allow us to accept anywhere from 0 to many arguments for that single parameter, which will then be stored in a list. Let’s look at an example:\ndef main(): max(2, 3) max(3, 4, 5) max(5, 6, 7, 8) max(10, 11, 12, 13, 14, 15, 16) def max(*values): if len(values) \u003e 0: max = values[0] for value in values: if value \u003e max: max = value print(max) # main guard if __name__ == \"__main__\": main() Here, we have defined a function named max() that accepts a single variable length parameter. To show a parameter is variable length we use an asterisk * before variable name. We must respect two rules when creating a variable length parameter:\nEach function may only have one variable length parameter It must be defined after any positional parameters. Any parameters after the variable length parameter can only be assigned as keyword arguments So, when we run this program, we see that we can call the max() function with any number of arguments, and it will be able to determine the maximum of those values. Inside of the function itself, values can be treated just like a list.",
    "description": "Python allows us to specify default values for parameters in a function definition. In that way, if those parameters are not provided, the default value will be used instead. So, it may appear that there are multiple functions with the same name that accept a different number of parameters. This is called function overloading.\nFunction Overloading using Default Values For example, we could create a function named max() that could take either two or three parameters:",
    "tags": [],
    "title": "Overloading",
    "uri": "/cc310/02-oop-review/08-overloading/"
  },
  {
    "breadcrumb": "Queues",
    "content": "In this module we looked at the queue data structure. Queues are a “first in first out” data structure that use two main operations, enqueue and dequeue, to put data into the queue and to remove data from the queue. Queues are useful in many applications including the scheduling of tasks, sharing of resources, and processing of messages in the proper order.",
    "description": "In this module we looked at the queue data structure. Queues are a “first in first out” data structure that use two main operations, enqueue and dequeue, to put data into the queue and to remove data from the queue. Queues are useful in many applications including the scheduling of tasks, sharing of resources, and processing of messages in the proper order.",
    "tags": [],
    "title": "Queues Summary",
    "uri": "/cc310/8-queues/8-queues-summary/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "Sorting is the process we use to organize an ordered container in a way that we understand what the ordering of the values represents. Recall that an ordered container just enforces an ordering between values, but that ordering may appear to be random. By sorting an ordered container, we can enforce a specific ordering on the elements in the container, allowing us to more quickly find specific elements as we’ll see later in this chapter.\nAscending and Descending Order In most cases, we sort values in either ascending or descending order. Ascending order means that the smallest value will be first, and then each value will get progressively larger until the largest value, which is at the end of the container. Descending order is the opposite—the largest value will be first, and then values will get progressively smaller until the smallest value is last.\nWe can also define this mathematically. Assume that we have a container called array and two indexes in that container, a and b. If the container is sorted in ascending order, we would say that if a is less than b (that is, the element at index a comes before the element at index b), then the element at index a is less than or equal to the element at index b. More succinctly:\n$$\ra \u003c b \\implies \\text{array}[a] \\leq \\text{array}[b]\r$$ Likewise, if the container is sorted in descending order, we would know that if a is less than b, then the element at index a would be greater than or equal to the element at index b. Or:\n$$\ra \u003c b \\implies \\text{array}[a] \\geq \\text{array}[b]\r$$ These facts will be important later when we discuss the precondition, postconditions, and loop invariants of algorithms in this section.\nSorting Algorithms To sort a collection of data, we can use one of many sorting algorithms to perform that action. While there are many different algorithms out there for sorting, there are a few commonly used algorithms for this process, each one with its own pros, cons, and time complexity. These algorithms are studied extensively by programmers, and nearly every programmer learns how to write and use these algorithms as part of their learning process. In this module, we’ll introduce you to the 4 most commonly used sorting algorithms:\nSelection Sort, Bubble Sort, Merge Sort, and Quicksort. ",
    "description": "Sorting is the process we use to organize an ordered container in a way that we understand what the ordering of the values represents. Recall that an ordered container just enforces an ordering between values, but that ordering may appear to be random. By sorting an ordered container, we can enforce a specific ordering on the elements in the container, allowing us to more quickly find specific elements as we’ll see later in this chapter.",
    "tags": [],
    "title": "Sorting",
    "uri": "/cc310/7-searching-and-sorting/8-sorting/"
  },
  {
    "breadcrumb": "Stacks",
    "content": "In this module we looked at the stack data structure. Stacks are a “last in first out” data structure that use two main operations, push and pop, to put data onto the stack and to remove data off of the stack. Stacks are useful in many applications including text editor “undo” and web browser “back” functions.",
    "description": "In this module we looked at the stack data structure. Stacks are a “last in first out” data structure that use two main operations, push and pop, to put data onto the stack and to remove data off of the stack. Stacks are useful in many applications including text editor “undo” and web browser “back” functions.",
    "tags": [],
    "title": "Stacks Summary",
    "uri": "/cc310/5-stacks/8-stacks-summary/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome! This page is the main page for Lists",
    "description": "Welcome! This page is the main page for Lists",
    "tags": [],
    "title": "Lists",
    "uri": "/cc310/9-lists/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " In programming, a class describes an individual entity or part of the program. In many cases, the class can be used to describe an actual thing, such as a person, a vehicle, or a game board, or a more abstract thing such as a set of rules for a game, or even an artificial intelligence engine for making business decisions.\nIn object-oriented programming, a class is the basic building block of a larger program. Typically each part of the program is contained within a class, representing either the main logic of the program or the individual entities or things that the program will use.\nRepresenting Classes in UML We can represent the contents of a class in a UML Class Diagram. Below is an example of a class called Person:\nThroughout the next few pages, we will realize the design of this class in code.\nCreating Classes in Python To create a class in Python, we can simply use the class keyword at the beginning of our file:\nclass Person: pass As we’ve already learned, each class declaration in Python includes these parts:\nclass - this keyword says that we are declaring a new class. Person - this is an identifier that gives us the name of the class we are declaring. Following the declaration, we see a colon : marking the start of a new block, inside of which will be all of the fields and methods stored in this class. We’ll need to indent all items inside of this class, just like we do with other blocks in Python.\nIn order for Python to allow this code to run, we cannot have an empty block inside of a class declaration. So, we can add the keyword pass to the block inside of the class so that it is not empty.\nBy convention, we would typically store this class in a file called Person.py.",
    "description": "In programming, a class describes an individual entity or part of the program. In many cases, the class can be used to describe an actual thing, such as a person, a vehicle, or a game board, or a more abstract thing such as a set of rules for a game, or even an artificial intelligence engine for making business decisions.\nIn object-oriented programming, a class is the basic building block of a larger program.",
    "tags": [],
    "title": "Classes",
    "uri": "/cc310/02-oop-review/09-classes/"
  },
  {
    "breadcrumb": "Performance",
    "content": "Throughout this course, we have looked at a few ways we can use the data structures we have already learned to do something useful. In this module, we will look at a few of those examples again, as well as a few more interesting uses of the data structures that we have built.\nArrays and Linked Lists as Stacks, Queues, and Sets First and foremost, it is important to understand that we can implement many of the simpler data structures such as stacks, queues and sets using both arrays and linked lists. In fact, from a certain point of view, there are only two commonly used containers for data – the array and the linked list. Nearly all other data structures are a variant of one of those two approaches or a combination of both.\nEarlier in this chapter, we discussed some of the performance implications that arise when using arrays or linked lists to implement stacks and queues. In practice, we need to understand how we will be using our data in order to choose between the two approaches.\nSets in Compilers and Interpreters One unique use of sets appears in the code of compilers and interpreters. In each case, a programming language can only have one instance of a variable with a given name at any one time. So, we can think of the variables in a program as a set. In the code for a compiler or interpreter, we might find many instances of sets that are used to enforce rules that require each variable or function name to be unique.\nOf course, this same property becomes important in even larger data storage structures, such as a relational database. For example, a database may include a column for a username or identification number which must be unique, such that no two entries can be the same. Once again, we can use a set to help enforce that restriction.\nHash Tables as Sets and Indexers Hash tables are a great example of a data structure that effectively combines arrays and linked lists to increase performance. The best way to understand this is through the analysis of a set implemented using a hash table instead of a linked list.\nWhen we determine if an element is already contained in a set based on a linked list, we must perform a linear search which runs on the order of $N$ time. The same operation performed on a set based on a hash table runs in constant time in the best case. This is because we can use the result of the hash function to jump directly to the bucket where the item should be stored, if it exists.\nThis same trick is used in large relational databases. If we have a database with a million rows, we can define an index for a column that allows us to quickly jump to entries without searching the entire database. To look up a particular entry using an index, we can calculate its hash, find the entry in the index, and then use the link in that index element to find the record in the database.\nFinally, we can also use hash tables to build efficient indexes for large amounts of text data. Consider a textbook, for example. Most textbooks contain an index in the back that gives the page locations where particular terms are discussed. How can we create that index? We can iterate through each word in the textbook, but for each one we will have to search through the existing words in the index to see if that page is already listed for that word. That can be very slow if we must use a linear search through a linked list. However, if we use a hash table to store the index, the process of updating entries can be done in nearly constant time!",
    "description": "Throughout this course, we have looked at a few ways we can use the data structures we have already learned to do something useful. In this module, we will look at a few of those examples again, as well as a few more interesting uses of the data structures that we have built.\nArrays and Linked Lists as Stacks, Queues, and Sets First and foremost, it is important to understand that we can implement many of the simpler data structures such as stacks, queues and sets using both arrays and linked lists.",
    "tags": [],
    "title": "Data Structure Uses",
    "uri": "/cc310/12-performance/9-data-structure-uses/"
  },
  {
    "breadcrumb": "Lists",
    "content": " With singly linked lists, each node in the list had a pointer to the next node in the list. This structure allowed us to grow and shrink the list as needed and gave us the ability to insert and delete nodes at the front, middle, or end of the list. However, we often had to use two pointers when manipulating the list to allow us to access the previous node in the list as well as the current node. One way to solve this problem and make our list even more flexible is to allow a node to point at both the previous node in the list as well as the next node in the list. We call this a doubly linked list.\nThe concept of a doubly linked list is shown below. Here, each node in the list has a link to the next node and a link to the previous node. If there is no previous or next node, we set the pointers to null.\nDoubly Linked Node A doubly linked list node is the same as a singly linked list node with the addition of the previous attribute that points to the previous node in the list as shown below.\nThe class representation of a doubly linked list Node is shown below. As discussed above, we have three attributes:\ndata, which holds the data of the node, next, which is a pointer to the next node, and previous, which is a pointer to the previous node. We also use a constructor and the standard toString operation to create a string for the data stored in the node.\nDoubly Linked List As with our singly linked list, we start off a doubly linked list with a pointer to the first node in the list, which we call head. However, if we also store the pointer to the last node in the list, we can simplify some of our insertion and removal operations as well as reduce the time complexity of operations that insert, remove, or peek at the last node in the list.\nThe figure below shows a doubly linked list with five nodes. The variable head points to the first node in the list, while the variable tail points to the last node in the list. Each node in the list now has two pointers, next and previous, which point to the appropriate node in the list. Notice that the first node’s previous pointer is null, while the last node’s next pointer is also null.\nDoubly Linked List Class Like we did for our singly linked list, we capture the necessary details for our doubly linked list in a class. The doubly linked list class has four attributes:\nhead—the pointer to the first node in the list, tail—the pointer to the last node in the list, current—the pointer to the current node used by the iterator, and size—an integer to keep track of the number of items in the list. Class DoubleLinkedList Node head Node tail Node current Integer size = 0 ",
    "description": "With singly linked lists, each node in the list had a pointer to the next node in the list. This structure allowed us to grow and shrink the list as needed and gave us the ability to insert and delete nodes at the front, middle, or end of the list. However, we often had to use two pointers when manipulating the list to allow us to access the previous node in the list as well as the current node.",
    "tags": [],
    "title": "Doubly Linked Lists",
    "uri": "/cc310/9-lists/9-doubly-linked-lists/"
  },
  {
    "breadcrumb": "Programming by Contract and Introduction to Performance",
    "content": " Another solution consists of comparing the numbers in pairs, instead of one at a time.\nBase Case When we have received just one number, this number is both the maximum and the minimum. In the initial state, you have max holding the maximum, and min holding the minimum. The invariant is the following:\nThe variable max holds the maximum of all the numbers considered so far The variable min holds the minimum of all the numbers considered so far The algorithm is depicted by the following flowchart and pseudocode:\nprint \"Enter a Number:\" input X MAX = X MIN = X The Next Two Numbers In this program, instead of just considering one number at a time, we’ll ask the user to input two numbers. Then, we can determine which of those two inputs is larger (we’ll call it lastmax), and compare it to the value in max. Similarly, we can do the same for the smaller value (called lastmin) and min. Would this program be more efficient?\nThe algorithm is depicted by the following flowchart and pseudocode:\nloop I from 1 to 10 step by 2: output \"Enter a Number:\" input X output \"Enter a Number:\" input Y if X \u003e Y LASTMAX = X LASTMIN = Y else LASTMAX = Y LASTMIN = X end if if LASTMAX \u003e MAX MAX = LASTMAX end if if LASTMIN \u003c MIN MIN = LASTMIN end if end loop Once again, we can easily show that the same loop preconditions, postconditions, and invariants work for this loop:\nLoop preconditions: The variable max holds the maximum value among all the numbers considered so far The variable min holds the minimum value among all the numbers considered so far The new inputs considered are a number Loop postconditions: The variable max holds the maximum value among all the numbers considered so far The variable min holds the minimum value among all the numbers considered so far Loop invariant: The variable max holds the maximum value among all the numbers considered so far The variable min holds the minimum value among all the numbers considered so far A full flowchart of this program can be found by clicking the following link:\nMin Max Flowchart\nIt is helpful to have this diagram available in a second browser tab for review on the next few pages.",
    "description": "Another solution consists of comparing the numbers in pairs, instead of one at a time.\nBase Case When we have received just one number, this number is both the maximum and the minimum. In the initial state, you have max holding the maximum, and min holding the minimum. The invariant is the following:\nThe variable max holds the maximum of all the numbers considered so far The variable min holds the minimum of all the numbers considered so far The algorithm is depicted by the following flowchart and pseudocode:",
    "tags": [],
    "title": "Max and Min - Pairs",
    "uri": "/cc310/3-programming-by-contract-and-introduction-to-performance/9-max-and-min---pairs/"
  },
  {
    "breadcrumb": "Recursion",
    "content": "In this module, we explored the use of recursion to write concise solutions for a variety of problems. Recursion allows us to call a function from within itself, using either head recursion, tail recursion or tree recursion to solve smaller instances of the original problem.\nRecursion requires a base case, which tells our function when to stop calling itself and start returning values, and a recursive case to handle reducing the problem’s size and calling the function again, sometimes multiple times.\nWe can use recursion in many different ways, and any problem that can be solved iteratively can also be solved recursively. The power in recursion comes from its simplicity in code—some problems are much easier to solve recursively than iteratively.\nUnfortunately, in general a recursive solution requires more computation time and memory than an iterative solution. We can use techniques such as memoization to greatly improve the time it takes for a recursive function to execute, especially in the case of calculating Fibonacci numbers where subproblems are overlapped.",
    "description": "In this module, we explored the use of recursion to write concise solutions for a variety of problems. Recursion allows us to call a function from within itself, using either head recursion, tail recursion or tree recursion to solve smaller instances of the original problem.\nRecursion requires a base case, which tells our function when to stop calling itself and start returning values, and a recursive case to handle reducing the problem’s size and calling the function again, sometimes multiple times.",
    "tags": [],
    "title": "Recursion Summary",
    "uri": "/cc310/6-recursion/9-recursion-summary/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": " The first sorting algorithm we’ll learn about is selection sort. The basic idea behind selection sort is to search for the minimum value in the whole container, and place it in the first index. Then, repeat the process for the second smallest value and the second index, and so on until the container is sorted.\nWikipedia includes a great animation that shows this process:\n^[File:Selection-Sort-Animation.gif. (2016, February 12). Wikimedia Commons, the free media repository. Retrieved 22:22, March 23, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Selection-Sort-Animation.gif\u0026oldid=187411773.]\nIn this animation, the element highlighted in blue is the element currently being considered. The red element shows the value that is the minimum value considered, and the yellow elements are the sorted portion of the list.\nSelection Sort Example Let’s look at a few steps in this process to see how it works. First, the algorithm will search through the array to find the minimum value. It will start by looking at index 0 as shown in the figure below.\nOnce it reaches the end of the array, it will find that the smallest value 0 is at index 8.\nThen, it will swap the minimum item with the item at index 0 of the array, placing the smallest item first. That item will now be part of the sorted array, so we’ll shade it in since we don’t want to move it again.\nNext, it will reset index to 1, and start searching for the next smallest element in the array. Notice that this time it will not look at the element at index 0, which is part of the sorted array. Each time the algorithm resets, it will start looking at the element directly after the sorted portion of the array.\nOnce again, it will search through the array to find the smallest value, which will be the value 1 at index 6.\nThen, it will swap the element at index 1 with the minimum element, this time at index 6. Just like before, we’ll shade in the first element since it is now part of the sorted list, and reset the index to begin at index 2\nThis process will repeat until the entire array is sorted in ascending order.",
    "description": "The first sorting algorithm we’ll learn about is selection sort. The basic idea behind selection sort is to search for the minimum value in the whole container, and place it in the first index. Then, repeat the process for the second smallest value and the second index, and so on until the container is sorted.\nWikipedia includes a great animation that shows this process:\n^[File:Selection-Sort-Animation.gif. (2016, February 12). Wikimedia Commons, the free media repository.",
    "tags": [],
    "title": "Selection Sort",
    "uri": "/cc310/7-searching-and-sorting/9-selection-sort/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": " [^1]\nFile:Tree (computer science).svg. (2019, October 20). Wikimedia Commons, the free media repository. Retrieved 03:13, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Tree_(computer_science).svg\u0026oldid=371240902.\nA tree is a more constrained version of a graph data structure. Specifically, a tree is a graph that can be shown as a hierarchical structure, where each node in the tree is itself the root of a smaller tree. Each node in the tree can have one or more child nodes and exactly one parent node, except for the topmost node or root node, which has no parent nodes.\nA tree is very useful for representing data in a hierarchical or sorted format. For example, one common use of a tree data structure is to represent knowledge and decisions that can be made to find particular items. The popular children’s game 20 Questions can be represented as a tree with 20 levels of nodes. Each node represents a particular question that can be asked, and the children of that node represent the possible answers. If the tree only contains yes and no questions, it can still represent up to $2^{20} = 1,408,576$ items!\nTrie Another commonly used tree data structure is the trie, which is a special type of tree used to represent textual data. Ever wonder how a computer can store an entire dictionary and quickly spell-check every single word in the language? It actually uses a trie!\nBelow is a small example of a trie data structure:\n1\nThis trie contains the words “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn” and “A” in just a few nodes and edges. Imagine creating a trie that could store the entire English language! While it might be large, we can hopefully see how it would be much more efficient to search and store that data in a trie instead of a linear data structure.\nWhen to Use a Tree A tree is a great choice for a data structure when there is an inherent hierarchy in our data, such that some nodes or elements are naturally “parents” of other elements. Likewise, if we know that each element may only have one parent but many children, a tree becomes an excellent choice. Trees contain several limitations that graphs do not, but they are also very powerful data structures.\nFile:Trie example.svg. (2014, March 2). Wikimedia Commons, the free media repository. Retrieved 03:22, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Trie_example.svg\u0026oldid=117843653. ↩︎",
    "description": "[^1]\nFile:Tree (computer science).svg. (2019, October 20). Wikimedia Commons, the free media repository. Retrieved 03:13, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Tree_(computer_science).svg\u0026oldid=371240902.\nA tree is a more constrained version of a graph data structure. Specifically, a tree is a graph that can be shown as a hierarchical structure, where each node in the tree is itself the root of a smaller tree. Each node in the tree can have one or more child nodes and exactly one parent node, except for the topmost node or root node, which has no parent nodes.",
    "tags": [],
    "title": "Trees",
    "uri": "/cc310/03-intro-dsa/09-trees/"
  },
  {
    "breadcrumb": "Performance",
    "content": "Welcome! This page is the main page for Java Libraries",
    "description": "Welcome! This page is the main page for Java Libraries",
    "tags": [],
    "title": "Java Libraries",
    "uri": "/cc310/12-performance/10-java-libraries/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome! This page is the main page for Sets",
    "description": "Welcome! This page is the main page for Sets",
    "tags": [],
    "title": "Sets",
    "uri": "/cc310/10-sets/"
  },
  {
    "breadcrumb": "Introduction",
    "content": " Resources Slides The Science of Learning Programming from Nathan Bean’s CIS 400 Textbook The Power of Believing You Can Improve | Carol Dweck - TED Talk on Mindsets and the Power of “Yet” The New Science of Learning: How to Learn in Haromony with your Brain by Terry Doyle and Todd Zakrajsek - Great Book on Learning Constructivism on Wikipedia - Article about Jean Piaget’s Learning Philosophy Toward a Developmental Epistemology of Computer Programming by Raymond Lister - Introduces the Stages of Learning to Program Video Script Before we launch into the course itself, I wanted to take a few minutes to share some information with you regarding what we know about how students learn to program. This isn’t just anecdotal evidence from computer science teachers like me, but theories and research from education researchers who study how humans learn new skills and abilities throughout their lives.If I had to summarize all of this information in as few words as possible, I’d simply say “do the work.” Learning to program is difficult, and the only way to really get good at it is through constant practice and learning. However, that greatly oversimplifies the information that I want to share, and I’m hoping that you’ll find some helpful takeaways from this video that you can incorporate into your learning process.\nBefore I begin, I want go give all the credit to Nathan Bean for developing this information as part of his CIS 400 course. He graciously allowed me to use his hard work here, and I encourage you to check out his original version, which is available at the URL shown on this slide.\nThe statement “do the work” is a shorter version of a very common quote from educators, which is “the person doing the work is the person doing the learning.” I couldn’t find a solid reference for who said it first, so I’ll just attributed it to various educators throughout time. This really highlights one of the biggest struggles many students run into when learning to program. There are so many guides online, and the answer to many simple problems can be found through a quick Google search. You can just copy and paste the code, and then your program works. However, did you really learn how to write that program and what it does, or just how to find a quick answer? While this may be a useful tactic from time to time, if you rely too much on other people to do your coding, you really won’t learn it yourself. This is just like learning to shoot free throws on a basketball court or beating your best time in a speedrun - you can’t just watch someone do it and expect to do it yourself (believe me, I’ve tried). So, if you aren’t doing the work, you aren’t really learning.\nNext, let’s address a major myth in computer science. I’ve heard this many times: “some people are just natural born programmers, and others simply cannot learn to program.” And yes, on the surface, it may appear to be this way. Some students just seem to have a knack for programming, and you may sit and struggle and not really get anywhere. However, there is no innate skill or ability that makes you good at programming.\nInstead, let’s reframe what it means to learn programming. At its core, programming is learning to write steps to solve problems in a way that a computer can perform those steps. That’s really what we are doing when we learn programming.\nSo, we must focus on learning how to write those steps with the proper exactitude and precision so that they make sense, and we must understand how a computer functions to be able to program that computer effectively. So, when you see someone who is good at programming, it’s not because they are good at some esoteric skill that you’ll never have - they just know how to express their steps properly and know enough about how a computer works to make their program do what they want. That’s really it! And, to be honest, after a single semester of learning to program, you’ll have all the skills you need to do both of those things! If you know how to make conditionals, loops, functions, and use simple variables and arrays, that’s really all you need. Everything else that comes after that is just refining those skills to make your programs more powerful and your coding more efficient.\nSo, how do we learn these skills? Well, there are a couple of important pieces we need to make sure are in the right place first. For starters, we need to have the correct mindset. Many times I’ll see students struggle to learn how to program, and they’ll say things like what you see on this slide. “Its too hard.” “I don’t understand this.” “I give up.” Statements like this are the sign of a “fixed mindset,” and they can be one of the greatest blockers preventing you from really learning to program. Just like learning any other skill, you have to be open to instruction and willing to learn, or else you’ve failed before you even started.\nInstead, we want to focus on building a growth mindset. In the TED talk by Carol Dweck that is linked below this video, which I encourage you to watch, she talks about the power of “yet.” We can turn these statements around by simply adding positive power of “yet” - “I don’t understand this yet.” “I love a good challenge.” “I’ll keep trying until I get it.” Going into a programming project with a mindset that is open to growth and change is really an important first steps. When I feel like I’m getting a fixed mindset, I like to think about how difficult it would be to teach a child to tie their shoes if they don’t want to learn. As soon as I realize that, it is pretty easy to recognize that same problem in myself and work to correct it.\nSo, once we have our growth mindset, how do we actually learn to program? To understand that, let’s dive a bit into the world of educational theory and the work of Jean Piaget. Piaget was a biologist and psychologist who studied how young children acquired new knowledge, and he helped pioneer the concept of Constructivism, one of the most influential philosophies in education. You can read more about Constructivism in the links below this video.\nOne particular thing that Piaget worked on was a theory of genetic epistemology. Epistemology is the term for the study of human knowledge, so genetic epistemology is the study of the origins, or genesis, of that knowledge. Put more clearly, it’s the study of how humans create new knowledge. This concept was inspired by research done on snails - he was able to prove that two previously distinct species of snails were actually the same by moving snails from one habitat to another and observing how they modified their behaviors and how their shells grew to match the snails in the new habitat. Put clearly, the snails displayed an altered behavior based on their environment. They tried to exist in equilibrium with their environment by adapting their behaviors to fit what they now experienced in the word.\nPiaget suspected that something similar happens when humans try to learn something - the brain tries to adapt itself to maintain an equilibrium in its environment, which in this case is the existing knowledge it contains. So, when the brain is exposed to new ideas, it must somehow adjust to account for that new information. Piaget proposed two different mechanisms for how this occurs: assimilation and accommodation. In assimilation, new knowledge can be added to existing structures in the brain. For example, if you are exposed to a new color, such as periwinkle, you can see that it falls somewhere between blue and violet, two colors you already know. So, you can assimilate that new knowledge into the existing knowledge without a major disruption to your mental structure of existing colors. Accommodation, on the other hand, happens when your brain must radically adapt to new information for which no existing structures exist. This can be very difficult, and can lead to a lot of struggle and frustration when trying to get “over the hump” on a new subject. Think about learning algebra or a new language for the first time - you really don’t have anything you can use to help understand this new material, so you just have to keep at it until those new structures are formed in your brain.\nUnfortunately, to achieve accommodation, your brain simply has to build brand new structures to store and represent all of this new information, and that process is difficult and takes time. Put another way, it takes significant stimulus, usually in the form of doing homework, struggling with difficult problems and wrestling with the new information to try and understand it all, to create enough disequilibrium in your brain that, coupled with a growth mindset, will allow accommodation to occur. However, when all the pieces are in the right place, and you work hard and have a growth mindset, then…\nEUREKA! The structures will form, and you’ll get over that huge hurdle, and things will start falling into place. It may not happen all at once, but it does happen (you’ve probably had it happen to you several times already - think about some eureka moments from your past - were they related to learning a new skill?). Of course, there’s a good chance that your brain might form a few incorrect structures in the process, so you’ll have to overcome those as you continue to learn. I still struggle to spell some words because my brain formed incorrect structures when I was still learning. But, if you continue to work hard and be open to learning, you’ll eventually sort those errors out as well.\nLet’s look at one other concept in education, which is called stage theory. Piaget identified four stages that children go through as they learn to reason about the world. Those four stages are shown on this slide. In the sensorimotor stage, the child is just using their senses to interact with the world, without any real understanding of what will happen when they perform an action. This is best represented by babies and toddlers, who touch and taste everything in their surroundings. Next, the preoperational stage is represented in young children as they start to think symbolically about the world, using pictures and words to represent actions and objects. They then progress to the concrete operational stage, where they can begin to think logically and understand how concrete events happen. They can also start to think inductively, building the general principles of the world from their specific experiences. For example, if they observe that cooked spaghetti is better than raw spaghetti, they might reason that other foods like potatoes are better cooked than raw. Finally, the last stage is the formal operational stage. This stage is represented by the ability to work fully with an abstract work, formulating and testing hypotheses to truly understand how the world works and predict how new items will work before experiencing them firsthand.\nMany later researchers built upon this model to show that adults learn in much the same way. They also discovered that the stages are not rigid, and you may exhibit behaviors from multiple stages at any given time. This is called the “overlapping waves” model, and is shown here in this diagram. So, as you learn new skills, you may be at the operational stage in some areas, but still at the preoperational stage in other areas. This explains why some concepts may make sense while others don’t for a while - you just have to keep going until it all fits together.\nSo, how can we apply all of this information to programming? One theory comes from the work of Lister and Teague, who proposed a developmental epistemology of computer programming. Put another way, they applied this theory to computer science education, and gave us a unique way to think about the different stages of learning to program.\nAt the sensorimotor stage, we’re just getting the basics. So, when given a piece of code and asked to trace what it does, we still make lots of errors and get the answer incorrect. If we want to get a program to work ourselves, it usually involves a lot of trial and error, and many times when it does end up working we don’t even know exactly why it worked that time, but we’re building up a baseline of information that we can use to construct our mental model of how a computer works.\nAs we progress into the preoperational stage, we become better at tracing code correctly, but we still struggle to understand what the program itself does. We see each line of code as a separate instruction, but not the entire program. A great analogy is reading a recipe that calls for flour, water, salt, and yeast. Will it make bread? Biscuits? Pie crust? We’re not sure yet, but at least we can recognize the ingredients. To solve problems at this stage, we typically will randomly adjust pieces of our code that we don’t quite understand and see what it does, trying to form a better idea of the importance of each line in the code.\nEventually, we’ll get to the concrete operational stage. At this stage, we can construct our own programs, but many times we are simply piecing together parts that we’ve used before and performing some futile patches and bugfixes as we refine the program. We can also work backwards to figure out what a program does from execution results, but we still aren’t very good at deducing the results from the code itself. However, we’re starting to work with abstraction, though we tend to simplify things to a level that we are more comfortable with.\nFinally, we’ll reach the formal operational stage. At this stage, we can comfortable read and understand code without executing it, quickly seeing what it does and how it works without fully tracing it ourselves. We can also start to form hypotheses for how to build new programs and code, and reason about whether different approaches would work better or worse than others. This is the goal stage for any programmer! Once you have reached this stage, then you’ll feel totally at home working in code and developing your own programs from scratch.\nSo, how can we enable ourselves to be the best learners we can be? There is lots of interesting research in that area, best summarized in the book “The New Science of Learning” that is linked below this video. Let’s go through a few of the big concepts.\nFirst, getting ample and regular sleep is important, because it allows your brain to build those knowledge structures we discussed earlier and store the memories from the day in long-term storage. Without enough sleep, your brain is unable to process memories offline and make them ready for retrieval later on, an important step in learning. Also, consuming large amounts of caffeine or alcohol can disrupt your sleep patterns, so keep that in mind before you pour that next cup of coffee or go out partying. You can also take advantage of modern technology to help you track your sleep - most smart watches and smartphones today can help with that!\nLikewise, regular exercise is important to both your physical and mental health. When you exercise, especially aerobic exercise that gets your heart rate up, your body releases neurochemicals that help your brain cells communicate. In addition, just getting up and moving around regularly helps keep your body healthy, so take regular breaks, and consider getting a standing desk for some extra benefits.\nResearch also shows that engaging your senses is an important part in learning. This is why we, as teachers, try to vary our lessons with pictures, videos, activities, and more. It is also the basis of the cognitive apprenticeship style of learning that we use, which you can learn more about in the links below this video. We show you the code we are writing, engaging your sense of vision, while talking about it so you are also listening, and then you are writing your own version, using your sense of touch. You can build upon this by using your senses while you learn by taking notes during a lecture video, building concept maps, and even printing out and writing on your code and these lecture scripts. All of these processes help engage different parts of your brain and make it that much easier to build new knowledge structures.\nLooking for patterns is another important way to understand programming. There are many common patterns in computer programs, such as using a for loop to iterate through an array, or an if-else statement to determine if a particular variable is set to a valid value. By recognizing and understanding those patterns, we can more quickly understand new programs that use slightly different versions of the same code. Humans are naturally very good at pattern recognition, and it is one of the reasons why we see the same code structures time and time again - not because they are the only way to accomplish that goal, but because that structure is commonly used across many programs and therefore is easier to understand.\nThere is quite a bit of research into how memories are formed and how we can adjust our studying habits to take advantage of that. For example, cognitive science shows that the parts of our brain responsible for memory creation are active up to one hour after a learning experience has ended, such as a lecture video or activity. So, instead of jumping to the next task, you may want to take a little while to reflect on what you just did and let it sink in before moving on. Likewise, to build strong memories, it is important to constantly recall the memory or use the skills you’ve learned to strengthen their structures in the brain. This is why teachers like to throw in a few questions from a previous exam or quiz every once in a while - it helps strengthen those structures by forcing you to recall information you’ve learned previously. On the other hand, many students try to “cram” a bunch of information right before an exam, only to forget it soon after because it wasn’t recalled more than once. As you progress further, we’ll continue to come back to concepts you’ve already learned and build upon them, a process called elaboration that helps reinforce what you’ve already learned while building new, related knowledge.\nFinally, it is important to remember that we must give our brains the space it needs to focus on the task at hand. Multitasking while learning, such as watching YouTube or Twitch, chatting with friends, or listening to a lecture video while coding can all reduce your brain’s ability to form strong memories and do well. In fact, research shows that individuals who try to multitask tend to make 50% more errors and spend 50% more time on both tasks. So, instead of giving yourself distractions, try to find things that will help you focus better - there are some great playlists online for music without lyrics that can help you focus or code better, and you can easily mute notifications on your phone and on your computer for an hour or so while you work.\nSo, let’s summarize what we’ve covered here. First, and most importantly, remember that you can learn to program, just like the many students who have done it before you. However, it can be difficult and frustrating at times, and it will take lots of hard work on your part to make it happen. That means that you’ll need to read and write a lot of code before it really starts to make sense. In short, you must do the work to learn to program.\nThat said, you can help make the process easier by getting good sleep, exercising regularly, and engaging fully with all of the content in the course. That means you’ll need to take your own notes, maybe draw some diagrams, and annotate code you write and code you read to help you understand it. While you are working, try not to multitask so you can focus. If you are given some code to include in your program, don’t copy/paste it - rewrite it, and make sure you completely understand what each line does. Finally, take some time to read code written by others! GitHub is a great place to discover all sorts of code and see how others write code. If you want to write good poetry you have to read lots of good poetry, and the same goes for coding.\nWith that in mind, I hope you are able to make the best of this course and continue to develop your programming skills. If you are interested in this topic and would like to know more about things you can do to be a better learner, let us know! As you can imagine, teachers like me love to talk about this stuff, so don’t be afraid to ask. Good luck!",
    "description": "Resources Slides The Science of Learning Programming from Nathan Bean’s CIS 400 Textbook The Power of Believing You Can Improve | Carol Dweck - TED Talk on Mindsets and the Power of “Yet” The New Science of Learning: How to Learn in Haromony with your Brain by Terry Doyle and Todd Zakrajsek - Great Book on Learning Constructivism on Wikipedia - Article about Jean Piaget’s Learning Philosophy Toward a Developmental Epistemology of Computer Programming by Raymond Lister - Introduces the Stages of Learning to Program Video Script Before we launch into the course itself, I wanted to take a few minutes to share some information with you regarding what we know about how students learn to program.",
    "tags": [],
    "title": "How to Learn Programming",
    "uri": "/cc310/00-introduction/05-how-to-learn-programming/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " Of course, our classes are not very useful at this point because they don’t include any attributes or methods. Including attributes in a class is one of the simplest uses of classes, so let’s start there.\nAdding Attributes To add an attribute to a class, we can simply declare a variable inside of our class declaration:\nclass Person: last_name = \"Person\" first_name = \"Test\" age = 25 That’s really all there is to it! These are static attributes or class attributes that are shared among all instances of the class. On the next page, we’ll see how we can create instance attributes within the class’s constructor.\nFinally, we can make these attributes private by adding two underscores to the variable’s name. We denote this on our UML diagram by placing a minus - before the attribute or method’s name. Otherwise, a + indicates that it should be public. In the diagram above, each attribute is private, so we’ll do that in our code:\nclass Person: __last_name = \"Person\" __first_name = \"Test\" __age = 25 Unfortunately, Python does have a way to get around these restrictions as well. Instead of referencing __last_name, we can instead reference _Person__last_name to find that value, as in this example:\nellie = Person(\"Jonson\", \"Ellie\", 29) ellie._Person__last_name = \"Jameson\" print(ellie.last_name) # Jameson Behind the scenes, Python adds an underscore _ followed by the name of the class to the beginning of any class attribute or method that is prefixed with two underscores __. So, knowing that, we can still access those attributes and methods if we want to. Thankfully, it’d be hard to do this accidentally, so it provides some small level of security for our data.",
    "description": "Of course, our classes are not very useful at this point because they don’t include any attributes or methods. Including attributes in a class is one of the simplest uses of classes, so let’s start there.\nAdding Attributes To add an attribute to a class, we can simply declare a variable inside of our class declaration:\nclass Person: last_name = \"Person\" first_name = \"Test\" age = 25 That’s really all there is to it!",
    "tags": [],
    "title": "Attributes",
    "uri": "/cc310/02-oop-review/10-attributes/"
  },
  {
    "breadcrumb": "Lists",
    "content": "Insertion in doubly linked lists is similar to what we saw in the singly linked list with two exceptions:\nWe must update both the previous and next pointers in all affected nodes. We can use the tail pointer to make the insertion of data at the end of the list very efficient. Inserting at the Beginning Inserting at the beginning of a doubly linked list is almost as straightforward as in a singly linked list. We just need to make sure that we update the previous pointer in each affected node. After creating the new node in line 1, we check to see if the list is empty in line 2. If it is empty, then we only have to worry about updating the head and tail pointers to both point at node in lines 3 and 4. If the list is not empty, we have the situation shown below.\nTo insert a node at the beginning of the list, we set head.previous (the previous pointer in the first node in the list) to point to the new node in line 5.\nNext, we set the next pointer in the new node to point to where head is currently pointing in line 6, which is the first node in the list.\nFinally, we update head to point to the new node and then increment the size in line 8.\nWith a little bit of reformatting, we can see that we’ve successfully inserted our new node in the list.\nThe pseudocode for this operation is given below.\nfunction prepend(data) node = new Node(data)\t(1) if size == 0\t(2) head = node\t(3) tail = node\t(4) else head.previous = node\t(5) node.next = head\t(6) head = node\t(7) end size = size + 1\t(8) end functionSince there are no loops in the prepend code, the code runs in constant time.\nInserting in the Middle Inserting a new node at some arbitrary index in a doubly linked list is similar to the same operation in a singly linked list with a couple of changes.\nIf the index is at the end of the list, we can use an efficient append operation (defined below) to insert the node at the end of the list. When walking through the list to the correct index, we do not need to keep track of the previous node. We will have to update both the previous and next pointers in all affected nodes. Lines 1 and 2 in the code check to ensure that the index is a valid number, then we check to see if we are inserting at the beginning or end of the list in lines 2 and 4. If we are, we simply call the appropriate method, either prepend or append.\nIf none of those conditions exist, then we start the process of walking through the list to find the node at index. To do this, we need to create the new node we want to insert and then create a temporary pointer curr that we will use to point to the current node on our walk.\nLines 10 and 11 form the loop that walks through the list until we get to the desired index. When the loop ends, we will want to insert the new node between curr and curr.next. Thus, we set the appropriate values for the new node’s next and previous pointers in line 12 and 13. Then, we set the previous pointer in node.next to point back to node in line 14 and then set curr.next to point at the new node. Finally, we increment size by 1.\nfunction insertAt(data, index) if index \u003c 0 OR index \u003e size\t(1) raise exception\t(2) else if index == 0\t(3) prepend(data)\t(4) else if index == size\t(5) append(data)\t(6) else\t(7) node = new node(data)\t(8) curr = head\t(9) for i = 1 to index -1\t(10) curr = curr.next\t(11) end for node.next = curr.next\t(12) node.previous = curr\t(13) node.next.previous = node\t(14) curr.next = node\t(15) size = size + 1\t(16) end if end functionAlthough prepend and append run in constant time, the general case will cause us to walk through the list using a for loop. Therefore, the insertAt operation runs in order $N$ time.\nInserting at the End Since we have added the tail pointer to the doubly linked list class, we can make adding a node at the end of the list run in constant time instead of order $N$ time. In fact, if you look at the code below for the append operation, it is exactly the same as the constant time prepend operation except we have replaced the head pointer with the tail pointer in lines 5 – 7.\nfunction append(data) node = new node(data)\t(1) if size == 0\t(2) tail = node\t(3) head = node\t(4) else tail.next = node\t(5) node.previous = tail (6) tail = node\t(7) end if size = size + 1\t(8) end function",
    "description": "Insertion in doubly linked lists is similar to what we saw in the singly linked list with two exceptions:\nWe must update both the previous and next pointers in all affected nodes. We can use the tail pointer to make the insertion of data at the end of the list very efficient. Inserting at the Beginning Inserting at the beginning of a doubly linked list is almost as straightforward as in a singly linked list.",
    "tags": [],
    "title": "Doubly Linked Lists - Insertion",
    "uri": "/cc310/9-lists/10-doubly-linked-lists---insertion/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": " 1\nThe last non-linear data structure we’ll talk about is the heap, which is a specialized version of a tree. In a heap, we try to accomplish a few goals:\nStore either the largest or smallest element in the heap at the root node, Ensure that each parent node is either larger or smaller than all of its children, and Minimize the height, or number of levels, of the tree. If we follow those three guidelines, a heap becomes the most efficient data structure for managing a set of data where we always want to get the maximum or minimum value each time we remove an element. These are typically called priority queues, since we remove items based on their priority instead of the order they entered the queue.\nBecause of this, heaps are very important in creating efficient algorithms that deal with ordered data.\nWhen to Use a Heap As discussed above, a heap is an excellent data structure for when we need to store elements and then always be able to quickly retrieve either the smallest or largest element in the data structure. Heaps are a very specific version of a tree that specialize in efficiency over everything else, so they are only really good for a few specific uses.\nFile:Max-Heap.svg. (2014, December 28). Wikimedia Commons, the free media repository. Retrieved 03:25, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Max-Heap.svg\u0026oldid=144372033. ↩︎",
    "description": "1\nThe last non-linear data structure we’ll talk about is the heap, which is a specialized version of a tree. In a heap, we try to accomplish a few goals:\nStore either the largest or smallest element in the heap at the root node, Ensure that each parent node is either larger or smaller than all of its children, and Minimize the height, or number of levels, of the tree.",
    "tags": [],
    "title": "Heaps",
    "uri": "/cc310/03-intro-dsa/10-heaps/"
  },
  {
    "breadcrumb": "Python Review",
    "content": " ^[File:USPS Post office boxes 1.jpg. (2017, May 17). Wikimedia Commons, the free media repository. Retrieved 18:17, November 5, 2018 from https://commons.wikimedia.org/w/index.php?title=File:USPS_Post_office_boxes_1.jpg\u0026oldid=244476438.]\nArrays allow us to store multiple values in the same variable, using an index to determine which value we wish to store or retrieve from the array. We can think of arrays like a set of post office boxes. Each one has the same physical address, the post office, but within the post office we can find an individual box based on its own box number.\nSome programming languages, such as Java, use arrays that are statically sized when they are first created, and those arrays cannot be resized later. In addition, many languages that require variables to be declared with a type only allow a single variable type to be stored in an array.\nOther languages, such as Python, use lists in place of arrays. List can be resized, and in untyped languages such as Python they can store different data types within the same list.\nArrays in Flowcharts \u0026 Pseudocode The table below lists the flowchart blocks used to represent arrays, as well as the corresponding pseudocode:\nOperation Flowchart Pseudocode Declare Array ARR = new array[5] Store Item ARR[0] = 5 Retrieve Item X = ARR[0] Lists in Python Let’s review the syntax for working with lists in Python.\nList Creation To define a list in Python, we can simply place values inside of a set of square brackets [], separated by commas ,:\narr = [1, 2] arr2 = [1.2, 3.4] We can also create an empty list by simply omitting any items inside the square brackets\narr3 = [] Adding Items Once we’ve created a list in Python, we can add items to the end of the list using the append() method:\narr4 = [] arr4.append(1) arr4.append(2) arr4.append(3) Accessing List Elements Once the list is created, we can access individual items in the list by placing the index in square brackets [] after the list’s variable name:\nx = arr[2] arr[1] = 5 Multidimensional List Python lists can also be created with multiple dimensions, simply by appending lists as elements in a base list.\ntwo_dim_arr = [] two_dim_arr.append([1, 2, 3]) two_dim_arr.append([4, 5, 6]) They can also be created through the use of lists as individual elements in a list when it is defined:\nanother_arr = [[1, 2, 3], [4, 5, 6]] To access elements in a multidimensional list, simply include additional sets of square brackets containing an index [] for each dimenison:\nanother_arr = [[1, 2, 3], [4, 5, 6]] x = another_arr[1, 2] another_arr[0, 1] = 5 List Operations There are several operations that can be performed on lists in Python as well:\narr = [1, 2, 3, 4, 5] # list length length = len(arr) # concatenation arr2 = [6, 7] arr3 = arr + arr2 # [1, 2, 3, 4, 5, 6, 7] # slicing b = arr[2:4] # [3, 4] List Loops Finally, we can use a special form of loop, called a For Each loop, to iterate through items in a list in Python:\narr = [1, 2, 3, 4 5] for i in arr: print(i) Once important thing to note is that lists accessed within a For Each loop are read only. So, we cannot change the values stored in the list using this loop, but we can access them. If we want to change them, we should use a standard For loop to iterate through the indices of the list:\narr = [1, 2, 3, 4, 5] for i in range(0, len(arr)): arr[i] = arr[i] + 5 References An Informal Introduction to Python: Lists Data Structures: More on Lists ",
    "description": "^[File:USPS Post office boxes 1.jpg. (2017, May 17). Wikimedia Commons, the free media repository. Retrieved 18:17, November 5, 2018 from https://commons.wikimedia.org/w/index.php?title=File:USPS_Post_office_boxes_1.jpg\u0026oldid=244476438.]\nArrays allow us to store multiple values in the same variable, using an index to determine which value we wish to store or retrieve from the array. We can think of arrays like a set of post office boxes. Each one has the same physical address, the post office, but within the post office we can find an individual box based on its own box number.",
    "tags": [],
    "title": "Lists",
    "uri": "/cc310/01-review/09-lists/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "To describe our selection sort algorithm, we can start with these basic preconditions and postconditions.\nPreconditions:\nThe array stores a type of elements which can be ordered. Postconditions:\nThe array will be sorted in ascending order. We can then represent this algorithm using the following pseudocode.\nfunction SELECTIONSORT(ARRAY)\t(1) loop INDEX from 0 to size of ARRAY – 2\t(2) MININDEX = 0\t(3) # find minimum index\tloop INDEX2 from INDEX to size of ARRAY – 1\t(4) if ARRAY[INDEX2] \u003c ARRAY[MININDEX] then\t(5) MININDEX = INDEX\t(6) end if\t(7) end loop\t(8) # swap elements TEMP = ARRAY[MININDEX]\t(9) ARRAY[MININDEX] = ARRAY[INDEX]\t(10) ARRAY[INDEX] = TEMP\t(11) end loop\t(12) end function\t(13)In this code, we begin by looping through every element in the array except the last one, as seen on line 2. We don’t include this one because if the rest of the array is sorted properly, then the last element must be the maximum value.\nLines 3 through 8 are basically the same as what we saw in our findMin function earlier. It will find the index of the minimum value starting at INDEX through the end of the array. Notice that we are starting at INDEX instead of the beginning. As the outer loop moves through the array, the inner loop will consider fewer and fewer elements. This is because the front of the array contains our sorted elements, and we don’t want to change them once they are in place.\nLines 9 through 11 will then swap the elements at INDEX and MININDEX, putting the smallest element left in the array at the position pointed to by index.\nWe can describe the invariant of our outer loop as follows:\nThe array from index 0 through index is sorted in ascending order. The elements in the array have not changed, only their positions. The second part of the loop invariant is very important. Without that distinction, we could simply place new values into the array before index and satisfy the first part of the invariant. It is always important to specify that the array itself still contains the same elements as before.",
    "description": "To describe our selection sort algorithm, we can start with these basic preconditions and postconditions.\nPreconditions:\nThe array stores a type of elements which can be ordered. Postconditions:\nThe array will be sorted in ascending order. We can then represent this algorithm using the following pseudocode.\nfunction SELECTIONSORT(ARRAY)\t(1) loop INDEX from 0 to size of ARRAY – 2\t(2) MININDEX = 0\t(3) # find minimum index\tloop INDEX2 from INDEX to size of ARRAY – 1\t(4) if ARRAY[INDEX2] \u003c ARRAY[MININDEX] then\t(5) MININDEX = INDEX\t(6) end if\t(7) end loop\t(8) # swap elements TEMP = ARRAY[MININDEX]\t(9) ARRAY[MININDEX] = ARRAY[INDEX]\t(10) ARRAY[INDEX] = TEMP\t(11) end loop\t(12) end function\t(13)In this code, we begin by looping through every element in the array except the last one, as seen on line 2.",
    "tags": [],
    "title": "Selection Sort Pseudocode",
    "uri": "/cc310/7-searching-and-sorting/10-selection-sort-pseudocode/"
  },
  {
    "breadcrumb": "Programming by Contract and Introduction to Performance",
    "content": " It is very useful to compare the two solutions to choose one. In general, you can compare the two solutions by considering:\nThe time required to execute it The amount of memory it requires The number of instructions used, and also the understandability of the code Time Complexity To compare programs in terms of the time we can estimate the running time, or time it takes to complete its work. If the program performs operations on a large set of data, you can also check the run time by using the timer available in your programming language. This type of algorithm profiling is called experimental algorithm evaluation.\nYou can also estimate the time by counting the number of comparisons and assignments performed by the two programs since comparison and assignments are the fundamental operations that allow you to find the smallest and the largest element.\nLet’s do this analysis for both the linear and pairs solution to the problem of finding the minimum and maximum values in a list of numbers. For this analysis, we’ll just look at the code inside the loop, and ignore any code before the loop that initializes variables, since both programs have the same code there.\nComparisons The linear program performs two comparisons, x \u003e max and x \u003c min each time a new number is considered. If the algorithm considers N numbers, the total number of comparisons is $N * 2$ or $2N$ comparisons.\nThe pairs program makes three comparisons every time it considers two elements: x \u003e y, lastmax \u003e max and lastmin \u003c min If the algorithm considers N numbers, the total number of comparison is $N/2 * 3$ or $3/2 N$ comparisons.\nIf we assume that our list is holding a large number of values, then we can see a major difference in the time required to complete the program. Put another way, we can observe that the difference in efficiency between the two programs increases as N increases. Assuming N is $1,000$, the linear program makes $2,000$ comparisons, while the pairs program makes $1,500$ comparisons.\nOf course, data sizes in real programs can be much larger. For example, Google currently indexes around 50 billion web pages! So, a list that contains $1,000$ numbers looks pretty small by comparison.\nAssignments For the assignments, you can count them. For the linear solution, the following situations could occur:\nThe new number updates the maximum. If the new number is the maximum it will be greater than the minimum, so no update is required for the minimum The new number update the minimum. If the new number is the minimum it will be lower than the maximum so no updated are required for the maximum If the new number is between the minimum and the maximum value no updates are required So, in the worst-case, the algorithm performs $N$ assignments. For example, consider a situation where the list is already sorted in increasing order. In that case, we’ll have to update the maximum value each time, resulting in $N$ assignments.\nIn the pairs solution, for every two numbers considered causes the following assignments to be computed:\nTwo assignments for updating the lastmax and lastmin. These two assignments are done in any case. From zero to two assignments to update the min and the max, depending on the results of the comparisons. Therefore, the number of assignments is $2$ in the best case, $4$ in the worst case, and $3$ in the average case. Hence, with $N$ numbers, the number of assignments is $N/2 * 2$ or $N$ in the best case, $2N$ in the worst case and $3/2N$ in the average case. The number of assignments is greater with the second algorithm. But, could we do better in this last case?\nWhich is Better? So, how can we determine which is better? Let’s look at a couple of situations.\nFor example, if we have a list of 1000 numbers, we can find the following number of steps for each program. First, let’s consider the worst case performance, taking the largest values for each.\nLinear: $2N$ or $2000$ comparisons + $N$ or $1000$ assignments, so $3000$ total steps Pairs: $3/2 * N$ or $1500$ comparisons + $2N$ or $2000$ assignments, to $3500$ total steps As we can see, the pairs program requires more steps in total than the linear program. So, it appears that it might be the best choice.\nHowever, not every program will be a worst case. So, let’s look at the best case performance for each one:\nLinear: $2N$ or $2000$ comparisons + $0$ assignments (ignoring the small number of initial assignments), so $2000$ total steps Pairs: $3/2 * N$ or $1500$ comparisons + $N$ or $1000$ assignments, to $2500$ total steps Again, we see that the pairs program still requires more steps than the linear program, though both programs run faster in the best case than the worst case.\nFinally, we can do the same for the average case performance:\nLinear: $2N$ or $2000$ comparisons + $N/2$ assignments, so $2500$ total steps Pairs: $3/2 * N$ or $1500$ comparisons + $3/2 * N$ or $1500$ assignments, to $3000$ total steps There we go! As we can see, in each case the linear program actually performs better than the pairs program, even though we know that the pairs program will only run the loop half as many times as the linear program. The extra comparisons and assignments make the program take more time!",
    "description": "It is very useful to compare the two solutions to choose one. In general, you can compare the two solutions by considering:\nThe time required to execute it The amount of memory it requires The number of instructions used, and also the understandability of the code Time Complexity To compare programs in terms of the time we can estimate the running time, or time it takes to complete its work.",
    "tags": [],
    "title": "Time Complexity",
    "uri": "/cc310/3-programming-by-contract-and-introduction-to-performance/10-time-complexity/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome! This page is the main page for Hash Tables",
    "description": "Welcome! This page is the main page for Hash Tables",
    "tags": [],
    "title": "Hash Tables",
    "uri": "/cc310/11-hash-tables/"
  },
  {
    "breadcrumb": "Performance",
    "content": "Welcome! This page is the main page for Python Libraries",
    "description": "Welcome! This page is the main page for Python Libraries",
    "tags": [],
    "title": "Python Libraries",
    "uri": "/cc310/12-performance/11-python-libraries/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "1\nThe other major topic covered in this course is the use of algorithms to manipulate the data stored in our data structures.\nAn algorithm is best defined as a finite list of specific instructions for performing a task. In the real world, we see algorithms all the time. A recipe for cooking your favorite dish, instructions for how to fix a broken car, or a method for solving a complex mathematical equation can all be considered examples of an algorithm. The flowchart above shows Euclid’s Algorithm for finding the greatest common divisor of two numbers.\nIn this course, however, we’re going to look specifically at the algorithms and algorithmic techniques that are most commonly used with data structures in computer programming.\nAlgorithmic Techniques An algorithmic technique, sometimes referred to as a methodology or paradigm, is a particular way to design an algorithm. While there are a few commonly used algorithms across different data structures, many times each program may need a unique algorithm, or at least an adaptation of an existing algorithm. to perform its work.\nTo make these numerous algorithms easier to understand, we can loosely categorize them based on the techniques they use to solve the problem. On the next few pages, we’ll introduce some of the more commonly used algorithmic techniques in this course. Throughout this course, we will learn how to apply many of these techniques when designing algorithms that work with various data structures to accomplish a goal.\nFile:Euclid flowchart.svg. (2019, January 8). Wikimedia Commons, the free media repository. Retrieved 21:43, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Euclid_flowchart.svg\u0026oldid=334007111. ↩︎",
    "description": "1\nThe other major topic covered in this course is the use of algorithms to manipulate the data stored in our data structures.\nAn algorithm is best defined as a finite list of specific instructions for performing a task. In the real world, we see algorithms all the time. A recipe for cooking your favorite dish, instructions for how to fix a broken car, or a method for solving a complex mathematical equation can all be considered examples of an algorithm.",
    "tags": [],
    "title": "Algorithms",
    "uri": "/cc310/03-intro-dsa/11-algorithms/"
  },
  {
    "breadcrumb": "Lists",
    "content": "The process of removing a node from a doubly linked list is really no more difficult than from a singly linked list. The only difference is that instead of changing just one pointer, we now also need to modify the previous pointer in the node following the node we want to remove. For instance, if we want to remove node “3” from the following list,\nwe simply modify the next pointer in node “-2” to point to node “23”. Then, we modify the previous pointer in node “23” to point to node “-2”. We then return the data in that node to the requesting function.\nRemoving at the Beginning The remove operation removes the first node in the list. First, we check to ensure that there is at least one node in the list in line 1 and raise an exception if there is not. Now, the process is simple. We simply create a temporary pointer temp that points to the node we are going to delete in line 3 and then point head to head.next, which is the second node in the list. Then, in line 5, we check to see if the list is empty (head == null) and set tail to null if it is (it was pointing at the node we just removed). If the list is not empty, we do not need to worry about updating tail; however, we do need to set the previous pointer of the first node in the list to null (it was also pointing at the node we just removed). Finally, we decrement size in line 8 and then return the data in the node we just removed in line 9. Obviously, the operation runs in constant time since there are no loops.\nfunction remove() returns data if size == 0\t(1) raise exception\t(2) end if temp = head\t(3) head = head.next\t(4) if head == null\t(5) tail = null\t(6) else head.previous = null\t(7) end if size = size – 1\t(8) return temp.data\t(9) end functionRemoving in the Middle Removing a node at a specific index is very similar to the way we did it in singly linked lists. First, if we have an invalid index number, we raise an exception in line 2. Otherwise we check for the special cases of removing the first or last node in the list and calling the appropriate operations in lines 3 – 6. If we have no special conditions, we create a temporary pointer curr and then walk through our list in lines 7 – 9. Once we reach the node we want to remove, we simply update the next node’s previous pointer (line 10) and the previous node’s next pointer (line 11) and we have effectively removed the node from the list. We then decrement size in line 12 and return the data from the removed node in line 13.\nSince the operation relies on a loop to walk through the list, the operation runs in order $N$ time.\nfunction removeAt(index) returns data if index \u003c 0 OR index \u003e size – 1\t(1) raise exception\t(2) else if (index == 0)\t(3) return remove()\t(4) else if index == size – 1\t(5) return removeLast()\t(6) else\tcurr = head.next;\t(7) for i = 1 to index -1 (8) curr = curr.next\t(9) end for curr.next.previous = curr.previous\t(10) curr.previous.next = curr.next\t(11) size = size – 1\t(12) return curr.data\t(13) end if end functionRemoving at the End Since we have added the tail pointer to the doubly linked list class, we can make removing a node at the end of the list run in constant time instead of running in order $N$ time. In fact, if you look at the code below for the removeLast operation, it is almost exactly the same as the constant time removeFirst operation. The only difference is that we have replaced the head pointer with the tail pointer and head.next with tail.previous in lines 3 – 7.\nfunction removeLast() returns data if size == 0\t(1) raise exception\t(2) end if\ttemp = tail\t(3) tail = tail.previous\t(4) if tail == null\t(5) head = null\t(6) else\ttail.next = null\t(7) end if size = size – 1\t(8) return temp.data\t(9) end functionPeekEnd Another operation impacted by the addition of the tail pointer is the peekEnd operation. Since we can access the last node in the list directly, we just need to make sure that the list is not empty, which we do in lines 1 and 2. Then, we can return the tail.data.\nfunction peekEnd() returns data if isEmpty()\t(1) raise exception (2) else\treturn tail.data\t(3) end if end function",
    "description": "The process of removing a node from a doubly linked list is really no more difficult than from a singly linked list. The only difference is that instead of changing just one pointer, we now also need to modify the previous pointer in the node following the node we want to remove. For instance, if we want to remove node “3” from the following list,\nwe simply modify the next pointer in node “-2” to point to node “23”.",
    "tags": [],
    "title": "Doubly Linked Lists - Removal and Peek",
    "uri": "/cc310/9-lists/11-doubly-linked-lists---removal-and-peek/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " We can also add methods to our classes. These methods are used either to modify the attributes of the class or to perform actions based on the attributes stored in the class. Finally, we can even use those methods to perform actions on data provided as arguments. In essence, the sky is the limit with methods in classes, so we’ll be able to do just about anything we need to do in these methods. Let’s see how we can add methods to our classes.\nConstructors A constructor is a special method that is called whenever a new instance of a class is created. It is used to set the initial values of attributes in the class. We can even accept parameters as part of a constructor, and then use those parameters to populate attributes in the class.\nLet’s go back to the Person class example we’ve been working on and add a simple constructor to that class:\nclass Person: __last_name = \"Person\" __first_name = \"Test\" __age = 25 def __init__(self, last_name, first_name, age): self.__last_name = last_name self.__first_name = first_name self.__age = age Since the constructor is an instance method, we need to add a parameter to the function at the very beginning of our list of parameters, typically named self. This parameter is automatically added by Python whenever we call an instance method, and it is a reference to the current instance on which the method is being called. We’ll learn more about this later.\nInside that constructor, notice that we use each parameter to set the corresponding attribute, using the self keyword once again to refer to the current object.\nAlso, since we are now defining the attributes as instance attributes in the constructor, we can remove them from the class definition itself:\nclass Person: def __init__(self, last_name, first_name, age): self.__last_name = last_name self.__first_name = first_name self.__age = age Variable Scope We’ve already discussed variable scope earlier in this course. Recall that two different functions may use the same local variable names without affecting each other because they are in different scopes.\nThe same applies to classes. A class may have an attribute named age, but a method inside of the class may also use a local variable named age. Therefore, we must be careful to make sure that we access the correct variable, using the self reference if we intend to access the attribute’s value in the current instance. Here’s a short example:\nclass Test: age = 15 def foo(self): age = 12 print(age) # 12 print(self.age) # 15 def bar(self): print(self.age) # 15 print(age) # NameError As we can see, in the method foo() we must be careful to use self.age to refer to the attribute, since there is another variable named age declared in that method. However, in the method bar() we see that age itself causes a NameError since there is no other variable named age defined in that scope. We have to use self.age to reference the attribute.\nSo, we should always get in the habit of using self to refer to any attributes, just to avoid any unintended problems later on.\nProperties In Python, we can use a special decorator @property to define special methods, called getters and setters, that can be used to access and update the value of private attributes.\nGetter In Python, a getter method is a method that can be used to access the value of a private attribute. To mark a getter method, we use the @property decorator, as in the following example:\nclass Person: def __init__(self, last_name, first_name, age): self.__last_name = last_name self.__first_name = first_name self.__age = age @property def last_name(self): return self.__last_name @property def first_name(self): return self.__first_name @property def age(self): return self.__age Setter Similarly, we can create another method that can be used to update the value of the age attribute:\nclass Person: def __init__(self, last_name, first_name, age): self.__last_name = last_name self.__first_name = first_name self.__age = age @property def last_name(self): return self.__last_name @property def first_name(self): return self.__first_name @property def age(self): return self.__age @age.setter def age(self, value): self.__age = value However, this method is not required in the UML diagram, so we can omit it.\nAdding Methods To add a method to our class, we can simply add a function declaration inside of our class.\nclass Person: def __init__(self, last_name, first_name, age): self.__last_name = last_name self.__first_name = first_name self.__age = age @property def last_name(self): return self.__last_name @property def first_name(self): return self.__first_name @property def age(self): return self.__age def happy_birthday(self): self.__age = self.age + 1 Notice that once again we must remember to add the self parameter as the first parameter. This method will update the private age attribute by one year.\nInstantiation Now that we have fully constructed our class, we can use it elsewhere in our code through the process of instantiation. In Python, we can simply call the name of the class as a method to create a new instance, which calls the constructor, and then we can use dot-notation to access any attributes or methods inside of that object.\nfrom Person import * john = Person(\"Smith\", \"John\", 25) print(john.last_name) john.happy_birthday() Notice that we don’t have to provide a value for the self parameter when we use any methods. This parameter is added automatically by Python based on the value of the object we are calling the methods from.",
    "description": "We can also add methods to our classes. These methods are used either to modify the attributes of the class or to perform actions based on the attributes stored in the class. Finally, we can even use those methods to perform actions on data provided as arguments. In essence, the sky is the limit with methods in classes, so we’ll be able to do just about anything we need to do in these methods.",
    "tags": [],
    "title": "Methods",
    "uri": "/cc310/02-oop-review/11-methods/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "Let’s look at the time complexity of the selection sort algorithm, just so we can get a feel for how much time this operation takes.\nFirst, we must determine if there is a worst-case input for selection sort. Can we think of any particular input which would require more steps to complete?\nIn this case, each iteration of selection sort will look at the same number of elements, no matter what they are. So there isn’t a particular input that would be considered worst-case. We can proceed with just the general case.\nIn each iteration of the algorithm we need to search for the minimum value of the remaining elements in the container. If the container has $N$ elements, we would follow the steps below.\nThe first time we need to find the minimum among $N$ elements. This will take $N$ comparisons assuming the element are compared one by one with the minimum. The second time we need to find the minimum among $N - 1$ elements. This will take $N - 1$ comparisons. The third time we need to find the minimum among $N - 2$ elements. This will take $N - 2$ comparisons. … and so on. This process continues until we have sorted all of the elements in the array. The number of steps will be:\n$$\rN + (N – 1) + (N – 2) + … + 2 + 1\r$$ While it takes a bit of math to figure out exactly what that means, we can use some intuition to determine an approximate value. For example we could pair up the values like this:\n$$\rN + [(N – 1) + 1] + [(N – 2) + 2] + ...\r$$ When we do that, we’ll see that we can create around $N / 2$ pairs, each one with the value of $N$. So a rough approximation of this value is $N * (N / 2)$, which is $N^2 / 2$. When analyzing time complexity, we would say that this is “on the order of $N^2$” time. Put another way, if the size of $N$ doubles, we would expect the number of steps to go up by a factor of $4$, since $(2 * N)^2 = 4N$.\nLater on, we’ll come back to this and compare the time complexity of each sorting algorithm and searching algorithm to see how they stack up against each other.",
    "description": "Let’s look at the time complexity of the selection sort algorithm, just so we can get a feel for how much time this operation takes.\nFirst, we must determine if there is a worst-case input for selection sort. Can we think of any particular input which would require more steps to complete?\nIn this case, each iteration of selection sort will look at the same number of elements, no matter what they are.",
    "tags": [],
    "title": "Selection Sort Time Complexity",
    "uri": "/cc310/7-searching-and-sorting/11-selection-sort-time-complexity/"
  },
  {
    "breadcrumb": "Programming by Contract and Introduction to Performance",
    "content": "We can also look at a program based on the amount of space, or memory, that it uses. In this case, we are looking at the number of variables that are needed, and also the size of any lists, arrays, or more advanced data structures used.\nThe comparison in terms of space leads us to observe that the linear solution uses, in addition to the input value x for each iteration of the loop, also the max and min variables. So, there are just 3 more variables to keep track of.\nThe pairs solution uses, in addition to the two input values x and y for each iteration of the loop, two variables for the lastmax and lastmin as well as the global max and min variables. So, there are 6 more variables to keep track of in this solution\nTherefore, the linear solution is more space-efficient since it requires only three variables.\nA Bigger Example Let’s consider a bigger example program, just to see the impact of space complexity when analyzing a program. Consider a program that will compute the result of multiplying two numbers from $1$ through $10$. So, there are 10 numbers we need to consider as both operands.\nOne possible solution would be to pre-compute all possible answers in a 10 by 10 array, which would contain 100 elements. A diagram of this is shown below.\n^[Wikipedia contributors. (2020, January 25). Multiplication table. In Wikipedia, The Free Encyclopedia. Retrieved 02:06, January 28, 2020, from https://en.wikipedia.org/w/index.php?title=Multiplication_table\u0026oldid=937470066]\nThis is a very inefficient program in terms of space complexity, since it requires $N^2$ spaces in memory for $N$ possible operand values.\nOf course, we already know that we could write a program that could simply calculate and return the answer based on the input values, so this example is a bit worthless in practice. However, on some small, embedded systems such as a smart watch or nano-machine, we might discover that it is better to use memory than to spend time calculating a result on such a slow processor, so there are times where having higher space complexity helps save time in the long run.",
    "description": "We can also look at a program based on the amount of space, or memory, that it uses. In this case, we are looking at the number of variables that are needed, and also the size of any lists, arrays, or more advanced data structures used.\nThe comparison in terms of space leads us to observe that the linear solution uses, in addition to the input value x for each iteration of the loop, also the max and min variables.",
    "tags": [],
    "title": "Space Complexity",
    "uri": "/cc310/3-programming-by-contract-and-introduction-to-performance/11-space-complexity/"
  },
  {
    "breadcrumb": "Python Review",
    "content": "Variables in our programs can be used in a variety of different roles. The simplest role for any variable is to store a value that does not change throughout the entire program. Most variables, however, fit into one of several roles throughout the program.\nTo help us understand these roles, let’s review them in detail here. As we move forward in this course, we’ll see many different data structures that use variables in these ways, so it helps to know each of them early on!\nContainer OPERAND = 1In this role, the variable is used to hold a value. This value can be changed during the program execution. In the example:\na variable named operand of type Integer is declared the value 1 is assigned to the variable Counter loop COUNTER from 1 to 10 print COUNTER end loopIn this role, variables are used to hold a sequence of values known beforehand. In the example, the variable counter holds values from 1 to 10 and these values are conveyed to the user.\nAccumulator SUM = 0 loop COUNTER from 1 to 10 SUM = SUM + COUNTER end loop print SUMIn this role, the variable is used to hold a value that aggregates, summarizes, and synthesize multiple values by means of an operation such as sum, product, mean, geometric mean, or median. In the example, we calculate the sum of the first ten numbers in the accumulator variable sum.\nRecent Value ANSWER = 0 print \"Input a number\" input ANSWER print \"You input \" + ANSWERIn this role, the variable answer contains the last value encountered so far in a data series, such as the last value that the program receives from the user.\nExtreme Value COUNTER = 0 SCORES = new array[10] input SCORES MAX = SCORES[0] loop COUNTER from 0 to (size of SCORES) - 1 if SCORES[COUNTER] \u003e MAX MAX = SCORES[COUNTER] end if end loop print \"Max value: \" + MAXIn this role, the variable contains the value that is most appropriate for the purpose of the program, e.g. the minimum or the maximum. The instruction scores[counter] \u003e max checks if the list item under observation is greater than the maximum. If the condition is true the value of the maximum variable is changed.\nFollower COUNTER = 0 SCORES = new array[10] input SCORES MAX = SCORES[0] SECOND = MAX loop COUNTER from 0 to (size of SCORES) - 1 if SCORES[COUNTER] \u003e MAX SECOND = MAX MAX = SCORES[COUNTER] else if SCORES[COUNTER] \u003e SECOND SECOND = SCORES[COUNTER] end if end loop print \"Max value: \" + MAX + \" Second max: \" + SECONDA variable, such as second, to which you assign the value of another variable that will be changed immediately after. In the example, the second variable contains the second largest value in a list.\nFlag MISTAKE = false COUNTER = 0 input COUNTER if COUNTER \u003c 0 MISTAKE = true else MISTAKE = false end ifA flag variable is used to report the occurrence or not of a particular condition, e.g. the occurrence of an error, the first execution, etc..\nTemporary TEMP = FIRST FIRST = SECOND SECOND = TEMPA variable used to hold a temporary value. For example, to exchange two variables, you must have a temporary variable temp to store a value before it is replaced.\nIndex SCORES = new array[10] input SCORES loop INDEX from 0 to 9 print SCORES[INDEX] end loopA variable used to indicate the position of the current item in a set of elements, such as the current item in an array of elements. The index variable here is a great example.\nReferences Sajaniemi, J. (2005, October). Roles of variables and learning to program. In Proc. 3rd Panhellenic Conf. Didactics of Informatics, Jimoyiannis A (ed) University of Peloponnese, Korinthos, Greece. Hosanee, M., \u0026 Rana, M. E. (2018). A Refined Approach for Understanding Role of Variables in Elementary Programming. Jour of Adv Research in Dynamical \u0026 Control Systems, 10(11). ",
    "description": "Variables in our programs can be used in a variety of different roles. The simplest role for any variable is to store a value that does not change throughout the entire program. Most variables, however, fit into one of several roles throughout the program.\nTo help us understand these roles, let’s review them in detail here. As we move forward in this course, we’ll see many different data structures that use variables in these ways, so it helps to know each of them early on!",
    "tags": [],
    "title": "Variable Roles",
    "uri": "/cc310/01-review/10-variable-roles/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome! This page is the main page for Performance",
    "description": "Welcome! This page is the main page for Performance",
    "tags": [],
    "title": "Performance",
    "uri": "/cc310/12-performance/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "The first algorithmic technique we’ll use is the brute force technique. This is the algorithmic technique that most of us are most familiar with, even if we don’t realize it.\nSimply put, a brute force algorithm will try all possible solutions to the problem, only stopping when it finds one that is the actual solution. A great example of a brute force algorithm in action is plugging in a USB cable. Many times, we will try one way, and if that doesn’t work, flip it over and try the other. Likewise, if we have a large number of keys but are unsure which one fits in a particular lock, we can just try each key until one works. That’s the essence of the brute force approach to algorithmic design.\nExample - Closest Pair 1\nA great example of a brute force algorithm is finding the closest pair of points in a multidimensional space. This could be as simple as finding the two closest cities on a map, or the two closest stars in a galaxy.\nTo find the answer, a brute force approach would be to simply calculate the distance between each individual pair of points, and then keep track of the minimum distance found. A pseudocode version of this algorithm would be similar to the following.\nMINIMUM = infinity POINT1 = none POINT2 = none loop each POINTA in POINTS loop each POINTB in POINTS if POINTA != POINTB DISTANCE = COMPUTE_DISTANCE(POINTA, POINTB) if DISTANCE \u003c MINIMUM MINIMUM = DISTANCE POINT1 = POINTA POINT2 = POINTB end if end if end loop end loopLooking at this code, if we have $N$ points, it would take $N^2$ steps to solve the problem! That’s not very efficient, event for a small data set. However, the code itself is really simple, and it is guaranteed to find exactly the best answer, provided we have enough time and a powerful enough computer to run the program.\nIn the project for this module, we’ll implement a few different brute-force algorithms to solve simple problems. This will help us gain more experience with this particular technique.\nFile:Closest pair of points.svg. (2018, October 20). Wikimedia Commons, the free media repository. Retrieved 22:29, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Closest_pair_of_points.svg\u0026oldid=324759130. ↩︎",
    "description": "The first algorithmic technique we’ll use is the brute force technique. This is the algorithmic technique that most of us are most familiar with, even if we don’t realize it.\nSimply put, a brute force algorithm will try all possible solutions to the problem, only stopping when it finds one that is the actual solution. A great example of a brute force algorithm in action is plugging in a USB cable.",
    "tags": [],
    "title": "Brute Force",
    "uri": "/cc310/03-intro-dsa/12-brute-force/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": " Next, let’s look at another sorting algorithm, bubble sort. The basic idea behind bubble sort is to continuously iterate through the array and swap adjacent elements that are out of order. As a side effect of this process, the largest element in the array will be “bubbled” to the end of the array after the first iteration. Subsequent iterations will do the same for each of the next largest elements, until eventually the entire list is sorted.\nWikipedia includes a great animation that shows this process:\n^[File:Bubble-sort-example-300px.gif. (2019, June 12). Wikimedia Commons, the free media repository. Retrieved 22:36, March 23, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Bubble-sort-example-300px.gif\u0026oldid=354097364. ] In this animation, the two red boxes slowly move through the array, comparing adjacent elements. If the elements are not in the correct order (that is, the first element is larger than the second element), then it will swap them. Once it reaches the end, the largest element, 8, will be placed at the end and locked in place.\nBubble Sort Example Let’s walk through a few steps of this process and see how it works. We’ll use the array we used previously for selection sort, just to keep things simple. At first, the array will look like the diagram below.\nWe’ll begin with the index variable pointing at index 0. Our algorithm should compare the values at index 0 and index 1 and see if they need to be swapped. We’ll put a bold border around the elements we are currently comparing in the figure below.\nSince the element at index 0 is 8, and the element at index 1 is 5, we know that they must be swapped since 8 is greater than 5. We need to swap those two elements in the array, as shown below.\nOnce those two elements have been swapped, the index variable will be incremented by 1, and we’ll look at the elements at indexes 1 and 2 next.\nSince 8 is greater than 2, we’ll swap these two elements before incrementing index to 2 and comparing the next two elements.\nAgain, we’ll find that 8 is greater than 6, so we’ll swap these two elements and move on to index 3.\nNow we are looking at the element at index 3, which is 8, and the element at index 4, which is 9. In this case, 8 is less than 9, so we don’t need to swap anything. We’ll just increment index by 1 and look at the elements at indexes 4 and 5.\nAs we’ve done before, we’ll find that 9 is greater than 3, so we’ll need to swap those two items. In fact, as we continue to move through the array, we’ll find that 9 is the largest item in the entire array, so we’ll end up swapping it with every element down to the end of the array. At that point, it will be in its final position, so we’ll lock it and restart the process again.\nAfter making a second pass through the array, swapping elements that must be swapped as we find them, we’ll eventually get to the end and find that 8 should be placed at index 8 since it is the next largest value in the array.\nWe can then continue this process until we have locked each element in place at the end of the array.",
    "description": "Next, let’s look at another sorting algorithm, bubble sort. The basic idea behind bubble sort is to continuously iterate through the array and swap adjacent elements that are out of order. As a side effect of this process, the largest element in the array will be “bubbled” to the end of the array after the first iteration. Subsequent iterations will do the same for each of the next largest elements, until eventually the entire list is sorted.",
    "tags": [],
    "title": "Bubble Sort",
    "uri": "/cc310/7-searching-and-sorting/12-bubble-sort/"
  },
  {
    "breadcrumb": "Programming by Contract and Introduction to Performance",
    "content": "Lastly, when analyzing a program, we must also consider the complexity of the code used to write the program. Code complexity can refer to many things, but in general we use it to describe how many lines of code are included the program, as well as how easy it is to understand what the program does.\nLines of Code One of the most common ways to measure the size of a program is the number of lines of code, or LOC, of the program. This can be a very rough estimate of the size of the program, since, in general, a longer program with more lines of code may be more complex than a shorter program with fewer lines.\nSo, if we can find a solution to a problem that requires many fewer lines of code than another solution, that is one factor to consider. Of course, the solution with fewer lines of code may be more complex in terms of time or space!\nUnderstandability The other important measure of code complexity deals with how easy it is to understand what the program does. Sometimes we can write a program that only takes a few lines of code, but it is so complex that it is difficult to really understand how it works.\nFor example, consider this line of pseudocode - can you determine what it does?\nreturn (X \u003e 0) and ((X % 10) + (INT((X % 100) / 10))) \u003c 5It is pretty difficult to understand. Can we rewrite this program to make it easier to understand? Consider the following code:\nif X \u003c= 0\rreturn FALSE\relse\rONES_PLACE = X % 10\rTENS_PLACE = X % 100\rSUM_LAST_TWO_DIGITS = TENS_PLACE + ONES_PLACE\rif SUM_LAST_TWO_DIGITS \u003c 5\rreturn TRUE\relse\rreturn FALSE\rend if\rend ifThis program is pretty easy to follow. First, it will determine if X is 0 or a negative number, and return FALSE if so. Then, it will find the last two digits of the number, corresponding to the ones and the tens place, and sum them. Finally, if the sum of the last two digits is less than $5$, it will return TRUE. Otherwise, it will return FALSE.\nAs it turns out, these two programs do the exact same thing! However, from the single line of code in the first program, it is very difficult to decipher exactly what it does. The second program, even though it is much longer, is much easier to understand. In addition, when run on a real computer, both of these programs will take nearly the same amount of time to run.\nComplexity Triad As we’ve seen, we can describe the complexity of a program in terms of three values: the time it takes to run, the space it requires in memory, and the size and understandability of the code. However, how do we know which of those measures is the most important?\nUnfortunately, that is a difficult question to answer. In general, we want to reduce each of these levels of complexity, but sometimes there are trade-offs. For example, a program that runs quickly may require lots of extra memory, or it could even require really complex code.\nThe world of business uses a simple triad to understand these trade-offs, as shown in the diagram below:\n^[File:Project-triangle.svg. (2020, January 12). Wikimedia Commons, the free media repository. Retrieved 02:41, January 28, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Project-triangle.svg\u0026oldid=386979544.]\nAlong with this diagram comes the saying: “Fast. Good. Cheap. Pick any two.” It helps express the difficulty in finding a perfect program that does not contain at least one level of complexity.\nThankfully, most modern computers have a sufficiently fast processor and ample memory that most programs can run easily, even without worrying about reducing the space and time complexity of the program. So, it may seem that the most important measure to focus on is code complexity: we should strive to write readable and understandable code.\nHowever, as we build larger programs and deal with more input data, time and space complexity quickly become more important. So, it is important to consider each measure independently, and do the best we can to build programs that run quickly, use a minimal amount of memory, and aren’t so complex that they are difficult to understand.",
    "description": "Lastly, when analyzing a program, we must also consider the complexity of the code used to write the program. Code complexity can refer to many things, but in general we use it to describe how many lines of code are included the program, as well as how easy it is to understand what the program does.\nLines of Code One of the most common ways to measure the size of a program is the number of lines of code, or LOC, of the program.",
    "tags": [],
    "title": "Code Complexity",
    "uri": "/cc310/3-programming-by-contract-and-introduction-to-performance/12-code-complexity/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": " We can also build classes that inherit attributes and methods from another class. This allows us to build more complex structures in our code, better representing the relationships between real world objects.\nInheritance in UML As we learned earlier in this chapter, we can represent an inheritance relationship with an open arrow in our UML diagrams, as shown below:\nIn this diagram, the Student class inherits from, or is a subclass of, the Person class.\nInheritance in Python To show inheritance in Python, we place the parent class inside of parentheses directly after the name of the subclass when it is defined:\nfrom Person import * class Student(Person): pass From there, we can quickly implement the code for each property and getter method in the new class:\nfrom Person import * class Student(Person): @property def student_id(self): return self.__student_id @property def grade_level(self): return self.__grade_level Method Overriding Since the subclass Student also includes a definition for the method happy_birthday(), we say that that method has been overridden in the subclass. We can do this by simply creating the new method in the Student class, making sure it accepts the same number of parameters as the original:\nfrom Person import * class Student(Person): @property def student_id(self): return self.__student_id @property def grade_level(self): return self.__grade_level def happy_birthday(self): super().happy_birthday() self.__grade_level += 1 Here, we are using the function super() to refer to our parent class. In that way, we can still call the happy_birthday() method as defined in Person, but extend it by adding our own code as well.\nInherited Constructors In addition, we can use the super() method to call our parent class’s constructor.\nfrom Person import * class Student(Person): @property def student_id(self): return self.__student_id @property def grade_level(self): return self.__grade_level def __init__(self, last_name, first_name, age, student_id, grade_level): super().__init__(last_name, first_name, age) self.__student_id = student_id self.__grade_level = grade_level def happy_birthday(self): super().happy_birthday() self.__grade_level += 1 Security In addition to private and public attributes and methods, UML also includes the concept of protected methods. This modifier is used to indicate that the attribute or method should not be accessed outside of the class, but will allow any subclasses to access them. Python does not enforce this restriction; it is simply convention. In a UML diagram, the protected keyword is denoted by a hash symbol # in front of the attribute or method. In Python, we then prefix those attributes or methods with a single underscore _.\nPolymorphism Inheritance allows us to make use of polymorphism in our code. Loosely polymorphism allows us to treat an instance of a class within the data type of any of its parent classes. By doing so, we can only access the methods and attributes defined by the data type, but any overriden methods will use the implementation from the child class.\nHere’s a quick example:\nsteve_student = new Student(\"Jones\", \"Steve\", \"19\", \"123456\", \"13\") # We can now treat steve_student as a Person object steve_person = steve_student print(steve_person.first_name) # We can call happy_birthday(), and it will use # the code from the Student class, even if we # think that steve_student is a Person object steve_person.happy_birthday() # We can still treat it as a Student object as well print(steve_person.grade_level) # 14 Polymorphism is a very powerful tool in programming, and we’ll use it throughout this course as we develop complex data structures.",
    "description": "We can also build classes that inherit attributes and methods from another class. This allows us to build more complex structures in our code, better representing the relationships between real world objects.\nInheritance in UML As we learned earlier in this chapter, we can represent an inheritance relationship with an open arrow in our UML diagrams, as shown below:\nIn this diagram, the Student class inherits from, or is a subclass of, the Person class.",
    "tags": [],
    "title": "Inheritance \u0026 Polymorphism",
    "uri": "/cc310/02-oop-review/12-polymorphism/"
  },
  {
    "breadcrumb": "Lists",
    "content": " An iterator is a set of operations a data structure provides to allow users to access the items in the data structure sequentially, without requiring them to know its underlying representation. There are many reasons users might want to access the data in a list. For instance, users may want to make a copy of their list or count the number of times a piece of data was stored in the list. Or, the user might want to delete all data from a list that matches a certain specification. All of these can be handled by the user using an iterator.\nAt a minimum, iterators have two operations: reset and getNext. Both of these operations use the list class’s current attribute to keep track of the iterator’s current node.\nReset The reset operation initializes or reinitializes the current pointer. It is typically used to ensure that the iterator starts at the beginning of the list. All that is required is for the current attribute be set to null.\nfunction reset() current = null end function Get Next The main operation of the iterator is the getNext operation. Basically, the getNext operation returns the next available node in the list if one is available. It returns null if the list is empty or if current is pointing at the last node in the list.\nLines 1 and 2 in the getNext operation check to see if we have an empty list, which results in returning the null value. If we have something in the list but current is null, this indicates that the reset operation has just been executed and we should return the data in the first node. Therefore, we set current = head in line 4. Otherwise, we set the current pointer to point to the next node in the list in line 5.\nfunction getNext() returns data if isEmpty()\t(1) return null\t(2) end if if current == null\t(3) current = head\t(4) else current = current.next\t(5) end if if current == null\t(6) return null\t(7) else return current.data\t(8) end if end function Next we return the appropriate data. If current == null we are at the end of the list and so we return the null value in line 7. If current is not equal to null, then it is pointing at a node in the list, so we simply return current.data in line 8.\nRemove current While not technically part of the basic iterator interface, the removeCurrent operation is an example of operations that can be provided to work hand-in-hand with a list iterator. The removeCurrent operation allows the user to utilize the iterator operations to find a specific piece of data in the list and then remove that data from the list. Other operations that might be provided include being able to replace the data in the current node, or even insert a new piece of data before or after the current node.\nThe removeCurrent operation starts by checking to make sure that current is really pointing at a node. If it is not, then the condition is caught in line 1 and an exception is raised in line 2. Next, we set the next pointer in the previous node to point to the current node’s next pointer in lines 3 – 5, taking into account whether the current node is the first node in the list. After that, we set the next node’s previous pointer to point back at the previous node in line 6 – 8, considering whether the node is the last node in the list. Finally, we decrement size in line 9.\nfunction removeCurrent() if current == null\t(1) raise exception\t(2) end if if current.previous != null\t(3) current.previous.next = current.next\t(4) else head = current.next\t(5) end if current.next != null\t(6) current.next.previous = current.previous\t(7) else tail = current.previous\t(8) end if current = current.previous (9) size – size – 1\t(10) end function Using an Iterator There are several applications for list iterators. For our example, we will use the case where we need a function to delete all instances of data in the list that match a given piece of data. Our deleteAll function resides outside the list class, so we will have to pass in the list we want to delete the data from. We start the operation by initializing the list iterator in line 1, followed by getting the first piece of data in the list in line 2. Next, we’ll enter a while loop and stay in that loop as long as our copy of the current node in the list, listData, is not null. When it becomes null, we are at the end of the list and we can exit the loop and the function.\nfunction deleteAll(list, data) list.reset()\t(1) listData = list.getNext()\t(2) while listData != null\t(3) if listData == data\t(4) list.removeCurrent()\t(5) end if\tlistData = list.getNext()\t(6) end while end function Once in the list, it’s a matter of checking if our listData is equal to the data we are trying to match. If it is, we call the list’s removeCurrent operation. Then, at the bottom of the list, we get the next piece of data from the list using the list iterator’s getNext operation.\nBy using a list iterator and a limited set of operations on the current data in the list, we can allow list users to manipulate the list while ensuring that the integrity of the list remains intact. Since we do not know ahead of time how a list will be used in a given application, an iterator with associated operations can allow the user to use the list in application-specific ways without having to add new operations to the list data structure.",
    "description": "An iterator is a set of operations a data structure provides to allow users to access the items in the data structure sequentially, without requiring them to know its underlying representation. There are many reasons users might want to access the data in a list. For instance, users may want to make a copy of their list or count the number of times a piece of data was stored in the list.",
    "tags": [],
    "title": "List Iterators",
    "uri": "/cc310/9-lists/12-list-iterators/"
  },
  {
    "breadcrumb": "Introduction",
    "content": "CC 310 - Data Structures \u0026 Algorithms I - Fall 2024 Previous Versions\nInstructor Contact Information Instructor: Russell Feldhausen (russfeld AT ksu DOT edu)\nI use he/him pronouns. Feel free to share your own pronouns with me, and I’ll do my best to use them! Office: DUE 2213, but I mostly work remotely from Kansas City, MO Phone: (785) 292-3121 (Call/Text) Website: https://russfeld.me Virtual Office Hours: By appointment via Zoom. Schedule a meeting at https://calendly.com/russfeld Preferred Methods of Communication: Email: Students should email cc310-help (cc310-help@KSUemailProd.onmicrosoft.com). We will try to respond within one business day. Ed Discussion: For short questions and discussions of course content and assignments, Ed Discussion is preferred since questions can be asked once and answered for all students. Students are encouraged to post questions there and use that space for discussion, and the instructor will strive to answer questions there as well. Phone/Text: Emergencies only! We will do our best to respond as quickly as we can. Prerequisites MATH 100 - College Algebra CC 210 - Fundamental Computer Programming Concepts Course Overview Exploration of data structures \u0026 related algorithms in computer programming. Basic concepts of complexity analysis. Object-oriented design concepts.\nCourse Description This course introduces simple data structures such as sets, lists, stacks, queues, and maps. Students learn how to create data structures and the algorithms that use them. Students are introduced to algorithm analysis to determine the efficiency of algorithms.\nMajor Course Topics Data Structures Sets Lists Stacks Queues Maps Algorithms Searching Sorting Structural Operations Hashing Set Relations Recursion Complexity Analysis Algorithm Design Strategies and Patterns Logic: Preconditions, Postconditions and Invariants Course Structure These courses are being taught 100% online, and each module is self-paced. There may be some bumps in the road as we refine the overall course structure. Students will work at their own pace through a set of modules, with approximately one module being due each week. Material will be provided in the form of recorded videos, online tutorials, links to online resources, and discussion prompts. Each module will include a coding project or assignment, many of which will be graded automatically through Codio. Assignments may also include portions which will be graded manually via Canvas or other tools.\nA common axiom in learner-centered teaching is “the person doing the work is the person doing the learning.” What this really means is that students primarily learn through grappling with the concepts and skills of a course while attempting to apply them. Simply seeing a demonstration or hearing a lecture by itself doesn’t do much in terms of learning. This is not to say that they don’t serve an important role - as they set the stage for the learning to come, helping you to recognize the core ideas to focus on as you work. The work itself consists of applying ideas, practicing skills, and putting the concepts into your own words.\nThe Work There is no shortcut to becoming a great programmer. Only by doing the work will you develop the skills and knowledge to make you a successful computer scientist. This course is built around that principle, and gives you ample opportunity to do the work, with as much support as we can offer.\nTutorials, Quizzes \u0026 Examples: Each module will include many tutorial assignments, quizzes, and examples that will take you step-by-step through using a particular concept or technique. The point is not simply to complete the example, but to practice the technique and coding involved. You will be expected to implement these techniques on your own in the milestone assignment of the module - so this practice helps prepare you for those assignments.\nProgramming Assignments: Throughout the semester you will be building several programming projects that explore the topics, data structures, and algorithms introduced in this class. Each programming project may include multiple tasks and an automated grading system.\nGrading In theory, each student begins the course with an A. As you submit work, you can either maintain your A (for good work) or chip away at it (for less adequate or incomplete work). In practice, each student starts with 0 points in the gradebook and works upward toward a final point total earned out of the possible number of points. In this course, each assignment constitutes a portion of the final grade, as detailed below:\n70% - Codio Programming Projects 30% - Codio Tutorials and Canvas Quizzes Up to 5% of the total grade in the class is available as extra credit. See the Extra Credit - Bug Bounty \u0026 Extra Credit - Helping Hands assignments for details.\nLetter grades will be assigned following the standard scale:\n90% - 100% → A 80% - 89.99% → B 70% - 79.99% → C 60% - 69.99% → D 00% - 59.99% → F Collaboration Policy In this course, all work submitted by a student should be created solely by the student without any outside assistance beyond the instructor and TA/GTAs. Students may seek outside help or tutoring regarding concepts presented in the course, but should not share or receive any answers, source code, program structure, or any other materials related to the course. Learning to debug coding problems is a vital skill, and students should strive to ask good questions and perform their own research instead of just sharing broken source code when asking for assistance.\nLate Work Warning Read this late work policy very carefully! If you are unsure how to interpret it, please contact the instructors via email. Not understanding the policy does not mean that it won’t apply to you!\nSince this course is entirely online, students may work at any time and at their own pace through the modules. However, to keep everyone on track, there will be approximately one module due each week. Each graded item in the module will have a specific due date specified. Any assignment submitted late will have that assignment’s grade reduced by 10% of the total possible points on that project for each day it is late. This penalty will be assessed automatically in the Canvas gradebook. For the purposes of record keeping, a combination of the time of a submission via Canvas and the creation of a release in GitHub will be used to determine if the assignment was submitted on time.\nHowever, even if a module is not submitted on time, it must still be completed before a student is allowed to begin the next module. So, students should take care not to get too far behind, as it may be very difficult to catch up.\nFinally, all course work must be submitted on or before the last day of the semester in which the student is enrolled in the course in order for it to be graded on time.\nIf you have extenuating circumstances, please discuss them with the instructor as soon as they arise so other arrangements can be made. If you find that you are getting behind in the class, you are encouraged to speak to the instructor for options to make up missed work.\nIncomplete Policy Students should strive to complete this course in its entirety before the end of the semester in which they are enrolled. However, since retaking the course would be costly and repetitive for students, we would like to give students a chance to succeed with a little help rather than immediately fail students who are struggling.\nIf you are unable to complete the course in a timely manner, please contact the instructor to discuss an incomplete grade. Incomplete grades are given solely at the instructor’s discretion. See the official K-State Grading Policy for more information. In general, poor time management alone is not a sufficient reason for an incomplete grade.\nUnless otherwise noted in writing on a signed Incomplete Agreement Form, the following stipulations apply to any incomplete grades given in Computational Core courses:\nStudents may receive at most two incompletes in Computational Core courses throughout their time in the program Students will be given 6 calendar weeks from the end of the enrolled semester’s finals week to complete the course Any modules in a future CC course which depend on incomplete work will not be accessible until the previous course is finished For example, if a student is given an incomplete in CC 210, then all modules in CC 310 will be inaccessible until CC 210 is complete Students understand that access to instructor and GTA assistance may be limited after the end of an academic semester due to holidays and other obligations If a student fails to resolve an incomplete grade after 6 weeks, they will be assigned an ‘F’ in the course. In addition, they will be dropped from any other Computational Core courses which require the failed course as a prerequisite or corequisite. Recommended Texts \u0026 Supplies To participate in this course, students must have access to a modern web browser and broadband internet connection. All course materials will be provided via Canvas and Codio. Modules may also contain links to external resources for additional information, such as programming language documentation.\nStudents will make use of GitHub or GitLab for source code management.\nStudents may choose to do some development work on their own computer. The recommended software is Visual Studio Code along with access to a system running Ubuntu. For Windows systems, Ubuntu can be installed via the Windows Subsystem for Linux. For Mac systems, Ubuntu can be installed in a virtual machine through VirtualBox.\nSubject to Change The details in this syllabus are not set in stone. Due to the flexible nature of this class, adjustments may need to be made as the semester progresses, though they will be kept to a minimum. If any changes occur, the changes will be posted on the Canvas page for this course and emailed to all students. All changes may also be posted to Canvas.\nStandard Syllabus Statements Info The statements below are standard syllabus statements from K-State and our program. The latest versions are available online here.\nAcademic Honesty Kansas State University has an Honor and Integrity System based on personal integrity, which is presumed to be sufficient assurance that, in academic matters, one’s work is performed honestly and without unauthorized assistance. Undergraduate and graduate students, by registration, acknowledge the jurisdiction of the Honor and Integrity System. The policies and procedures of the Honor and Integrity System apply to all full and part-time students enrolled in undergraduate and graduate courses on-campus, off-campus, and via distance learning. A component vital to the Honor and Integrity System is the inclusion of the Honor Pledge which applies to all assignments, examinations, or other course work undertaken by students. The Honor Pledge is implied, whether or not it is stated: “On my honor, as a student, I have neither given nor received unauthorized aid on this academic work.” A grade of XF can result from a breach of academic honesty. The F indicates failure in the course; the X indicates the reason is an Honor Pledge violation.\nFor this course, a violation of the Honor Pledge will result in sanctions such as a 0 on the assignment or an XF in the course, depending on severity. Actively seeking unauthorized aid, such as posting lab assignments on sites such as Chegg or StackOverflow, or asking another person to complete your work, even if unsuccessful, will result in an immediate XF in the course.\nThis course assumes that all your course work will be done by you. Use of AI text and code generators such as ChatGPT and GitHub Copilot in any submission for this course is strictly forbidden unless explicitly allowed by your instructor. Any unauthorized use of these tools without proper attribution is a violation of the K-State Honor Pledge.\nWe reserve the right to use various platforms that can perform automatic plagiarism detection by tracking changes made to files and comparing submitted projects against other students’ submissions and known solutions. That information may be used to determine if plagiarism has taken place.\nStudents with Disabilities At K-State it is important that every student has access to course content and the means to demonstrate course mastery. Students with disabilities may benefit from services including accommodations provided by the Student Access Center. Disabilities can include physical, learning, executive functions, and mental health. You may register at the Student Access Center or to learn more contact:\nManhattan/Olathe/Global Campus – Student Access Center accesscenter@k-state.edu 785-532-6441 K-State Salina Campus – Julie Rowe; Student Success Coordinator jarowe@k-state.edu 785-820-7908 Students already registered with the Student Access Center please request your Letters of Accommodation early in the semester to provide adequate time to arrange your approved academic accommodations. Once SAC approves your Letter of Accommodation it will be e-mailed to you, and your instructor(s) for this course. Please follow up with your instructor to discuss how best to implement the approved accommodations.\nExpectations for Conduct All student activities in the University, including this course, are governed by the Student Judicial Conduct Code as outlined in the Student Governing Association By Laws, Article V, Section 3, number 2. Students who engage in behavior that disrupts the learning environment may be asked to leave the class.\nMutual Respect and Inclusion in K-State Teaching \u0026 Learning Spaces At K-State, faculty and staff are committed to creating and maintaining an inclusive and supportive learning environment for students from diverse backgrounds and perspectives. K-State courses, labs, and other virtual and physical learning spaces promote equitable opportunity to learn, participate, contribute, and succeed, regardless of age, race, color, ethnicity, nationality, genetic information, ancestry, disability, socioeconomic status, military or veteran status, immigration status, Indigenous identity, gender identity, gender expression, sexuality, religion, culture, as well as other social identities.\nFaculty and staff are committed to promoting equity and believe the success of an inclusive learning environment relies on the participation, support, and understanding of all students. Students are encouraged to share their views and lived experiences as they relate to the course or their course experience, while recognizing they are doing so in a learning environment in which all are expected to engage with respect to honor the rights, safety, and dignity of others in keeping with the K-State Principles of Community.\nIf you feel uncomfortable because of comments or behavior encountered in this class, you may bring it to the attention of your instructor, advisors, and/or mentors. If you have questions about how to proceed with a confidential process to resolve concerns, please contact the Student Ombudsperson Office. Violations of the student code of conduct can be reported using the Code of Conduct Reporting Form. You can also report discrimination, harassment or sexual harassment, if needed.\nNetiquette Info This is our personal policy and not a required syllabus statement from K-State. It has been adapted from this statement from K-State Global Campus, and theRecurse Center Manual. We have adapted their ideas to fit this course.\nOnline communication is inherently different than in-person communication. When speaking in person, many times we can take advantage of the context and body language of the person speaking to better understand what the speaker means, not just what is said. This information is not present when communicating online, so we must be much more careful about what we say and how we say it in order to get our meaning across.\nHere are a few general rules to help us all communicate online in this course, especially while using tools such as Canvas or Discord:\nUse a clear and meaningful subject line to announce your topic. Subject lines such as “Question” or “Problem” are not helpful. Subjects such as “Logic Question in Project 5, Part 1 in Java” or “Unexpected Exception when Opening Text File in Python” give plenty of information about your topic. Use only one topic per message. If you have multiple topics, post multiple messages so each one can be discussed independently. Be thorough, concise, and to the point. Ideally, each message should be a page or less. Include exact error messages, code snippets, or screenshots, as well as any previous steps taken to fix the problem. It is much easier to solve a problem when the exact error message or screenshot is provided. If we know what you’ve tried so far, we can get to the root cause of the issue more quickly. Consider carefully what you write before you post it. Once a message is posted, it becomes part of the permanent record of the course and can easily be found by others. If you are lost, don’t know an answer, or don’t understand something, speak up! Email and Canvas both allow you to send a message privately to the instructors, so other students won’t see that you asked a question. Don’t be afraid to ask questions anytime, as you can choose to do so without any fear of being identified by your fellow students. Class discussions are confidential. Do not share information from the course with anyone outside of the course without explicit permission. Do not quote entire message chains; only include the relevant parts. When replying to a previous message, only quote the relevant lines in your response. Do not use all caps. It makes it look like you are shouting. Use appropriate text markup (bold, italics, etc.) to highlight a point if needed. No feigning surprise. If someone asks a question, saying things like “I can’t believe you don’t know that!” are not helpful, and only serve to make that person feel bad. No “well-actually’s.” If someone makes a statement that is not entirely correct, resist the urge to offer a “well, actually…” correction, especially if it is not relevant to the discussion. If you can help solve their problem, feel free to provide correct information, but don’t post a correction just for the sake of being correct. Do not correct someone’s grammar or spelling. Again, it is not helpful, and only serves to make that person feel bad. If there is a genuine mistake that may affect the meaning of the post, please contact the person privately or let the instructors know privately so it can be resolved. Avoid subtle -isms and microaggressions. Avoid comments that could make others feel uncomfortable based on their personal identity. See the syllabus section on Diversity and Inclusion above for more information on this topic. If a comment makes you uncomfortable, please contact the instructor. Avoid sarcasm, flaming, advertisements, lingo, trolling, doxxing, and other bad online habits. They have no place in an academic environment. Tasteful humor is fine, but sarcasm can be misunderstood. As a participant in course discussions, you should also strive to honor the diversity of your classmates by adhering to the K-State Principles of Community.\nSafeZone Ally I am part of the SafeZone community network of trained K-State faculty/staff/students who are available to listen and support you. As a SafeZone Ally, I can help you connect with resources on campus to address problems you face that interfere with your academic success, particularly issues of sexual violence, hateful acts, or concerns faced by individuals due to sexual orientation/gender identity. My goal is to help you be successful and to maintain a safe and equitable campus.\nDiscrimination, Harassment, and Sexual Harassment Kansas State University is committed to maintaining academic, housing, and work environments that are free of discrimination, harassment, and sexual harassment. Instructors support the University’s commitment by creating a safe learning environment during this course, free of conduct that would interfere with your academic opportunities. Instructors also have a duty to report any behavior they become aware of that potentially violates the University’s policy prohibiting discrimination, harassment, and sexual harassment, as outlined by PPM 3010.\nIf a student is subjected to discrimination, harassment, or sexual harassment, they are encouraged to make a non-confidential report to the University’s Office for Institutional Equity (OIE) using the online reporting form. Incident disclosure is not required to receive resources at K-State. Reports that include domestic and dating violence, sexual assault, or stalking, should be considered for reporting by the complainant to the Kansas State University Police Department or the Riley County Police Department. Reports made to law enforcement are separate from reports made to OIE. A complainant can choose to report to one or both entities. Confidential support and advocacy can be found with the K-State Center for Advocacy, Response, and Education (CARE). Confidential mental health services can be found with Lafene Counseling and Psychological Services (CAPS). Academic support can be found with the Office of Student Life (OSL). OSL is a non-confidential resource. OIE also provides a comprehensive list of resources on their website. If you have questions about non-confidential and confidential resources, please contact OIE at equity@ksu.edu or (785) 532–6220.\nAcademic Freedom Statement Kansas State University is a community of students, faculty, and staff who work together to discover new knowledge, create new ideas, and share the results of their scholarly inquiry with the wider public. Although new ideas or research results may be controversial or challenge established views, the health and growth of any society requires frank intellectual exchange. Academic freedom protects this type of free exchange and is thus essential to any university’s mission.\nMoreover, academic freedom supports collaborative work in the pursuit of truth and the dissemination of knowledge in an environment of inquiry, respectful debate, and professionalism. Academic freedom is not limited to the classroom or to scientific and scholarly research, but extends to the life of the university as well as to larger social and political questions. It is the right and responsibility of the university community to engage with such issues.\nCampus Safety Kansas State University is committed to providing a safe teaching and learning environment for student and faculty members. In order to enhance your safety in the unlikely case of a campus emergency make sure that you know where and how to quickly exit your classroom and how to follow any emergency directives. Current Campus Emergency Information is available at the University’s Advisory webpage.\nWeapons Policy Kansas State University prohibits the possession of firearms, explosives, and other weapons on any University campus, with certain limited exceptions, including the lawful concealed carrying of handguns, as provided in the University Weapons Policy.\nYou are encouraged to take the online weapons policy education module to ensure you understand the requirements of the policy, including the requirements related to concealed carrying of handguns on campus. Students possessing a concealed handgun on campus must be lawfully eligible to carry and either at least 21 years of age or a licensed individual who is 18-21 years of age. All carrying requirements of the policy must be observed in this class, including but not limited to the requirement that a concealed handgun be completely hidden from view, securely held in a holster that meets the specifications of the policy, carried without a chambered round of ammunition, and that any external safety be in the “on” position.\nIf an individual carries a concealed handgun in a personal carrier such as a backpack, purse, or handbag, the carrier must remain within the individual’s exclusive and uninterrupted control. This includes wearing the carrier with a strap, carrying or holding the carrier, or setting the carrier next to or within the immediate reach of the individual.\nDuring this course, you will be required to engage in activities, such as interactive examples or sharing work on the whiteboard, that may require you to separate from your belongings, and thus you should plan accordingly.\nEach individual who lawfully possesses a handgun on campus shall be wholly and solely responsible for carrying, storing and using that handgun in a safe manner and in accordance with the law, Board policy and University policy. All reports of suspected violation of the weapons policy are made to the University Police Department by picking up any Emergency Campus Phone or by calling 785-532-6412.\nStudent Resources K-State has many resources to help contribute to student success. These resources include accommodations for academics, paying for college, student life, health and safety, and others. Check out the Student Guide to Help and Resources: One Stop Shop for more information.\nStudent Academic Creations Student academic creations are subject to Kansas State University and Kansas Board of Regents Intellectual Property Policies. For courses in which students will be creating intellectual property, the K-State policy can be found at University Handbook, Appendix R: Intellectual Property Policy and Institutional Procedures (part I.E.). These policies address ownership and use of student academic creations.\nMental Health Your mental health and good relationships are vital to your overall well-being. Symptoms of mental health issues may include excessive sadness or worry, thoughts of death or self-harm, inability to concentrate, lack of motivation, or substance abuse. Although problems can occur anytime for anyone, you should pay extra attention to your mental health if you are feeling academic or financial stress, discrimination, or have experienced a traumatic event, such as loss of a friend or family member, sexual assault or other physical or emotional abuse.\nIf you are struggling with these issues, do not wait to seek assistance.\nKansas State University Counseling and Psychological Services offers free and confidential services to assist you to meet these challenges. Lafene Health Center has specialized nurse practitioners to assist with mental health. The Office of Student Life can direct you to additional resources. K-State Family Center offers individual, couple, and family counseling services on a sliding fee scale. Center for Advocacy, Response, and Education (CARE) provides free and confidential assistance for those in our K-State community who have been victimized by violence. For Kansas State Salina Campus:\nKansas State Salina Counseling Services offers free and confidential services to assist you to meet these challenges. The Kansas State Salina Office of Student Life can direct you to additional resources. The Kansas State Salina Campus offers several services for students, including health services, counseling, and academic assistance. For Global Campus/K-State Online:\nK-State Online students have free access to mental health counseling with My SSP - 24/7 support via chat and phone. The Office of Student Life can direct you to additional resources. University Excused Absences K-State has a University Excused Absence policy (Section F62). Class absence(s) will be handled between the instructor and the student unless there are other university offices involved. For university excused absences, instructors shall provide the student the opportunity to make up missed assignments, activities, and/or attendance specific points that contribute to the course grade, unless they decide to excuse those missed assignments from the student’s course grade. Please see the policy for a complete list of university excused absences and how to obtain one. Students are encouraged to contact their instructor regarding their absences.\nCopyright Notice © The materials in this online course fall under the protection of all intellectual property, copyright and trademark laws of the U.S. The digital materials included here come with the legal permissions and releases of the copyright holders. These course materials should be used for educational purposes only; the contents should not be distributed electronically or otherwise beyond the confines of this online course. The URLs listed here do not suggest endorsement of either the site owners or the contents found at the sites. Likewise, mentioned brands (products and services) do not suggest endorsement. Students own copyright to what they create.",
    "description": "CC 310 - Data Structures \u0026 Algorithms I - Fall 2024 Previous Versions\nInstructor Contact Information Instructor: Russell Feldhausen (russfeld AT ksu DOT edu)\nI use he/him pronouns. Feel free to share your own pronouns with me, and I’ll do my best to use them! Office: DUE 2213, but I mostly work remotely from Kansas City, MO Phone: (785) 292-3121 (Call/Text) Website: https://russfeld.me Virtual Office Hours: By appointment via Zoom. Schedule a meeting at https://calendly.",
    "tags": [],
    "title": "Spring 2024 Syllabus",
    "uri": "/cc310/00-introduction/06-syllabus/"
  },
  {
    "breadcrumb": "Python Review",
    "content": " Strings are another very important data type in programming. A string is simply a set of characters that represent text in our programs. We can then write programs that use and manipulate strings in a variety of ways, allowing us to easily work with textual data.\nStrings in Flowcharts \u0026 Pseudocode The table below lists the flowchart blocks used to represent strings, as well as the corresponding pseudocode:\nOperation Flowchart Pseudocode Create String STR = “abc” Access Character C = STR[0] String Length X = size of STR Strings in Python Let’s review the syntax for working with strings in Python.\nString Creation Strings in Python are declared just like any other variable:\ns = \"abc123\" Notice that strings are enclosed in double quotations marks \". Since Python does not have a data type for a single character, we can do the same for single character strings as well:\nc = \"a\" There are several special characters we can include in our strings. Here are a few of the more common ones:\n\\' - Single Quotation Mark (usually not required) \\\" - Double Quotation Mark \\n - New Line \\t - Tab String Parsing Most of the time, we will need to be able to parse strings in order to read input from the user. This is easily done using Python. Let’s refer to the skeleton code given in an exercise:\n# Load required modules import sys def main(argv): # create a file reader for terminal input reader = sys.stdin # read a single integer from the terminal x = int(reader.readline()) # -=-=-=-=- MORE CODE GOES HERE -=-=-=-=- # main guard if __name__ == \"__main__\": main(sys.argv) This code will initialize a variable called reader to read input from the terminal, or sys.stdin in Python.\nOnce we have a reader initialized, we can read a line of data from the input as follows:\nline = reader.readline() If we know that line will contain a single item of a different data type, such as an integer, we can also convert that input using the appropriate method:\nx = int(reader.readline()) Finally, if we have read an entire string of input consisting of multiple parts, we can use the split method to split the string in to tokens that are separated by a special delimiter. When we do this, we’ll have to use special methods to convert the strings to other primitive data types. Here’s an example:\nline = \"This 1 is 2.0 true\" parts = line.split(\" \") first = parts[0] second = int(parts[1]) third = parts[2] fourth = float(parts[3]) fifth = bool(parts[4]) In this example, we are able to split the first string variable into $5$ parts, each one separated by a space in the original string. Then, we can use methods such as int() to convert each individual string token into the desired data type.\nReading Input in a Loop When reading an unknown number of lines of input, we can use a loop in Python such as the following example:\nfor line in reader: line = line.strip() if not line or len(line) == 0: break # parse the input This will read input until either a blank line is received (usually via the terminal), or there is no more input available to read (from a file).\nString Operations There are also several operations we can perform on strings in Python:\ns1 = \"This\" s2 = \"That\" # string length x = len(s1) # string comparison # can use standard comparison operators b1 = s1 == s2 b2 = s1 \u003c s2 # concatenation s3 = s1 + \" \" + s2 Additional methods can be found on the Python Built-In Types: str and Python Common String Operations pages\nString Formatting Strings can also be used to create formatted output in Python through the use of f-strings. Here’s a short example:\nsum = 123 avg = 1.23 name = \"Student\" print(f\"{name}: Your score is {sum} with an average of {avg}.\") When we run this program, the output will be:\nStudent: Your score is 123 with an average of 1.23. Each item in the formatted output can also be given additional attributes such as width and precision. More details can be found on the Python Format String Syntax page.\nReferences Python Built-In Types: str Python Common String Operations Python Format String Syntax ",
    "description": "Strings are another very important data type in programming. A string is simply a set of characters that represent text in our programs. We can then write programs that use and manipulate strings in a variety of ways, allowing us to easily work with textual data.\nStrings in Flowcharts \u0026 Pseudocode The table below lists the flowchart blocks used to represent strings, as well as the corresponding pseudocode:\nOperation Flowchart Pseudocode Create String STR = “abc” Access Character C = STR[0] String Length X = size of STR Strings in Python Let’s review the syntax for working with strings in Python.",
    "tags": [],
    "title": "Strings",
    "uri": "/cc310/01-review/11-strings/"
  },
  {
    "breadcrumb": "Performance",
    "content": "In this module, we reviewed each of the data structures we have explored in this class. Most importantly, we looked at how they compare in terms of performance and discussed some of the best and most efficient ways to use them in our programs.\nUsing that information, we introduced the standard collection libraries for both Java and Python, and saw how those professional implementations closely follow the same ideas and analysis that we saw in our own structures. While the professional structures may have many more features and more complex code, at the core they still work just like the structures we learned how to build from scratch.\nOne of the best traits of a good programmer is knowing how to most effectively use the tools made available to us through the programming languages and libraries we have chosen to use. The goal of this class is to give us the background we need to understand how the various collection data structures we can choose from work, so that we can use them in the most effective way to build useful and efficient programs.",
    "description": "In this module, we reviewed each of the data structures we have explored in this class. Most importantly, we looked at how they compare in terms of performance and discussed some of the best and most efficient ways to use them in our programs.\nUsing that information, we introduced the standard collection libraries for both Java and Python, and saw how those professional implementations closely follow the same ideas and analysis that we saw in our own structures.",
    "tags": [],
    "title": "Summary",
    "uri": "/cc310/12-performance/12-summary/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome! This page is the main page for Hold for CC 410",
    "description": "Welcome! This page is the main page for Hold for CC 410",
    "tags": [],
    "title": "Hold for CC 410",
    "uri": "/cc310/13-hold-for-cc-410/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "To describe our bubble algorithm, we can start with these basic preconditions and postconditions.\nPreconditions:\nThe array stores a type of elements which can be ordered. Postconditions:\nThe array will be sorted in ascending order. We can then represent this algorithm using the following pseudocode.\nfunction BUBBLESORT(ARRAY)\t(1) # loop through the array multiple times loop INDEX from 0 to size of ARRAY – 1\t(2) # consider every pair of elements except the sorted ones loop INDEX2 from 0 to size of ARRAY – 2 – INDEX\t(3) if ARRAY[INDEX2] \u003e ARRAY[INDEX2 + 1] then\t(4) # swap elements if they are out of order TEMP = ARRAY[INDEX2]\t(5) ARRAY[INDEX2] = ARRAY[INDEX2 + 1]\t(6) ARRAY[INDEX2 + 1] = TEMP\t(7) end if end loop end loop end functionIn this code, we begin by looping through every element in the array, as seen on line 2. Each time we run this outer loop, we’ll lock one additional element in place at the end of the array. Therefore, we need to run it once for each element in the array.\nOn line 3, we’ll start at the beginning of the array and loop to the place where the sorted portion of the array begins. We know that after each iteration of the outer loop, the value index will represent the number of locked elements at the end of the array. We can subtract that value from the end of the array to find where we want to stop.\nLine 4 is a comparison between two adjacent elements in the array starting at the index index2. If they are out of order, we use lines 5 through 7 to swap them. That’s really all it takes to do a bubble sort!\nLooking at this code, we can describe the invariant of our outer loop as follows:\nThe last index elements in the array are in sorted order, and The elements in the array have not changed, only their positions. Notice how this differs from selection sort, since it places the sorted elements at the beginning of the array instead of the end. However, the result is the same, and by the end of the program we can show that each algorithm has fully sorted the array.",
    "description": "To describe our bubble algorithm, we can start with these basic preconditions and postconditions.\nPreconditions:\nThe array stores a type of elements which can be ordered. Postconditions:\nThe array will be sorted in ascending order. We can then represent this algorithm using the following pseudocode.\nfunction BUBBLESORT(ARRAY)\t(1) # loop through the array multiple times loop INDEX from 0 to size of ARRAY – 1\t(2) # consider every pair of elements except the sorted ones loop INDEX2 from 0 to size of ARRAY – 2 – INDEX\t(3) if ARRAY[INDEX2] \u003e ARRAY[INDEX2 + 1] then\t(4) # swap elements if they are out of order TEMP = ARRAY[INDEX2]\t(5) ARRAY[INDEX2] = ARRAY[INDEX2 + 1]\t(6) ARRAY[INDEX2 + 1] = TEMP\t(7) end if end loop end loop end functionIn this code, we begin by looping through every element in the array, as seen on line 2.",
    "tags": [],
    "title": "Bubble Sort Pseudocode",
    "uri": "/cc310/7-searching-and-sorting/13-bubble-sort-pseudocode/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "The next most common algorithmic technique is divide and conquer. A divide and conquer algorithm works just like it sounds. First, it will divide the problem into at least two or more smaller problems, and then it will try to solve each of those problems individually. It might even try to subdivide those smaller problems again and again to finally get to a small enough problem that it is easy to solve.\nA great real-world example of using a divide and conquer approach to solving a problem is when we need to look for something that we’ve lost around the house. Instead of trying to search the entire house, we can subdivide the problem into smaller parts by looking in each room separately. Then, within each room, we can even further subdivide the problem by looking at each piece of furniture individually. By reducing the problem’s size and complexity, it becomes easier to search through each individual piece of furniture in the house, either finding our lost object or eliminating that area as the likely location it will be found.\nExample - Binary Search One great example of a divide and conquer algorithm is the binary search algorithm. If we have a list of data that has already been sorted, as seen in the figure above, we can easily find any item in the list using a divide and conquer process.\nFor example, let’s say we want to find the value $19$ in that list. First, we can look at the item in the middle of the list, which is $23$. Is it our desired number? Unfortunately, it is not. So, we need to figure out how we can use it to divide our input into a smaller problem. Thankfully, we know the list is sorted, so we can use that to our advantage. If our desired number is less than the middle number, we know that it must exist in the first half of the list. Likewise, if it is greater than the middle number, it must be in the second half. In this case, since $19$ is less than $23$, we must only look at the first half of the list.\nNow we can just repeat that process, this time using only the first half of the original list. This is the powerful feature of a divide and conquer algorithm. Once we’ve figured out how to divide our data, we can usually follow the same steps again to solve the smaller problems as well.\nOnce again, we ask ourselves if $12$, the centermost number in the list, is the one we are looking for. Once again, it is not, but we know that $19$ is greater than $12$, so we’ll need to look in the second half of the list.\nFinally, we have reduced our problem to the simplest, or base case of the problem. Here, we simply need to determine if the single item in the list is the number we are looking for. In this case, it is! So, we can return that our original list did indeed include the number $19$.\nWe’ll explore many ways of using divide and conquer algorithms in this course, especially when we learn to sort and search through lists of values.",
    "description": "The next most common algorithmic technique is divide and conquer. A divide and conquer algorithm works just like it sounds. First, it will divide the problem into at least two or more smaller problems, and then it will try to solve each of those problems individually. It might even try to subdivide those smaller problems again and again to finally get to a small enough problem that it is easy to solve.",
    "tags": [],
    "title": "Divide and Conquer",
    "uri": "/cc310/03-intro-dsa/13-divide-conquer/"
  },
  {
    "breadcrumb": "Python Review",
    "content": " An exception is an error that a program encounters when it is running. While some errors cannot be dealt with directly by the program, many of these exceptions can be caught and handled directly in our programs.\nExceptions in Flowcharts \u0026 Pseudocode There isn’t really a standard way to display exceptions in flowcharts and pseudocode, but we can easily create a system that works well for our needs. Below are the flowchart blocks and pseudocode examples we’ll use in this course to represent exceptions and exception handling:\nOperation Flowchart Pseudocode Throw Exception throw INPUT EXCEPTION Catch Exception catch INPUT EXCEPTION Try-Catch Example X = 0\ntry\ninput X\nif X \u003c 0\nthrow INPUT EXCEPTION\nend if\nprint X\ncatch INPUT EXCEPTION\nprint “Error”\nend try Exceptions in Python Let’s review the syntax for working with exceptions in Python.\nTry-Catch In Python, we can use a Try-Except statement to detect and handle exceptions in our code:\n# Load required modules import sys try: reader = open(sys.argv[1]) x = int(reader.readline()) print(x) except Exception as e: print(\"Error!\") In this example, the program will try to open a file using the first command-line argument as a file name. There are several exceptions that could occur in this code, such as a ValueError, a IndexError, a FileNotFoundError, and more. They can also be handled individually:\n# Load required modules import sys try: reader = open(sys.argv[1]) x = int(reader.readline()) print(x) except IndexError as e: print(\"Error: Invalid Array Index!\") except FileNotFoundError as e: print(\"Error: File Not Found!\") except ValueError as e: print(\"Error: Input Does Not Match Expected Format!\") except OSError as e: print(\"Error: OS Exception!\") Throw If desired, we can also raise our own exceptions in Python:\nif y == 0: raise ValueError(\"Cannot divide by zero\") else: z = x / y print(z) This will cause an exception to be thrown if the value of y is equal to $0.0$.\nFinally We can also add Else and Finally blocks at the end of each Try-Except block. A Finally block will be executed whenever the control exits the Try-Except block, even through the use of a return statement to return from a method. The Else block will be executed if the entire Try-Except block completes without any exceptions being raised:\n# Load required modules import sys try: reader = open(sys.argv[1]) x = int(reader.readline()) print(x) except Exception as e: print(\"Error!\") else: print(\"No Errors!\") finally: print(\"Finally Block\") With Statement When working with resources such as files in Python, we can also use a With block to ensure that those resources are properly closed when we are done with them. In addition, a With block will automatically catch and suppress any exceptions that result from trying to close the resource after an exception has occurred, preventing us from being bombarded by unavoidable exceptions. Here’s an example:\nimport sys try: with open(sys.argv[1]) as reader: x = int(reader.readline()) print(x) except IndexError as e: print(\"Error: Invalid Array Index!\") except ValueError as e: print(\"ValueError: {}\".format(e)) except FileNotFoundError as e: print(\"FileNotFoundError: {}\".format(e)) In this example, we are opening a file using the open() method inside of the With statement. That file will automatically be closed once the program leaves the With statement.\nReferences Built-in Exceptions Tutorial: Errors and Exceptions Python Exception Hierarchy ",
    "description": "An exception is an error that a program encounters when it is running. While some errors cannot be dealt with directly by the program, many of these exceptions can be caught and handled directly in our programs.\nExceptions in Flowcharts \u0026 Pseudocode There isn’t really a standard way to display exceptions in flowcharts and pseudocode, but we can easily create a system that works well for our needs. Below are the flowchart blocks and pseudocode examples we’ll use in this course to represent exceptions and exception handling:",
    "tags": [],
    "title": "Exceptions",
    "uri": "/cc310/01-review/12-exceptions/"
  },
  {
    "breadcrumb": "Lists",
    "content": " Implementing a queue with a doubly linked list is straightforward and efficient. The core queue operations (enqueue, dequeue, isEmpty, and peek) can all be implemented by directly calling list operations that run in constant time. The only other major operation is the toString operation, which is also implemented by directly calling the list toString operation; however, it runs in order $N$ time due to the fact that the list toString operation must iterate through each item in the list.\nThe key queue operations and their list-based implementations are shown below.\nOperation Implementation enqueue function enqueue (data)\nlist.append(data)\nend function dequeue function dequeue() returns data\nreturn removeFirst()\nend function isEmpty function isEmpty() returns Boolean\nreturn list.isEmpty()\nend function peek function peek() returns data\nreturn list.peek()\nend function toString function toString() returns data\nreturn list.toString()\nend function ",
    "description": "Implementing a queue with a doubly linked list is straightforward and efficient. The core queue operations (enqueue, dequeue, isEmpty, and peek) can all be implemented by directly calling list operations that run in constant time. The only other major operation is the toString operation, which is also implemented by directly calling the list toString operation; however, it runs in order $N$ time due to the fact that the list toString operation must iterate through each item in the list.",
    "tags": [],
    "title": "List-Based Queues",
    "uri": "/cc310/9-lists/13-list-based-queues/"
  },
  {
    "breadcrumb": "Programming by Contract and Introduction to Performance",
    "content": "In this module, we covered two major topics that will help us understand the data structures and algorithms we’ll learn in this course. First, we learned about the use of preconditions, postconditions, and loop invariants to help describe the exact specifications of how methods and loops should operate in code. We’ll use these as the basis of unit tests in this course to help prove the correctness of data structures and algorithms we are asked to develop throughout the course.\nIn addition, we were introduced to the concepts of time complexity, space complexity, and code complexity, three ways to measure the performance and usefulness of a computer program. We also learned that it may be difficult to find a perfect program that has very little time, space, and code complexity, so many times we’ll have to consider a trade-off between programs that operate quickly, use less memory, and are easier to understand.\nWhich these tools, we’re in a much better place to understand the specifics of the data structures and algorithms we’ll encounter in this module. Next, we’ll do a short project to explore how we can build programs based on a set of preconditions, postconditions, and invariants instead of the plain language descriptions we’ve used up to this point.",
    "description": "In this module, we covered two major topics that will help us understand the data structures and algorithms we’ll learn in this course. First, we learned about the use of preconditions, postconditions, and loop invariants to help describe the exact specifications of how methods and loops should operate in code. We’ll use these as the basis of unit tests in this course to help prove the correctness of data structures and algorithms we are asked to develop throughout the course.",
    "tags": [],
    "title": "Programming by Contract and Performance Summary",
    "uri": "/cc310/3-programming-by-contract-and-introduction-to-performance/13-programming-by-contract-and-performance-summary/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": "Static Many programming languages include a special keyword static. In essence, a static attribute or method is part of the class in which it is declared instead of part of objects instantiated from that class. If we think about it, the word static means “lacking in change”, and that’s sort of a good way to think about it.\nIn a UML diagram, static attributes and methods are denoted by underlining them.\nStatic Attributes In Python, any attributes declared outside of a method are class attributes, but they can be considered the same as static attributes until they are overwritten by an instance. Here’s an example:\nclass Stat: x = 5 # class or static attribute def __init__(self, an_y): self.y = an_y # instance attribute In this class, we’ve created a class attribute named x, and a normal attribute named y. Here’s a main() method that will help us explore how the static keyword operates:\nfrom Stat import * class Main: def main(): some_stat = Stat(7) another_stat = Stat(8) print(some_stat.x) # 5 print(some_stat.y) # 7 print(another_stat.x) # 5 print(another_stat.y) # 8 Stat.x = 25 # change class attribute for all instances print(some_stat.x) # 25 print(some_stat.y) # 7 print(another_stat.x) # 25 print(another_stat.y) # 8 some_stat.x = 10 # overwrites class attribute in instance print(some_stat.x) # 10 (now an instance attribute) print(some_stat.y) # 7 print(another_stat.x) # 25 (still class attribute) print(another_stat.y) # 8 if __name__ == \"__main__\": Main.main() First, we can see that the attribute x is set to 5 as its default value, so both objects some_stat and another_stat contain that same value. Interestingly, since the attribute x is static, we can access it directly from the class Stat, without even having to instantiate an object. So, we can update the value in that way to 25, and it will take effect in any objects instantiated from Stat.\nBelow that, we can update the value of x attached to some_stat to 10, and we’ll see that it now creates an instance attribute for that object that contains 10, overwriting the previous class attribute. The value attached to another_stat is unchanged.\nStatic Methods Python also allows us to create static methods that work in a similar way:\nclass Stat: x = 5 # class or static attribute def __init__(self, an_y): self.y = an_y # instance attribute @staticmethod def sum(a): return Stat.x + a We have now added a static method sum() to our Stat class. To create a static method, we place the @staticmethod decorator above the method declaration. We haven’t learned about decorators yet, but they allow us to tell Python some important information about the code below the decorator.\nIn addition, it is important to remember that a static method cannot access any non-static attributes or methods, since it doesn’t have access to an instantiated object in the self parameter.\nAs a tradeoff, we can call a static method without instantiating the class either, as in this example:\nfrom Stat import * class Main: @staticmethod def main(): # other code omitted Stat.x = 25 moreStat = Stat(7) print(moreStat.sum(5)) # 30 print(Stat.sum(5)) # 30 if __name__ == \"__main__\": Main.main() This becomes extremely useful in our main() method. Since we aren’t instantiating our Main class, we can use the decorator @staticmethod above the method to clearly mark that it should be considered a static method.\nAbstract Another major feature of class inheritance is the ability to define a method in a parent class, but not provide any code that implements that function. In effect, we are saying that all objects of that type must include that method, but it is up to the child classes to provide the code. These methods are called abstract methods, and the classes that contain them are abstract classes. Let’s look at how they work!\nAbstract in Python In the UML diagram above, we see that the describe() method in the Vehicle class is printed in italics. That means that the method should be abstract, without any code provided. To do this in Python, we simply inherit from a special class called ABC, short for “Abstract Base Class,” and then use the @abstractmethod decorator:\nfrom abc import ABC, abstractmethod class Vehicle(ABC): def __init__(self, name): self.__name = name self._speed = 1.0 @property def name(self): return self.__name def move(self, distance): print(\"Moving\"); return distance / self._speed; @abstractmethod def describe(self): pass Notice that we must first import both the ABC class and the @abstractmethod decorator from a library helpfully called ABC. Then, we can use ABC as the parent class of our class, and update each method using the @abstractmethod decorator before the method, similar to how we’ve already used @staticmethod in an earlier module.\nIn addition, since we have declared the method describe() to be abstract, we can either add some code to that method that can be called using super().describe() from a child class, or we can simply choose to use the pass keyword to avoid including any code in the method.\nNow, any class that inherits from the Vehicle class must provide an implementation for the describe() method. If it does not, that class must also be declared to be abstract. So, for example, in the UML diagram above, we see that the MotorVehicle class does not include an implementation for describe(), so we’ll also have to make it abstract.\nOf course, that means that we’ll have to inherit from both Vehicle and ABC. In Python, we can do that by simply including both classes in parentheses after the subclass name, separated by a comma.",
    "description": "Static Many programming languages include a special keyword static. In essence, a static attribute or method is part of the class in which it is declared instead of part of objects instantiated from that class. If we think about it, the word static means “lacking in change”, and that’s sort of a good way to think about it.\nIn a UML diagram, static attributes and methods are denoted by underlining them.",
    "tags": [],
    "title": "Static and Abstract",
    "uri": "/cc310/02-oop-review/13-static-abstract/"
  },
  {
    "breadcrumb": "Introduction",
    "content": " Resources K-State Honor \u0026 Integrity System Video Script “On my honor, as a student, I have neither given nor received unauthorized aid on this academic work.” - K-State Honor Pledge\nPlagiarism is a very serious concern in this course, and something that we do not take lightly. Computer programs and code are especially easy targets for plagiarism due to how easy it is to copy and manipulate code in such a way that it is unrecognizable as the original source but still performs correctly.\nAt its core, plagiarism is taking someone else’s work and passing it off as your own without giving appropriate credit to the original source. As a student at K-State, you are bound by the K-State Honor Code not to accept any unauthorized aid, and this includes plagiarized code.\nWhen it comes to plagiarism in computer code, there is a fine line between using resources appropriately and copying code. In this program, you should strive to avoid plagiarism issues by doing the following:\nDo not search for or use any complete solutions to projects in this course found online or from fellow students. Small portions of code may be used or adapted from an online source with proper citation. To cite a piece of code, include a code comment section above it that contains the original source URL and a description of why it was used. In general, copying or adapting small pieces of code to perform auxiliary functions in the assignment is permitted. Copying or adapting code that is the general goal of the assignment should be avoided. For example, if the assignment is to create a bubble sort algorithm, you should write the algorithm from scratch yourself since that is the goal of the assignment. If the assignment is to create a program for displaying data that you feel should be sorted, you may choose to adapt an existing sorting algorithm for your needs (or use one from a library).\nIf you aren’t sure about whether it is OK to use an online resource or piece of code in this course, please contact the instructors using the course discussion forums or help email address. You will not get in trouble for asking, and it will help you determine what the best course of action is. Plagiarism can really only occur when you submit the assignment for grading, so you are welcome to ask for clarification or a judgement on whether a particular usage is acceptable at any time before you submit the assignment.\nCodio has features that will compare your submissions against those of your fellow students. Any submissions with a high degree of similarity may be subjected to additional scrutiny by the instructors to determine if plagiarism has occurred.\nIn this course, any violation of the K-State Honor Code will result in a 0 on that assignment and a report made to the K-State Honor Council. A second violation will result in an XF in this course, as well as any additional sanctions imposed by the K-State Honor Council.\nFor more information on the K-State Honor \u0026 Integrity system, please visit their website, which is linked in the resources section below this video.",
    "description": "Resources K-State Honor \u0026 Integrity System Video Script “On my honor, as a student, I have neither given nor received unauthorized aid on this academic work.” - K-State Honor Pledge\nPlagiarism is a very serious concern in this course, and something that we do not take lightly. Computer programs and code are especially easy targets for plagiarism due to how easy it is to copy and manipulate code in such a way that it is unrecognizable as the original source but still performs correctly.",
    "tags": [],
    "title": "Plagiarism Policy",
    "uri": "/cc310/00-introduction/07-plagiarism/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "Once again, let’s look at the time complexity of the bubble sort algorithm and see how it compares to selection sort.\nBubble sort is a bit trickier to analyze than selection sort, because there are really two parts to the algorithm:\nThe number of comparisons, and The number of swaps. Let’s look at each one individually. First, is there a way to reduce the number of comparisons made by this algorithm just by changing the input? As it turns out, there isn’t anything we can do to change that based on how it is written. The number of comparisons only depends on the size of the array. In fact, the analysis is exactly the same as selection sort, since each iteration of the outer loop does one fewer comparison. Therefore, we can say that bubble sort has time complexity on the order of $N^2$ time when it comes to comparisons.\nWhat about swaps? This is where it gets a bit tricky. What would be the worst-case input for the bubble sort algorithm, which would result in the largest number of swaps made?\nConsider a case where the input is sorted in descending order. The largest element will be first, and the smallest element will be last. If we want the result to be sorted in ascending order, we would end up making $N - 1$ swaps to get the first element to the end of the array, then $N - 2$ swaps for the second element, and so on. So, once again we end up with the same series as before:\n$$\r(N – 1) + (N – 2) + ... + 2 + 1.\r$$ In the worst-case, we’ll also end up doing on the order of $N^2$ swaps, so bubble sort has a time complexity on the order of $N^2$ time when it comes to swaps as well.\nComparing Selection Sort and Bubble Sort It seems that both bubble sort and selection sort are in the same order of time complexity, meaning that each one will take roughly the same amount of time to sort the same array. Does that tell us anything about the process of sorting an array?\nHere’s one way to think about it: what if we decided to compare each element in an array to every other element? How many comparisons would that take? We can use our intuition to know that each element in an array of $N$ elements would require $N – 1$ comparisons, so the total number of comparisons would be $N * (N – 1)$, which is very close to $N^2$.\nOf course, once we’ve compared each element to every other element, we’d know exactly where to place them in a sorted array. One possible conclusion we could make is that there isn’t any way to sort an array that runs much faster than an algorithm that runs in the order of $N^2$ time.\nThankfully, that conclusion is incorrect! There are several other sorting algorithms we can use that allow us to sort an array much more quickly than $N^2$ time. Let’s take a look at those algorithms and see how they work!",
    "description": "Once again, let’s look at the time complexity of the bubble sort algorithm and see how it compares to selection sort.\nBubble sort is a bit trickier to analyze than selection sort, because there are really two parts to the algorithm:\nThe number of comparisons, and The number of swaps. Let’s look at each one individually. First, is there a way to reduce the number of comparisons made by this algorithm just by changing the input?",
    "tags": [],
    "title": "Bubble Sort Time Complexity",
    "uri": "/cc310/7-searching-and-sorting/14-bubble-sort-time-complexity/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "Another algorithmic technique that we’ll learn about is the greedy technique. In a greedy algorithm, the program tries to build a solution one piece at a time. At each step, it will act “greedy” by choosing the piece that it thinks is the best choice for the solution based on the available information. Instead of trying every possible solution like a brute force algorithm or dividing the problem into smaller parts like the divide and conquer approach, a greedy algorithm will just try to construct the one best answer it can.\n1\nExample For example, we can use a greedy algorithm to determine the fewest number of coins needed to give change, as shown in the example above. If the customer is owed $36$ cents, and we have coins worth $20$ cents, $10$ cents, $5$ cents and $1$ cent, how many coins are needed to reach $36$ cents?\nIn a greedy solution, we could choose the coin with the highest value that is less than the change required, give that to the customer, and subtract its value from the remaining change. In this case, it will indeed produce the optimal solution.\nIn fact, both the United States dollar and the European euro have a system of coins that will always produce the minimum number of coins with a greedy algorithm. So that’s very helpful!\nHowever, does it always work? What if we have a system that has coins worth $30$ cents, $18$ cents $4$ cents, and $1$ cent. Would a greedy algorithm produce the result with the minimum number of coins when making change for $36$ cents?\nLet’s try it and see. First, we see that we can use a $30$ cent coin, leaving us with $6$ cents left. Then, we can use a single $4$ cent coin, as well as two $1$ cent coins for a total of $4$ coins: $30 + 4 + 1 + 1 = 36$.\nIs that the minimum number of coins?\nIt turns out that this system includes a coin worth $18$ cents. So, to make $36$ cents, we really only need $2$ coins: $18 + 18 = 36$!\nThis is the biggest weakness of the greedy approach to algorithm design. A greedy algorithm will find a possible solution, but it is not guaranteed to be the best possible solution. Sometimes it will work just fine, but other times it may produce solutions that are not very good at all. So we always must consider that when creating an algorithm using a greedy technique.\nFile:Greedy algorithm 36 cents.svg. (2019, April 27). Wikimedia Commons, the free media repository. Retrieved 23:19, February 8, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Greedy_algorithm_36_cents.svg\u0026oldid=347456702. ↩︎",
    "description": "Another algorithmic technique that we’ll learn about is the greedy technique. In a greedy algorithm, the program tries to build a solution one piece at a time. At each step, it will act “greedy” by choosing the piece that it thinks is the best choice for the solution based on the available information. Instead of trying every possible solution like a brute force algorithm or dividing the problem into smaller parts like the divide and conquer approach, a greedy algorithm will just try to construct the one best answer it can.",
    "tags": [],
    "title": "Greedy",
    "uri": "/cc310/03-intro-dsa/14-greedy/"
  },
  {
    "breadcrumb": "Python Review",
    "content": "One of the major features of a modern computer is the ability to store and retrieve data from the computer’s file system. So, we need to be able to access the file system in our code in order to build useful programs. Thankfully, most modern programming languages include a way to do this.\nI/O in Flowcharts \u0026 Pseudocode Most operations working with files in code take the form of method calls. So, we will primarily use the call block to represent operations on files:\nOperation Flowchart Pseudocode Open File S = “file.txt”\nFILE = open(S) Read from File S = FILE.read() Write to File FILE.write(X) I/O in Python Let’s review the syntax for working with files in Python.\nReading Files To open a file in Python, we can simply use the open() method. Here is an example:\nimport sys try: reader = open(sys.argv[1]) except FileNotFoundError as e: print(\"FileNotFoundError: {}\".format(e)) sys.exit() except IndexError as e: print(\"IndexError: {}\".format(e)) reader = sys.stdin with reader: # -=-=-=-=- MORE CODE GOES HERE -=-=-=-=-In this example, the program will try to open a file provided as the first command-line argument. If no argument is provided, it will automatically read from standard input instead. However, if an argument is provided, it will try to open it as a file. In addition, we can use a With statement to make sure the file is properly closed once it is open.\nOnce we have opened the file, we can read the file just like we would any other input:\nfor line in reader: line = line.strip() if not line or len(line) == 0: break # use line variableWriting Files To write to a file, we must open it a different way. In Python, we must provide an optional \"w\" argument to the open() method call to make the file writable:\nimport sys try: with open(sys.argv[1], \"w\") as writer: writer.write(\"Hello World\") writer.write(\"\\n\") except IndexError as e: # no arguments provided print(\"IndexError: {}\".format(e)) sys.exit() except IOError as e: # unable to write to the file print(\"IOError: {}\".format(e)) sys.exit() except Exception as e: # unknown exception print(\"Exception: {}\".format(e)) sys.exit()This example shows to how to open a file for writing using the open() method inside of a With statement. It also lists several of the common exceptions and their cause.\nResources Open Method Options in the Python Documentation pathlib on the Python Documentation shutil on the Python Documentation ",
    "description": "One of the major features of a modern computer is the ability to store and retrieve data from the computer’s file system. So, we need to be able to access the file system in our code in order to build useful programs. Thankfully, most modern programming languages include a way to do this.\nI/O in Flowcharts \u0026 Pseudocode Most operations working with files in code take the form of method calls.",
    "tags": [],
    "title": "I/O",
    "uri": "/cc310/01-review/13-io/"
  },
  {
    "breadcrumb": "Lists",
    "content": "In this module, we introduced the concept of a linked list, discussing both singly and doubly linked lists. Both kinds of lists are made up of nodes that hold data as well as references (also known as pointers) to other nodes in the list. Singly linked lists use only a single pointer, next, to connect each node to the next node in the list. While simple, we saw that a singly linked list allowed us to efficiently implement a stack without any artificial bounds on the number of items in the list.\nWith doubly linked lists, we added a previous pointer that points to the previous node. This makes the list more flexible and makes it easier to insert and remove nodes from the list. We also added a tail pointer to the class, which keeps track of the last node in the list. The tail pointer significantly increased the efficiency of working with nodes at the end of the list. Adding the tail pointer allowed us to implement all the major queue operations in constant time.",
    "description": "In this module, we introduced the concept of a linked list, discussing both singly and doubly linked lists. Both kinds of lists are made up of nodes that hold data as well as references (also known as pointers) to other nodes in the list. Singly linked lists use only a single pointer, next, to connect each node to the next node in the list. While simple, we saw that a singly linked list allowed us to efficiently implement a stack without any artificial bounds on the number of items in the list.",
    "tags": [],
    "title": "Lists Summary",
    "uri": "/cc310/9-lists/14-lists-summary/"
  },
  {
    "breadcrumb": "OOP Review",
    "content": "This chapter covered the rest of the programming basics we’ll need to know before starting on the new content of this course. By now we should be pretty familiar with the basic syntax of the language we’ve chosen, as well as the concepts of classes, objects, inheritance, and polymorphism in object-oriented programming. Finally, we’ve explored the Model-View-Controller (MVC) architecture, which will be used extensively in this course.",
    "description": "This chapter covered the rest of the programming basics we’ll need to know before starting on the new content of this course. By now we should be pretty familiar with the basic syntax of the language we’ve chosen, as well as the concepts of classes, objects, inheritance, and polymorphism in object-oriented programming. Finally, we’ve explored the Model-View-Controller (MVC) architecture, which will be used extensively in this course.",
    "tags": [],
    "title": "Object Oriented Programming Summary",
    "uri": "/cc310/02-oop-review/14-summary/"
  },
  {
    "breadcrumb": "Python Review",
    "content": "It is important both to easily grasp the design choice and the code structure of a project even long after it has been completed. The documentation process starts by commenting the code. Code comments are usually intended for software developers and aim at clarifying the code by giving details of how it works. They are usually performed using inline or multiple lines comments using the language syntax.\nSingle Line Comments As we’ve seen before, we can add single-line comments to our Python programs using a hash symbol # before a line in our source file:\n# this is a comment x = 5 # this is also a comment b = TrueDocstrings Finally, Python also includes a secondary type of comment that spans multiple lines, specifically for creating documentation. A docstring is usually the first line of text inside of a class or method definition, and is surrounded by three double quotes \"\"\" with one set of three on each end.\nThese comments are specifically designed to provide information about classes and methods in our code. Here’s a quick example using a simple class:\nclass IntTuple: \"\"\" Represents a tuple containing two integer values This class is an adaptation of a class developed for Java that mimics the built-in tuples in Python Attributes ---------- first : int the first element in the tuple second : int the second element in the tuple \"\"\" def __init__(self, one, two): \"\"\" Initializes a new IntTuple object Parameters ---------- one : int the first element in the new tuple two : int the second element in the new tuple \"\"\" self.first = one self.second = twoUnfortunately, Python does not enforce a particular style for these docstrings, so there are many different formats used in practice. To learn more, we can consult the following references.\nReferences Documenting Python Code from Real Python Google Docstring Style Guide reStructured Text - The format used in official Python libraries ",
    "description": "It is important both to easily grasp the design choice and the code structure of a project even long after it has been completed. The documentation process starts by commenting the code. Code comments are usually intended for software developers and aim at clarifying the code by giving details of how it works. They are usually performed using inline or multiple lines comments using the language syntax.\nSingle Line Comments As we’ve seen before, we can add single-line comments to our Python programs using a hash symbol # before a line in our source file:",
    "tags": [],
    "title": "Documentation",
    "uri": "/cc310/01-review/14-documentation/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": " Another commonly used sorting algorithm is merge sort. Merge sort uses a recursive, divide and conquer approach to sorting, which makes it very powerful. It was actually developed to handle sorting data sets that were so large that they couldn’t fit on a single memory device, way back in the early days of computing.\nThe basic idea of the merge sort algorithm is as follows:\nIf the container only contains one or two elements, we can quickly sort that container by swapping the elements if needed. Otherwise, we should divide the container in half and recursively use merge sort on each half. Once each half is sorted, we can then merge them back together into a single container. Once again, Wikipedia has a great animation showing this process:\n^[File:Merge-sort-example-300px.gif. (2020, February 22). Wikimedia Commons, the free media repository. Retrieved 00:06, March 24, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Merge-sort-example-300px.gif\u0026oldid=397192885.]\nMerge Sort Example Let’s walk through a simple example and see how it works. First, we’ll start with the same initial array as before, shown in the figure below. To help us keep track, we’ll refer to this function call using the array indexes it covers. It will be mergeSort(0, 9).\nSince this array contains more than 2 elements, we won’t be able to sort it quickly. Instead, we’ll divide it in half, and sort each half using merge sort again. Let’s continue the process with the first half of the array. We’ll use a thick outline to show the current portion of the array we are sorting, but we’ll retain the original array indexes to help keep track of everything.\nNow we are in the first recursive call, mergeSort(0, 4),which is looking at the first half of the original array. Once again, we have more than 2 elements, so we’ll split it in half and recursively call mergeSort(0, 1) first.\nAt this point, we now have an array with just 2 elements. We can use one of our base cases to sort that array by swapping the two elements, if needed. In this case, we should swap them, so we’ll get the result shown below.\nNow that the first half of the smaller array has been sorted, our recursive call mergeSort(0, 1) will return and we’ll look at the second half of the smaller array in the second recursive call, mergeSort(2, 4), as highlighted below.\nAs we’ve seen before, this array has more than 2 elements, so we’ll need to divide it in half and recursively call the function again. First, we’ll call mergeSort(2, 2).\nIn this case, the current array we are considering contains a single element, so it is already sorted. Therefore, the recursive call to mergeSort(2, 2) will return quickly, and we’ll consider the second part of the smaller array in mergeSort(3, 4), highlighted below.\nHere, we have 2 elements, and this time they are already sorted. So, we don’t need to do anything, and our recursive call to mergeSort(3, 4) will return. At this point, we will be back in our call to mergeSort(2, 4), and both halves of that array have been sorted. We’re back to looking at the highlighted elements below.\nNow we have to merge these two arrays together. Thankfully, since they are sorted, we can follow this simple process:\nCreate a temporary array that has the same size as both halves combined. Look at the first element of each half of the original array. Choose the smaller of the two. Place that element first in the temporary array. Repeat steps 2 and 3 until one half is empty. Place the remaining elements of the half that is not empty at the end of the temporary array. Replace the original array with the temporary array. Let’s take a look at what that process would look like. First, we’ll create a new temporary array to store the result.\nNext, we will look at the first element in each of the two sorted halves of the original array. In this case, we’ll compare 2 and 6, which are highlighted below.\nNow we should pick the smaller of those two values, which will be 2. That value will be placed in the new temporary array at the very beginning.\nNext, we should look at the remaining halves of the array. Since the first half is empty, we can just place the remaining elements from the second half into the temporary array.\nFinally, we should replace the portion of the original array that we are looking at in this recursive call with the temporary array. In most cases, we’ll just copy these elements into the correct places in the original array. In the diagram, we’ll just replace them.\nThere we go! We’ve now completed the recursive call mergeSort(2, 4). We can return from that recursive call and go back to mergeSort(0, 4).\nSince both halves of the array in mergeSort(0, 4) are sorted, we must do the merge process again. We’ll start with a new temporary array and compare the first element in each half.\nAt this point, we’ll see that 2 is the smaller of those elements, so we’ll place it in the first slot in the temporary array and consider the next element in the second half.\nNext, we’ll compare the values 5 and 6, and see that 5 is smaller. It should be placed in the next available element in our temporary array and we should continue onward.\nWe’ll repeat this process again, placing the 6 in the temporary array, then the 8, then finally the 9. After completing the merge process, we’ll have the following temporary array.\nFinally, we’ll replace the original elements with the now merged elements in the temporary array.\nThere we go! We’ve now completed the process in the mergeSort(0, 4) recursive call. Once that returns, we’ll be back in our original call to mergeSort(0, 9). In that function, we’ll recursively call the process again on the second half of the array using mergeSort(5, 9).\nHopefully by now we understand that it will work just like we intended, so by the time that recursive call returns, we’ll now have the second half of the array sorted as well.\nThe last step in the original mergeSort(0, 9) function call is to merge these two halves together. So, once again, we’ll follow that same process as before, creating a new temporary array and moving through the elements in each half, placing the smaller of the two in the new array. Once we are done, we’ll end up with a temporary array that has been populated as shown below.\nFinally, we’ll replace the elements in the original array with the ones in the temporary array, resulting in a completely sorted result.",
    "description": "Another commonly used sorting algorithm is merge sort. Merge sort uses a recursive, divide and conquer approach to sorting, which makes it very powerful. It was actually developed to handle sorting data sets that were so large that they couldn’t fit on a single memory device, way back in the early days of computing.\nThe basic idea of the merge sort algorithm is as follows:\nIf the container only contains one or two elements, we can quickly sort that container by swapping the elements if needed.",
    "tags": [],
    "title": "Merge Sort",
    "uri": "/cc310/7-searching-and-sorting/15-merge-sort/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": " The next algorithmic technique we’ll discuss is recursion. Recursion is closely related to the divide and conquer method we discussed earlier. However, recursion itself is a very complicated term to understand. It usually presents one of the most difficult challenges for a novice programmer to overcome when learning to write more advanced programs. Don’t worry! We’ll spend an entire module on recursion later in this course.\nWhat is Recursion? There are many different ways to define recursion. In one sense, recursion is a problem solving technique where the solution to a problem depends on solutions to smaller versions of the problem, very similar to the divide and conquer approach.\nHowever, to most programmers, the term recursion is used to describe a function or method that calls itself inside of its own code. It may seem strange at first, but there are many instances in programming where a method can actually call itself again to help solve a difficult problem. However, writing recursive programs can be tricky at first, since there are many ways to make simple errors using recursion that cause our programs to break.\nMastering recursion takes quite a bit of time and practice, and nearly every programmer has a strong memory of the first time recursion made sense in their minds. So, it is important to make sure we understand it! In fact, it is so notable, that when we search for “recursion” on Google, it helpfully prompts us if we want to search for “recursion” instead, as seen at the top of this page.\nExample - Factorial A great example of a recursive method is calculating the factorial of a number. We may recall from mathematics that the factorial of a number is the product of each integer from 1 up to and including that number. For example, the factorial of $5$, written as $5!$, is calculated as $5 * 4 * 3 * 2 * 1 = 120$\nWe can easily write a traditional method to calculate the factorial of a number as follows.\nfunction ITERATIVE_FACTORIAL(N) RESULT = 1 loop I from 1 to N: RESULT = RESULT * I end loop return RESULT end functionHowever, we may also realize that the value of $5!$ is the same as $4! * 5$. If we already know how to find the factorial of $4$, we can just multiply that result by $5$ to find the factorial of $5$. As it turns out, there are many problems in the real world that work just like this, and, in fact, many of the data structures we’ll learn about are built in a similar way.\nWe can rewrite this iterative function to be a recursive function instead.\nfunction RECURSIVE_FACTORIAL(N) if N == 1 return 1 else return N * RECURSIVE_FACTORIAL(N - 1) end if end functionAs we can see, a recursive function includes two important elements, the base case and a recursive case. We need to include the base case so we can stop calling our recursive function over and over again, and actually reach a solution. This is similar to the termination condition of a for loop or while loop. If we forget to include the base case, our program will recurse infinitely!\nThe second part, the recursive case, is used to reduce the problem to a smaller version of the same problem. In this case, we reduce $N!$ to $N * (N - 1)!$. Then, we can just call our function again to solve the problem $(N - 1)!$, and multiply the result by $N$ to find the solution to $N!$.\nSo, if we have a problem that can be reduced to a smaller instance of itself, we may be able to use recursion to solve it!",
    "description": "The next algorithmic technique we’ll discuss is recursion. Recursion is closely related to the divide and conquer method we discussed earlier. However, recursion itself is a very complicated term to understand. It usually presents one of the most difficult challenges for a novice programmer to overcome when learning to write more advanced programs. Don’t worry! We’ll spend an entire module on recursion later in this course.\nWhat is Recursion? There are many different ways to define recursion.",
    "tags": [],
    "title": "Recursion",
    "uri": "/cc310/03-intro-dsa/15-recursion/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": " Beyond the algorithmic techniques we’ve introduced so far, there are a number of techniques that deal specifically with data stored in non-linear data structures based on graphs. Generally speaking, we can group all of these algorithms under the heading graph traversal algorithms.\nA graph traversal algorithm constructs an answer to a problem by moving between nodes in a graph using the graph’s edges, thereby traversing the graph. For example, a graph traversal algorithm could be used by a mapping program to construct a route from one city to another on a map, or to determine friends in common on a social networking website.\nExample - Dijkstra’s Algorithm 1\nA great example of a graph traversal algorithm is Dijkstra’s Algorithm, which can be used to find the shortest path between two selected nodes in a graph. In the image above, we can see the process of running Dijkstra’s Algorithm on a graph that contains just a few nodes.\n1\nOf course, we can use the same approach on any open space, as seen in this animation. Starting at the lower left corner, the algorithm slowly works toward the goal node, but it eventually runs into an obstacle. So, it must find a way around the obstacle while still finding the shortest path to the goal.\nAlgorithms such as Dijkstra’s Algorithm, and a more refined version called the A* Algorithm are used in many different computer programs to help find a path between two points, especially in video games.\nFile:Dijkstra Animation.gif. (2018, November 24). Wikimedia Commons, the free media repository. Retrieved 01:45, February 9, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Dijkstra_Animation.gif\u0026oldid=329177321. ↩︎ ↩︎",
    "description": "Beyond the algorithmic techniques we’ve introduced so far, there are a number of techniques that deal specifically with data stored in non-linear data structures based on graphs. Generally speaking, we can group all of these algorithms under the heading graph traversal algorithms.\nA graph traversal algorithm constructs an answer to a problem by moving between nodes in a graph using the graph’s edges, thereby traversing the graph. For example, a graph traversal algorithm could be used by a mapping program to construct a route from one city to another on a map, or to determine friends in common on a social networking website.",
    "tags": [],
    "title": "Graph Traversal",
    "uri": "/cc310/03-intro-dsa/16-graph-traversals/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "Now that we’ve seen how merge sort works by going through an example, let’s look at the pseudocode of a merge sort function.\nfunction MERGESORT(ARRAY, START, END)\t(1) # base case size == 1\tif END - START + 1 == 1 then\t(2)\treturn\t(3) end if\t(4) # base case size == 2 if END - START + 1 == 2 then\t(5) # check if elements are out of order if ARRAY[START] \u003e ARRAY[END] then\t(6) # swap if so TEMP = ARRAY[START]\t(7) ARRAY[START] = ARRAY[END]\t(8) ARRAY[END] = TEMP\t(9) end if\t(10) return\t(11) end if\t(12) # find midpoint HALF = int((START + END) / 2)\t(13) # sort first half MERGESORT(ARRAY, START, HALF)\t(14) # sort second half MERGESORT(ARRAY, HALF + 1, END)\t(15) # merge halves MERGE(ARRAY, START, HALF, END)\t(16) end function\t(17)This function is a recursive function which has two base cases. The first base case is shown in lines 2 through 4, where the size of the array is exactly 1. In that case, the array is already sorted, so we just return on line 3 without doing anything.\nThe other base case is shown in lines 5 through 11. In this case, the element contains just two elements. We can use the if statement on line 6 to check if those two elements are in the correct order. If not, we can use lines 7 through 9 to swap them, before returning on line 11.\nIf neither of the base cases occurs, then we reach the recursive case starting on line 13. First, we’ll need to determine the midpoint of the array , which is just the average of the start and end variables. We’ll need to remember to make sure that value is an integer by truncating it if needed.\nThen, on lines 14 and 15 we make two recursive calls, each one focusing on a different half of the array. Once each of those calls returns, we can assume that each half of the array is now sorted.\nFinally, in line 16 we call a helper function known as merge to merge the two halves together. The pseudocode for that process is below.\nfunction MERGE(ARRAY, START, HALF, END)\t(1) TEMPARRAY = new array[END – START + 1]\t(2) INDEX1 = START\t(3) INDEX2 = HALF + 1\t(4) NEWINDEX = 0\t(5) loop while INDEX1 \u003c= HALF and INDEX2 \u003c= END\t(6) if ARRAY[INDEX1] \u003c ARRAY[INDEX2] then\t(7) TEMPARRAY[NEWINDEX] = ARRAY[INDEX1]\t(8) INDEX1 = INDEX1 + 1\t(9) else\t(10) TEMPARRAY[NEWINDEX] = ARRAY[INDEX2]\t(11) INDEX2 = INDEX2 + 1\t(12) end if\t(13) NEWINDEX = NEWINDEX + 1\t(14) end loop\t(15) loop while INDEX1 \u003c= HALF\t(16) TEMPARRAY[NEWINDEX] = ARRAY[INDEX1]\t(17) INDEX1 = INDEX1 + 1\t(18) NEWINDEX = NEWINDEX + 1\t(19) end loop\t(20) loop while INDEX2 \u003c= END\t(21) TEMPARRAY[NEWINDEX] = ARRAY[INDEX2]\t(22) INDEX2 = INDEX2 + 1\t(23) NEWINDEX = NEWINDEX + 1\t(24) end loop\t(25) loop INDEX from 0 to size of TEMPARRAY – 1\t(26) ARRAY[START + INDEX] = TEMPARRAY[INDEX]\t(27) end loop\t(28) end function\t(29)The merge function begins by creating some variables. The tempArray will hold the newly merged array. Index1 refers to the element in the first half that is being considered, while index2 refers to the element in the second half. Finally, newIndex keeps track of our position in the new array.\nThe first loop starting on line 6 will continue operating until one half or the other has been completely added to the temporary array. It starts by comparing the first element in each half of the array. Then, depending on which one is smaller, it will place the smaller of the two in the new array and increment the indexes.\nOnce the first loop has completed, there are two more loops starting on lines 16 and 21. However, only one of those loops will actually execute, since only one half of the array will have any elements left in it to be considered. These loops will simply copy the remaining elements to the end of the temporary array.\nFinally, the last loop starting on line 26 will copy the elements from the temporary array back into the source array. At this point, they will be properly merged in sorted order.",
    "description": "Now that we’ve seen how merge sort works by going through an example, let’s look at the pseudocode of a merge sort function.\nfunction MERGESORT(ARRAY, START, END)\t(1) # base case size == 1\tif END - START + 1 == 1 then\t(2)\treturn\t(3) end if\t(4) # base case size == 2 if END - START + 1 == 2 then\t(5) # check if elements are out of order if ARRAY[START] \u003e ARRAY[END] then\t(6) # swap if so TEMP = ARRAY[START]\t(7) ARRAY[START] = ARRAY[END]\t(8) ARRAY[END] = TEMP\t(9) end if\t(10) return\t(11) end if\t(12) # find midpoint HALF = int((START + END) / 2)\t(13) # sort first half MERGESORT(ARRAY, START, HALF)\t(14) # sort second half MERGESORT(ARRAY, HALF + 1, END)\t(15) # merge halves MERGE(ARRAY, START, HALF, END)\t(16) end function\t(17)This function is a recursive function which has two base cases.",
    "tags": [],
    "title": "Merge Sort Pseudocode",
    "uri": "/cc310/7-searching-and-sorting/16-merge-sort-pseudocode/"
  },
  {
    "breadcrumb": "Python Review",
    "content": "To make your code easier to read, many textbooks and companies use a style guide that defines some of the formating rules that you should follow in your source code. In Python, these rules are very important, as the structure of your code is defined by the layout. We’ll learn more about that in a later module.\nFor this book, most of the examples will be presented using the guidelines in the Style Guide for Python. However, by default Codio used to use 2 spaces for an indentation level instead of 4, so that is the format that will be used in some examples in this book.\nGoogle also provides a comprehensive style guide that is recommended reading if you’d like to learn more about how to format your source code.",
    "description": "To make your code easier to read, many textbooks and companies use a style guide that defines some of the formating rules that you should follow in your source code. In Python, these rules are very important, as the structure of your code is defined by the layout. We’ll learn more about that in a later module.\nFor this book, most of the examples will be presented using the guidelines in the Style Guide for Python.",
    "tags": [],
    "title": "Style",
    "uri": "/cc310/01-review/15-style/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "Now that we’ve reviewed the pseudocode for the merge sort algorithm, let’s see if we can analyze the time it takes to complete. Analyzing a recursive algorithm requires quite a bit of math and understanding to do it properly, but we can get a pretty close answer using a bit of intuition about what it does.\nFor starters, let’s consider a diagram that shows all of the different recursive calls made by merge sort, as shown below.\nThe first thing we should do is consider the worst-case input for merge sort. What would that look like? Put another way, would the values or the ordering of those values change anything about how merge sort operates?\nThe only real impact that the input would have is on the number of swaps made by merge sort. If we had an input that caused each of the base cases with exactly two elements to swap them, that would be a few more steps than any other input. Consider the highlighted entries below.\nIf each of those pairs were reversed, we’d end up doing that many swaps. So, how many swaps would that be? As it turns out, a good estimate would be $N / 2$ times. If we have an array with exactly 16 elements, there are at most 8 swaps we could make. With 10 elements, we can make at most 4. So, the number of swaps is on the order of N time complexity.\nWhat about the merge operation? How many steps does that take? This is a bit trickier to answer, but let’s look at each row of the diagram above. Across all of the calls to merge sort on each row, we’ll end up merging all $N$ elements in the original array at least once. Therefore, we know that it would take around $N$ steps for each row in the diagram. We’ll just need to figure out how many rows there are.\nA better way to phrase that question might be “how many times can we recursively divide an array of $N$ elements in half?” As it turns out, the answer to that question lies in the use of the logarithm.\nInfo Logarithm The logarithm is the inverse of exponentiation. For example, we could have the exponentiation formula:\n$$\r\\text{base}^{\\text{exponent}} = \\text{power}\r$$ The inverse of that would be the logarithm $$\r\\text{log}_{\\text{base}}(\\text{power}) = \\text{exponent}\r$$ So, if we know a value and base, we can determine the exponent required to raise that base to the given value.\nIn this case, we would need to use the logarithm with base $2$, since we are dividing the array in half each time. So, we would say that the number of rows in that diagram, or the number of levels in our tree would be on the order of $\\text{log}_2(N)$. In computer science, we typically write $\\text{log}_2$ as $\\text{lg}$, so we’ll say it is on the order of $\\text{lg}(N)$.\nTo get an idea of how that works, consider the case where the array contains exactly $16$ elements. In that case, the value $\\text{lg}(16)$ is $4$, since $2^4 = 16$. If we use the diagram above as a model, we can draw a similar diagram for an array containing $16$ elements and find that it indeed has $4$ levels.\nIf we double the size of the array, we’ll now have $32$ elements. However, even by doubling the size of the array, the value of $\\text{lg}(32)$ is just $5$, so it has only increased by $1$. In fact, each time we double the size of the array, the value of $\\text{lg}(N)$ will only go up by $1$.\nWith that in mind, we can say that the merge operation runs on the order of $N * \\text{lg}(N)$ time. That is because there are ${\\text{lg}(N)}$ levels in the tree, and each level of the tree performs $N$ operations to merge various parts of the array together. The diagram below gives a good graphical representation of how we can come to that conclusion.\nPutting it all together, we have $N/2$ swaps, and $N * \\text{lg}(N)$ steps for the merge. Since the value $N * \\text{lg}(N)$ is larger than $N$, we would say that total running time of merge sort is on the order of $N * \\text{lg}(N)$.\nLater on in this chapter we’ll discuss how that compares to the running time of selection sort and bubble sort and how that impacts our programs.",
    "description": "Now that we’ve reviewed the pseudocode for the merge sort algorithm, let’s see if we can analyze the time it takes to complete. Analyzing a recursive algorithm requires quite a bit of math and understanding to do it properly, but we can get a pretty close answer using a bit of intuition about what it does.\nFor starters, let’s consider a diagram that shows all of the different recursive calls made by merge sort, as shown below.",
    "tags": [],
    "title": "Merge Sort Time Complexity",
    "uri": "/cc310/7-searching-and-sorting/17-merge-sort-time-complexity/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": " In this course, we will learn how to develop several different data structures, and then use those data structures in programs that implement several different types of algorithms. However, one of the most difficult parts of programming is clearly explaining what a program should do and how it should perform.\nSo far, we’ve used UML class diagrams to discuss the structure of a program. It can give us information about the classes, attributes, and methods that our program will contain, as well as the overall relationships between the classes. We can even learn if attributes and methods are private or public, and more.\nHowever, to describe what each method does, we have simply relied on descriptions in plain language up to this point, with no specific format at all. In this module, we’ll introduce the concept of programming by contract to help us provide more specific information about what each method should do and the expectations we can count on based on the inputs and outputs of the method.\nSpecifically, we’ll learn about the preconditions that are applied to the parameters of a method to make sure they are valid, the postconditions that the method will guarantee if the preconditions are met, and the invariants that a loop or data structure will maintain.\nFinally, we can put all of that information together to discuss how to prove that an algorithm correctly performs the task it was meant to, and how to make sure that it works correctly in all possible cases.",
    "description": "In this course, we will learn how to develop several different data structures, and then use those data structures in programs that implement several different types of algorithms. However, one of the most difficult parts of programming is clearly explaining what a program should do and how it should perform.\nSo far, we’ve used UML class diagrams to discuss the structure of a program. It can give us information about the classes, attributes, and methods that our program will contain, as well as the overall relationships between the classes.",
    "tags": [],
    "title": "Programming by Contract",
    "uri": "/cc310/03-intro-dsa/17-contracts/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "First, let’s discuss preconditions. A precondition is an expectation applied to any parameters and existing variables when a method or function is called. Phrased a different way, the preconditions should all be true before the method is called. If all of the preconditions are met, the function can proceed and is expected to function properly. However, if any one of the preconditions are not met, the function may either reach an exception, prompt the user to correct the issue, or produce invalid output, depending on how it is written.\nExample - Area of a Triangle Let’s consider an example method to see how we can define the preconditions applied to that method. In this example, we’re going to write a method triangleArea(side1, side2, side3) that will calculate the area of a triangle, given the lengths of the sides of the triangle.\nSo, to determine what the preconditions of that method should be, we must think about what we know about a triangle and what sort of data we expect to receive.\nFor example, we know that the length of each side should be a number. In addition, those lengths should all be positive, so each one must be strictly greater than $0$.\nWe can also determine if we expect the length to be whole numbers or floating-point numbers. To make this example simpler, let’s just work with whole numbers.\nWhen looking at preconditions, determining the types and expected range of values of each parameter is a major first step. However, sometimes we must also look at the relationship between the parameters to find additional preconditions that we must consider.\n1\nFor example, the triangle inequality states that the longest side of a triangle must be strictly shorter than the sum of the other two sides. Otherwise, those sides will not create a triangle. So, another precondition must state that the sides satisfy the triangle inequality.\nAll together, we’ve found the following preconditions for our method triangleArea(side1, side2, side3):\nside1, side2 and side3 each must each be an integer that is strictly greater than $0$ side1, side2 and side3 must satisfy the triangle inequality Precondition Failures What if our method is called and provided a set of parameters that do not meet the preconditions described above? As a programmer, there are several actions we can take in our code to deal with the situation.\nExceptions One of the most common ways to handle precondition failures is to simply throw or raise exceptions from our method as soon as it determines that the preconditions are not met. In this way, we can quickly indicate that the program is unable to perform the requested operation, and leave it up to the code that called that method to either handle the exception or ignore it and allow the program to crash.\nThis method is best used within the model portions of a program written using the Model-View-Controller or MVC architecture. By doing so, this allows our controller to react to problems quickly, usually by requesting additional input from the user using the view portion of the program.\nPrompt User In simpler programs, it is common for the code to simply handle the precondition failure by asking the user for new input. This is commonly done in programs that are small enough to fit in a single class, instead of being developed using MVC architecture.\nIncorrect Output Of course, we could choose to simply ignore these precondition failures and allow our code to continue running. IN that case, if the preconditions are not met, then the answer we receive may be completely invalid. On the next page, we’ll discuss how failed preconditions affect whether we can trust our method’s output.\nFile:TriangleInequality.svg. (2015, July 10). Wikimedia Commons, the free media repository. Retrieved 23:22, January 21, 2020 from https://commons.wikimedia.org/w/index.php?title=File:TriangleInequality.svg\u0026oldid=165448754. ↩︎",
    "description": "First, let’s discuss preconditions. A precondition is an expectation applied to any parameters and existing variables when a method or function is called. Phrased a different way, the preconditions should all be true before the method is called. If all of the preconditions are met, the function can proceed and is expected to function properly. However, if any one of the preconditions are not met, the function may either reach an exception, prompt the user to correct the issue, or produce invalid output, depending on how it is written.",
    "tags": [],
    "title": "Preconditions",
    "uri": "/cc310/03-intro-dsa/18-preconditions/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": " The last sorting algorithm we will review in this module is quicksort. Quicksort is another example of a recursive, divide and conquer sorting algorithm, and at first glance it may look very similar to merge sort. However, quicksort uses a different process for dividing the array, and that can produce some very interesting results.\nThe basic idea of quicksort is as follows:\nChoose a pivot value, called pivotValue. This value could be any random value in the array. In our implementation, we’ll simply use the last value. Partition the values in the container into two parts: the left part contains all the elements less than or equal to the value of pivotValue the right part contains all the elements greater than the value of pivotValue Place pivotValue in between those two parts. We’ll call the index of pivotValue the pivotIndex. Recursively sort the two parts by calling the quicksort procedure again: the first call sorts the values in the container from start to pivotIndex – 1 the second call sort the values in the container from pivotIndex + 1 to the end Once the recursive calls are complete, the entire container should be sorted. As with all of the other examples we’ve looked at in this module, Wikipedia provides yet another excellent animation showing this process.\n^[File:Sorting quicksort anim.gif. (2019, July 30). Wikimedia Commons, the free media repository. Retrieved 01:14, March 24, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Sorting_quicksort_anim.gif\u0026oldid=359998181.]\nQuicksort Example Let’s look at an example of the quicksort algorithm in action to see how it works. Unlike the other sorting algorithms we’ve seen, this one may appear to be just randomly swapping elements around at first glance. However, as we move through the example, we should start to see how it achieves a sorted result, usually very quickly!\nWe can start with our same initial array, shown below.\nThe first step is to choose a pivot value. As we discussed above, we can choose any random value in the array. However, to make it simple, we’ll just use the last value. We will create two variables, pivotValue and pivotIndex, to help us keep track of things. We’ll set pivotValue to the last value in the array, and pivotIndex will initially be set to 0. We’ll see why in a few steps.\nNow, the algorithm will iterate across each element in the array, comparing it with the value in pivotValue. If that value is less than or equal to the pivotValue, we should swap the element at pivotIndex with the value we are looking at in the array. Let’s see how this would work.\nWe’d start by looking at the value at index 0 of the array, which is 8. Since that value is greater than the pivotValue, we do nothing and just look at the next item.\nHere, we are considering the value 5, which is at index 1 in the array. In this case, that value is less than or equal to the pivotValue. So, we want to swap the current element with the element at our pivotIndex, which is currently 0. Once we do that, we’ll also increment our pivotIndex by 1. The diagram below shows these changes before they happen.\nOnce we make those changes, our array should look like the following diagram, and we’ll be ready to examine the value at index 2.\nOnce again, the value 2 at index 2 of the array is less than or equal to the pivot value. So, we’ll swap them, increment pivotValue, and move to the next element.\nWe’ll continue this process, comparing the next element in the array with the pivotValue, and then swapping that element and the element at the pivotIndex if needed, incrementing the pivotIndex after each swap. The diagrams below show the next few steps. First, since 6 is less than or equal to our pivotValue, we’ll swap it with the pivot index and increment.\nHowever, since 9 is greater than the pivot index, we’ll just leave it as is for now and move to the next element.\n3 is less than or equal to the pivot value, so we’ll swap the element at index 3 with the 3 at index 5.\nWe’ll see that the elements at indexes 6, 7 and 8 are all less than or equal to the pivot value. So, we’ll end up making some swaps until we reach the end of the list.\nFinally, we have reached the end of the array, which contains our pivotValue in the last element. Thankfully, we can just continue our process one more step. Since the pivotValue is less than or equal to itself, we swap it with the element at the pivotIndex, and increment that index one last time.\nAt this point, we have partitioned the initial array into two sections. The first section contains all of the values which are less than or equal to the pivot value, and the second section contains all values greater than the pivot value.\nThis demonstrates the powerful way that quicksort can quickly partition an array based on a pivot value! With just a single pass through the array, we have created our two halves and done at least some preliminary sorting. The last step is to make two recursive calls to quicksort, one that sorts the items from the beginning of the array through the element right before the pivotValue. The other will sort the elements starting after the pivotValue through the end of the array.\nOnce each of those recursive calls is complete, the entire array will be sorted!",
    "description": "The last sorting algorithm we will review in this module is quicksort. Quicksort is another example of a recursive, divide and conquer sorting algorithm, and at first glance it may look very similar to merge sort. However, quicksort uses a different process for dividing the array, and that can produce some very interesting results.\nThe basic idea of quicksort is as follows:\nChoose a pivot value, called pivotValue. This value could be any random value in the array.",
    "tags": [],
    "title": "Quicksort",
    "uri": "/cc310/7-searching-and-sorting/18-quicksort/"
  },
  {
    "breadcrumb": "Python Review",
    "content": "That’s a quick overview of the basics we’ll need to know before starting the new content in this course. The next module will provide a quick review of object-oriented programming concepts as well as the model-view-controller or MVC architecture, both of which will be used heavily in this course.",
    "description": "That’s a quick overview of the basics we’ll need to know before starting the new content in this course. The next module will provide a quick review of object-oriented programming concepts as well as the model-view-controller or MVC architecture, both of which will be used heavily in this course.",
    "tags": [],
    "title": "Review Summary",
    "uri": "/cc310/01-review/16-summary/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "Next, we can discuss postconditions. A postcondition is a statement that is guaranteed to be true after a method is executed, provided all of the preconditions were met. If any one of the preconditions were not met, then we can’t count on the postcondition being true either. This is the most important concept surrounding preconditions and postconditions.\nInfo If the preconditions of a method are all true when a method is called, then we may assume the postconditions are true after the method is complete, provided it is written correctly.\nExample - Area of a Triangle On the last page, we discussed the preconditions for a method triangleArea(side1, side2, side3) that will calculate the area of a triangle given the lengths of its sides. Those preconditions are:\nside1, side2 and side3 each must each be an integer that is strictly greater than $0$ side1, side2 and side3 must satisfy the triangle inequality So, once the method completes, what should our postcondition be? In this case, we want to find a statement that would be always true if all of the preconditions are met.\nSince the method will be calculating the area of the triangle, the strongest postcondition we can use is the most obvious one:\nThe method will return the area of a triangle with side lengths side1, side2 and side3 That’s really it!\nOf course, there are a few other postconditions that we could consider, especially when we start working with data structures and objects. For example, one of the most powerful postconditions is the statement:\nThe values of the parameters are not modified from their original values When we call a method that accepts an array or object as a parameter, we know that we can modify the values stored in that array or object because the parameter is handled in a call-by-reference fashion in most languages. So, if we don’t state that this postcondition applies, we can’t guarantee that the method did not change the values in the array or object we provided as a parameter.\nPrecondition Failures: Incorrect Output So, what if the preconditions are not met? Then what happens?\nAs we discussed on the previous page, if the preconditions are not met, then we cannot guarantee that the postcondition will be true once the method executes. In fact, it may be decidedly incorrect, depending on how we implement the method.\n1\nFor example, the simplest way to find the area of a triangle given the lengths of all three sides is Heron’s formula, which can be written mathematically as:\n$$\rA = 1/4 \\sqrt{(a + b + c)(-a + b + c)(a - b + c)(a + b - c)}\r$$ Since this is a mathematical formula, it is always possible to get a result from it, even if all of the preconditions are not met. For example, the inputs could be floating-point values instead of integers, or they may not satisfy the triangle inequality. In that case, the function may still produce a result, but it will not represent the actual area of the triangle described, mainly because the parameters provided describe a triangle that cannot exist in the real world. So, we must always be careful not to assume that a method will always provide the correct output unless we provide parameters that make all of its preconditions true.\nFile:Triangle with notations 2 without points.svg. (2018, December 5). Wikimedia Commons, the free media repository. Retrieved 00:03, January 22, 2020 from https://commons.wikimedia.org/w/index.php?title=File:Triangle_with_notations_2_without_points.svg\u0026oldid=330397605. ↩︎",
    "description": "Next, we can discuss postconditions. A postcondition is a statement that is guaranteed to be true after a method is executed, provided all of the preconditions were met. If any one of the preconditions were not met, then we can’t count on the postcondition being true either. This is the most important concept surrounding preconditions and postconditions.\nInfo If the preconditions of a method are all true when a method is called, then we may assume the postconditions are true after the method is complete, provided it is written correctly.",
    "tags": [],
    "title": "Postconditions",
    "uri": "/cc310/03-intro-dsa/19-postconditions/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "Now that we’ve seen an example of how quicksort works, let’s walk through the pseudocode of a quicksort function. The function itself is very simple, as shown below.\nfunction QUICKSORT(ARRAY, START, END)\t(1) # base case size \u003c= 1\tif START \u003e= END then\t(2)\treturn\t(3) end if\t(4) PIVOTINDEX = PARTITION(ARRAY, START, END)\t(5) QUICKSORT(ARRAY, START, PIVOTINDEX – 1)\t(6) QUICKSORT(ARRAY, PIVOTINDEX + 1, END)\t(7) end function\t(8)This implementation of quicksort uses a simple base case on lines 2 through 4 to check if the array is either empty, or contains one element. It does so by checking if the START index is greater than or equal to the END index. If so, it can assume the array is sorted and just return it without any additional changes.\nThe recursive case is shown on lines 5 – 7. It simply uses a helper function called partition on line 5 to partition the array based on a pivot value. That function returns the location of the pivot value, which is stored in pivotIndex. Then, on lines 6 and 7, the quicksort function is called recursively on the two partitions of the array, before and after the pivotIndex. That’s really all there is to it!\nLet’s look at one way we could implement the partition function, shown below in pseudocode.\nfunction PARTITION(ARRAY, START, END)\t(1) PIVOTVALUE = ARRAY[END]\t(2) PIVOTINDEX = START\t(3) loop INDEX from START to END\t(4) if ARRAY[INDEX] \u003c= PIVOTVALUE\t(5) TEMP = ARRAY[INDEX] (6) ARRAY[INDEX] = ARRAY[PIVOTINDEX]\t(7) ARRAY[PIVOTINDEX] = TEMP\t(8) PIVOTINDEX = PIVOTINDEX + 1\t(9) end if\t(10) end loop\t(11) return PIVOTINDEX – 1\t(12)This function begins on lines 2 and 3 by setting initial values for the pivotValue by choosing the last element in the array, and then setting the pivotIndex to 0. Then, the loop on lines 4 through 11 will look at each element in the array, determine if it is less than or equal to pivotValue, and swap that element with the element at pivotIndex if so, incrementing pivotIndex after each swap.\nAt the end, the value that was originally at the end of the array will be at location pivotIndex – 1, so we will return that value back to the quicksort function so it can split the array into two parts based on that value.",
    "description": "Now that we’ve seen an example of how quicksort works, let’s walk through the pseudocode of a quicksort function. The function itself is very simple, as shown below.\nfunction QUICKSORT(ARRAY, START, END)\t(1) # base case size \u003c= 1\tif START \u003e= END then\t(2)\treturn\t(3) end if\t(4) PIVOTINDEX = PARTITION(ARRAY, START, END)\t(5) QUICKSORT(ARRAY, START, PIVOTINDEX – 1)\t(6) QUICKSORT(ARRAY, PIVOTINDEX + 1, END)\t(7) end function\t(8)This implementation of quicksort uses a simple base case on lines 2 through 4 to check if the array is either empty, or contains one element.",
    "tags": [],
    "title": "Quicksort Pseudocode",
    "uri": "/cc310/7-searching-and-sorting/19-quicksort-pseudocode/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "To wrap up our analysis of the quicksort algorithm, let’s take a look at the time complexity of the algorithm. Quicksort is a very difficult algorithm to analyze, especially since the selection of the pivot value is random and can greatly affect the performance of the algorithm. So, we’ll talk about quicksort’s time complexity in terms of two cases, the worst case and the average case. Let’s look at the average case first\nAverage case complexity What would the average case of quicksort look like? This is a difficult question to answer and requires a bit of intuition and making a few assumptions. The key really lies in how we choose our pivot value.\nFirst, let’s assume that the data in our array is equally distributed. This means that the values are evenly spread between the lowest value and the highest value, with no large clusters of similar values anywhere. While this may not always be the case in the real world, often we can assume that our data is somewhat equally distributed.\nSecond, we can also assume that our chosen pivot value is close to the average value in the array. If the array is equally distributed and we choose a value at random, we have a $50\\%$ chance of that value being closer to the average than either the minimum or the maximum value, so this is a pretty safe assumption.\nWith those two assumptions in hand, we see that something interesting happens. If we choose the average value as our pivot value, quicksort will perfectly partition the array into two equal sized halves! This is a great result, because it means that each recursive call to the function will be working with data that is half the initial array.\nIf we consider an array that initially contains $15$ elements, and make sure that we always choose the average element as our pivot point, we’d end up with a tree of recursive calls that resembles the diagram below.\nIn this diagram, we see that each level of the tree looks at around $N$ elements. (It is actually fewer, but not by a significant amount so we can just round up to $N$ each time). We also notice that there are 4 levels to the tree, which is closely approximated by $\\text{lg}(N)$. This is the same result we observed when analyzing the merge sort algorithm earlier in this module.\nSo, in the average case, we’d say that quicksort runs in the order of $N * \\text{lg}(N)$ time.\nWorst case complexity To consider the worst-case situation for quicksort, we must come up with a way to define what the worst-case input would be. It turns out that the selection of our pivot value is the key here.\nConsider the situation where the pivot value is chosen to be the maximum value in the array. What would happen in that case?\nLooking at the code, we would see that each recursive call would contain one empty partition, and the other partition would be just one less than the size of the original array. So, if our original array only contained 8 elements, our tree recursion diagram would look similar to the following.\nThis is an entirely different result! In this case, since we are only reducing the size of our array by 1 at each level, it would take $N$ recursive calls to complete. However, at each level, we are looking at one fewer element. Is this better or worse than the average case?\nIt turns out that it is much worse. As we learned in our analysis of selection sort and bubble sort, the series\n$$\rN + (N – 1) + (N – 2) + ... + 2 + 1\r$$ is best approximated by $N^2$. So, we would say that quicksort runs in the order of $N^2$ time in the worst case. This is just as slow as selection sort and bubble sort! Why would we ever call it “quicksort” if it isn’t any faster?\nThankfully, in practice, it is very rare to run into this worst-case performance with quicksort, and in fact most research shows that quicksort is often the fastest of the four sorting algorithms we’ve discussed so far. In the next section, we’ll discuss these performance characteristics a bit more.\nThis result highlights why it is important to consider both the worst case and average case performance of our algorithms. Many times we’ll write an algorithm that runs well most of the time, but is susceptible to poor performance when given a particular worst-case input.",
    "description": "To wrap up our analysis of the quicksort algorithm, let’s take a look at the time complexity of the algorithm. Quicksort is a very difficult algorithm to analyze, especially since the selection of the pivot value is random and can greatly affect the performance of the algorithm. So, we’ll talk about quicksort’s time complexity in terms of two cases, the worst case and the average case. Let’s look at the average case first",
    "tags": [],
    "title": "Quicksort Time Complexity",
    "uri": "/cc310/7-searching-and-sorting/20-quicksort-time-complexity/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "Once we’ve written a program, how can we verify that it works correctly? There are many ways to do this, but one of the most common is unit testing.\nUnit Testing Unit testing a program involves writing code that actually runs the program and verifies that it works correctly. In addition, many unit tests will also check that the program produces appropriate errors when given bad input, or even that it won’t crash when given invalid input.\nFor example, a simple unit test for the maximum() method would be:\nfunction MAXIMUMTEST() ARRAY = new array[5] ARRAY[0] = 5 ARRAY[1] = 25 ARRAY[2] = 10 ARRAY[3] = 15 ARRAY[4] = 0 RESULT = MAXIMUM(ARRAY) if RESULT == 25: print \"Test Passed\" end if end functionThis code will simply create an array that we know the maximum value of, and then confirm that our own maximum() method will find the correct result.\nOf course, this is a very simplistic unit test, and it would take several more unit tests to fully confirm that the maximum() method works completely correctly.\nHowever, it is important to understand how this test relates to the preconditions and postconditions that were established on previous pages. Here, the unit tests creates a variable ARRAY which is an array of at least one numerical value. Therefore, it has met the preconditions for the maximum() method, so we can assume that if maximum() is written correctly, then the postconditions will be true once it is has executed. This is the key assumption behind unit tests.\nWhy Does This Matter? In this course, you will be asked to build several data structures and implement algorithms that use those data structures. In the assignment descriptions, we may describe these methods using the preconditions and postconditions applied to them. Similarly, we’ll learn about structural invariants of data structures, which help us ensure that your data structures are always valid.\nThen, to grade your work, we use an autograder that contains several unit tests. Those unit tests are used to confirm that you code works correctly, and they do so by providing input that either satisfies the preconditions, meaning that the test expects that the postconditions will be true, or by providing invalid input and testing how your code reacts to those situations.\nYou’ll see these concepts throughout this course, so it is important to be familiar with them now.",
    "description": "Once we’ve written a program, how can we verify that it works correctly? There are many ways to do this, but one of the most common is unit testing.\nUnit Testing Unit testing a program involves writing code that actually runs the program and verifies that it works correctly. In addition, many unit tests will also check that the program produces appropriate errors when given bad input, or even that it won’t crash when given invalid input.",
    "tags": [],
    "title": "Unit Testing",
    "uri": "/cc310/03-intro-dsa/20-unit-test/"
  },
  {
    "breadcrumb": "Introduction to Data Structures \u0026 Algorithms",
    "content": "In this chapter, we introduced a number of different data structures that we can use in our programs. In addition, we explored several algorithmic techniques we can use to develop algorithms that manipulate these data structures to allow us to solve complex problems in our code.\nThroughout the rest of this course, as well as a subsequent course, we’ll explore many of these data structures and techniques in detail. We hope that introducing them all at the same time here will allow us to compare and contrast each one as we learn more about it, while still keeping in mind that there are many different structures and techniques that will be available to us in the future.",
    "description": "In this chapter, we introduced a number of different data structures that we can use in our programs. In addition, we explored several algorithmic techniques we can use to develop algorithms that manipulate these data structures to allow us to solve complex problems in our code.\nThroughout the rest of this course, as well as a subsequent course, we’ll explore many of these data structures and techniques in detail. We hope that introducing them all at the same time here will allow us to compare and contrast each one as we learn more about it, while still keeping in mind that there are many different structures and techniques that will be available to us in the future.",
    "tags": [],
    "title": "Data Structures \u0026 Algorithms Summary",
    "uri": "/cc310/03-intro-dsa/21-dsa-summary/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "We introduced four sorting algorithms in this chapter: selection sort, bubble sort, merge sort, and quicksort. In addition, we performed a basic analysis of the time complexity of each algorithm. In this section, we’ll revisit that topic and compare sorting algorithms based on their performance, helping us understand what algorithm to choose based on the situation.\nOverall Comparison The list below shows the overall result of our time complexity analysis for each algorithm.\nSelection Sort: $N^2$ Bubble Sort: $N^2$ Merge Sort: $N * \\text{lg}(N)$ Quicksort Average Case: $N * \\text{lg}(N)$ Quicksort Worst Case: $N^2$ We have expressed the amount of time each algorithm takes to complete in terms of the size of the original input $N$. But how does $N^2$ compare to $N * \\text{lg}(N)$?\nOne of the easiest ways to compare two functions is to graph them, just like we’ve learned to do in our math classes. The diagram below shows a graph containing the functions $N$, $N^2$, and $N * \\text{lg}(N)$.\nFirst, notice that the scale along the X axis (representing values of $N$) goes from 0 to 10, while the Y axis (representing the function outputs) goes from 0 to 30. This graph has been adjusted a bit to better show the relationship between these functions, but in actuality they have a much steeper slope than is shown here.\nAs we can see, the value of $N^2$ at any particular place on the X axis is almost always larger than $N * \\text{lg}(N)$, while that function’s output is almost always larger than $N$ itself. We can infer from this that functions which run in the order of $N^2$ time will take much longer to complete than functions which run in the order of $N * \\text{lg}(N)$ time. Likewise, the functions which run in the order of $N * \\text{lg}(N)$ time themselves are much slower than functions which run in linear time, or in the order of $N$ time.\nBased on that assessment alone, we might conclude that we should always use merge sort! It is guaranteed to run in $N * \\text{lg}(N)$ time, with no troublesome worst-case scenarios to consider, right? Unfortunately, as with many things in the real world, it isn’t that simple.\nChoosing Sorting Algorithms The choice of which sorting algorithm to use in our programs largely comes down to what we know about the data we have, and how that information can impact the performance of the algorithm. This is true for many other algorithms we will write in this class. Many times there are multiple methods to perform a task, such as sorting, and the choice of which method we use largely depends on what we expect our input data to be.\nFor example, consider the case where our input data is nearly sorted. In that instance, most of the items are in the correct order, but a few of them, maybe less than $10\\%$, are slightly out of order. In that case, what if we used a version of bubble sort that was optimized to stop sorting as soon as it makes a pass through the array without swapping any elements? Since only a few elements are out of order, it may only take a few passes with bubble sort to get them back in the correct places. So even though bubble sort runs in $N^2$ time, the actual time may be much quicker.\nLikewise, if we know that our data is random and uniformly distributed, we might want to choose quicksort. Even though quicksort has very slow performance in the worst case, if our data is properly random and distributed, research shows that it will have better real-world performance than most other sorting algorithms in that instance.\nFinally, what if we know nothing about our input data? In that case, we might want to choose merge sort as the safe bet. It is guaranteed to be no worse than $N * \\text{lg}(N)$ time, even if the input is truly bad. While it might not be as fast as quicksort if the input is random, it won’t run the risk of being slow, either.",
    "description": "We introduced four sorting algorithms in this chapter: selection sort, bubble sort, merge sort, and quicksort. In addition, we performed a basic analysis of the time complexity of each algorithm. In this section, we’ll revisit that topic and compare sorting algorithms based on their performance, helping us understand what algorithm to choose based on the situation.\nOverall Comparison The list below shows the overall result of our time complexity analysis for each algorithm.",
    "tags": [],
    "title": "Performance of Sorting Algorithms",
    "uri": "/cc310/7-searching-and-sorting/21-performance-of-sorting-algorithms/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": " Now that we’ve learned how to sort the data in our container, let’s go back and revisit the concept of searching once again. Does our approach change when we know the data has been sorted?\nOur intuition tells us that it should. Recall that we discussed how much easier it would be to find a particular paper in a sorted filing cabinet rather than just searching through a random pile of papers on the floor. The same concept applies to data in our programs.\nThe most commonly used searching algorithm when dealing with sorted data is binary search. The idea of the algorithm is to compare the value in the middle of the container with the value we are looking for. In this case, let’s assume the container is sorted in ascending order, so the smaller elements are before the larger ones. If we compare our desired value with the middle value, there are three possible outcomes:\nthe value in the middle is equal to the desired value. We have found the element! the value in the middle is less than the desired value. Since the container is ordered in ascending order, we must search for the value in the second half of the container. the value in the middle is greater than the desired value. Since the container is ordered in ascending order, we must search for the value in the first half of the container. Once an occurrence of the desired value is found, we can also look at the values before it to see if there any more of the desired values in the container. Since it is sorted, they should all be grouped together. If we want our algorithm to return the index of the first occurrence of the desired value, we can simply move toward the front of the array until we find that first occurrence.\nBinary Search Example Let’s work through a quick example of the binary search algorithm to see how it works in practice. Let’s assume we have the array shown in the diagram below, which is already sorted in ascending order. We wish to find out if the array contains the value 5. So, we’ll store that in our value variable. We also have variables start and end representing the first and last index in the array that we are considering.\nFirst, we must calculate the middle index of the array. To do that, we can use the following formula.\n$$\r\\text{int}((\\text{start} + \\text{end}) / 2)\r$$ In this case, we’ll find that the middle index is 5.\nNext, we’ll compare our desired value with the element at the middle index, which is 2. Since our desired value 5 is greater than 2, we know that 5 must be present in the second half of the array. We will then update our starting value to be one greater than the middle element and start over. In practice, this could be done either iteratively or recursively. We’ll see both implementations later in this section. The portion of the array we are ignoring has been given a grey background in the diagram below.\nOnce again, we’ll start by calculating a new middle index. In this case, it will be 8.\nThe value at index 8 is 7, which is greater than our desired value 5. So we know that 5 should be in the first half of the array from index 6 through 10. We need to update the end variable to be one less than middle and try once again.\nWe’ll first calculate the middle index, which will be 6. This is because (6 + 7) / 2 is 6.5, but when we convert it to an integer it will be truncated, resulting in just 6.\nSince the value at index 6 is 4, which is less than our desired value 5, we know that we should be looking at the portion of the array which comes after our middle element. Once again, we’ll update our start index to be one greater than the middle and start over.\nIn this case, since both start and end are the same, we know that the middle index will also be 7. We can compare the value at index 7 to our desired value. As it turns out, they are a match, so we’ve found our value! We can just return middle as the index for this value. Of course, if we want to make sure it is the first instance of our desired value, we can quickly check the elements before it until we find one that isn’t our desired value. We won’t worry about that for now, but it is something that can easily be added to our code later.",
    "description": "Now that we’ve learned how to sort the data in our container, let’s go back and revisit the concept of searching once again. Does our approach change when we know the data has been sorted?\nOur intuition tells us that it should. Recall that we discussed how much easier it would be to find a particular paper in a sorted filing cabinet rather than just searching through a random pile of papers on the floor.",
    "tags": [],
    "title": "Binary Search",
    "uri": "/cc310/7-searching-and-sorting/22-binary-search/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "The binary search algorithm is easily implemented in both an iterative and recursive function. We’ll look at both versions and see how they compare.\nThe pseudocode for an iterative version of binary search is shown below.\nfunction BINARYSEARCH(ARRAY, VALUE)\t(1) START = 0\t(2) END = size of ARRAY - 1\t(3) loop while START \u003c= END\t(4) MIDDLE = INT((START + END) / 2)\t(5) if ARRAY[MIDDLE] == VALUE then\t(6) return MIDDLE\t(7) else if ARRAY[MIDDLE] \u003e VALUE then\t(8) END = MIDDLE – 1\t(9) else if ARRAY[MIDDLE] \u003c VALUE then\t(10) START = MIDDLE + 1\t(11) end if\t(12) end loop\t(13) return -1\t(14) end function\t(15)This function starts by setting the initial values of start and end on lines 2 and 3 to the first and last indexes in the array, respectively. Then, the loop starting on line 4 will repeat while the start index is less than or equal to the end index. If we reach an instance where start is greater than end, then we have searched the entire array and haven’t found our desired value. At that point the loop will end and we will return -1 on line 14.\nInside of the loop, we first calculate the middle index on line 5. Then on line 6 we check to see if the middle element is our desired value. If so, we should just return the middle index and stop. It is important to note that this function will return the index to an instance of value in the array, but it may not be the first instance. If we wanted to find the first instance, we’d add a loop at line 7 to move forward in the array until we were sure we were at the first instance of value before returning.\nIf we didn’t find our element, then the if statements on lines 8 and 10 determine which half of the array we should look at. Those statements update either end or start as needed, and then the loop repeats.",
    "description": "The binary search algorithm is easily implemented in both an iterative and recursive function. We’ll look at both versions and see how they compare.\nThe pseudocode for an iterative version of binary search is shown below.\nfunction BINARYSEARCH(ARRAY, VALUE)\t(1) START = 0\t(2) END = size of ARRAY - 1\t(3) loop while START \u003c= END\t(4) MIDDLE = INT((START + END) / 2)\t(5) if ARRAY[MIDDLE] == VALUE then\t(6) return MIDDLE\t(7) else if ARRAY[MIDDLE] \u003e VALUE then\t(8) END = MIDDLE – 1\t(9) else if ARRAY[MIDDLE] \u003c VALUE then\t(10) START = MIDDLE + 1\t(11) end if\t(12) end loop\t(13) return -1\t(14) end function\t(15)This function starts by setting the initial values of start and end on lines 2 and 3 to the first and last indexes in the array, respectively.",
    "tags": [],
    "title": "Iterative Binary Search",
    "uri": "/cc310/7-searching-and-sorting/23-iterative-binary-search/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "The recursive implementation of binary search is very similar to the iterative approach. However, this time we also include both start and end as parameters, which we update at each recursive call. The pseudocode for a recursive binary search is shown below.\nfunction BINARYSEARCHRECURSE(ARRAY, VALUE, START, END)\t(1) # base case if START \u003e END then\t(2) return -1\t(3) end if\t(4) MIDDLE = INT((START + END) / 2)\t(5) if ARRAY[MIDDLE] == VALUE then\t(6) return MIDDLE\t(7) else if ARRAY[MIDDLE] \u003e VALUE then\t(8) return BINARYSEARCHRECURSE(ARRAY, VALUE, START, MIDDLE – 1)\t(9)\telse if ARRAY[MIDDLE] \u003c VALUE then\t(10) return BINARYSEARCHRECURSE(ARRAY, VALUE, MIDDLE + 1, END)\t(11) end if\t(12) end function\t(13)The recursive version moves the loop’s termination condition to the base case, ensuring that it returns -1 if the start index is greater than the end index. Otherwise, it performs the same process of calculating the middle index and checking to see if it contains the desired value. If not, it uses the recursive calls on lines 9 and 11 to search the first half or second half of the array, whichever is appropriate.",
    "description": "The recursive implementation of binary search is very similar to the iterative approach. However, this time we also include both start and end as parameters, which we update at each recursive call. The pseudocode for a recursive binary search is shown below.\nfunction BINARYSEARCHRECURSE(ARRAY, VALUE, START, END)\t(1) # base case if START \u003e END then\t(2) return -1\t(3) end if\t(4) MIDDLE = INT((START + END) / 2)\t(5) if ARRAY[MIDDLE] == VALUE then\t(6) return MIDDLE\t(7) else if ARRAY[MIDDLE] \u003e VALUE then\t(8) return BINARYSEARCHRECURSE(ARRAY, VALUE, START, MIDDLE – 1)\t(9)\telse if ARRAY[MIDDLE] \u003c VALUE then\t(10) return BINARYSEARCHRECURSE(ARRAY, VALUE, MIDDLE + 1, END)\t(11) end if\t(12) end function\t(13)The recursive version moves the loop’s termination condition to the base case, ensuring that it returns -1 if the start index is greater than the end index.",
    "tags": [],
    "title": "Recursive Binary Search",
    "uri": "/cc310/7-searching-and-sorting/24-recursive-binary-search/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "Analyzing the time complexity of binary search is similar to the analysis done with merge sort. In essence, we must determine how many times it must check the middle element of the array.\nIn the worst case, it will continue to do this until it has determined that the value is not present in the array at all. Any time that our array doesn’t contain our desired value would be our worst-case input.\nIn that instance, how many times do we look at the middle element in the array? That is hard to measure. However, it might be easier to measure how many elements are in the array each time and go from there.\nConsider the situation where we start with 15 elements in the array. How many times can we divide the array in half before we are down to just a single element? The diagram below shows what this might look like.\nAs it turns out, this is similar to the analysis we did on merge sort and quick sort. If we divide the array in half each time, we will do this $\\text{lg}(N)$ times. The only difference is that we are only looking at a single element, the shaded element, at each level. So the overall time complexity of binary search is on the order of $\\text{lg}(N)$. That’s pretty fast!",
    "description": "Analyzing the time complexity of binary search is similar to the analysis done with merge sort. In essence, we must determine how many times it must check the middle element of the array.\nIn the worst case, it will continue to do this until it has determined that the value is not present in the array at all. Any time that our array doesn’t contain our desired value would be our worst-case input.",
    "tags": [],
    "title": "Binary Search Time Complexity",
    "uri": "/cc310/7-searching-and-sorting/25-binary-search-time-complexity/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": " Let’s go back and look at the performance of our sorting algorithms, now that we know how quickly binary search can find a particular value in an array. Let’s add the function $\\text{lg}(N)$ to our graph from earlier, shown below.\nAs we can see, the function $\\text{lg}(N)$ is even smaller than $N$. So performing a binary search is much faster than a linear search, which we already know runs in the order of $N$ time.\nHowever, performing a single linear search is still faster than any of the sorting algorithms we’ve reviewed. So when does it become advantageous to sort our data?\nThis is a difficult question to answer since it depends on many factors. However, a good rule of thumb is to remember that the larger the data set, or the more times we need to search for a value, the better off we are to sort the data before we search.\nIn the graph below, the topmost line colored in red shows the approximate running time of $10$ linear search operations, while the bottom line in black shows the running time of performing a merge sort before $10$ binary search operations.\nAs we can see, it is more efficient to perform a merge sort, which runs in $N * \\text{lg}(N)$ time, then perform $10$ binary searches running in $\\text{lg}(N)$ time, than it is to perform $10$ linear searches running in $N$ time. The savings become more pronounced as the size of the input gets larger, as indicated by the X axis on the graph.\nIn fact, this analysis suggests that it may only take as few as 7 searches to see this benefit, even on smaller data sets. So, if we are writing a program that needs to search for a specific value in an array more than about 7 times, it is probably a good idea to sort the array before doing our searches, at least from a performance standpoint.\nTip Faster Sorting So far we’ve looked at sorting algorithms that run in $N * \\text{lg}(N)$ time. However, what if we try to sort the data as we add it to the array? In a later course, we’ll learn how we can use an advanced data structure known as a heap to create a sorted array in nearly linear time (with some important caveats, of course)!",
    "description": "Let’s go back and look at the performance of our sorting algorithms, now that we know how quickly binary search can find a particular value in an array. Let’s add the function $\\text{lg}(N)$ to our graph from earlier, shown below.\nAs we can see, the function $\\text{lg}(N)$ is even smaller than $N$. So performing a binary search is much faster than a linear search, which we already know runs in the order of $N$ time.",
    "tags": [],
    "title": "The Importance of Sorting",
    "uri": "/cc310/7-searching-and-sorting/26-the-importance-of-sorting/"
  },
  {
    "breadcrumb": "Searching and Sorting",
    "content": "In this chapter, we learned how to search for values in an array using a linear search method. Then, we explored four different sorting algorithms, and compared them based on their time complexity. Finally, we learned how we can use a sorted array to perform a faster binary search and saw how we can increase our performance by sorting our array before searching in certain situations.\nSearching and sorting are two of the most common operations performed in computer programs, and it is very important to have a deep understanding of how they work. Many times the performance of a program can be improved simply by using the correct searching and sorting algorithms to fit the program’s needs, and understanding when you might run into a particularly bad worst-case input.\nThe project in this module will involve implementing several of these algorithms in the language of your choice. As we learn about more data structures, we’ll revisit these algorithms again to discuss how they can be improved or adapted to take advantage of different structures.\nReferences Mergesort iterative without a stack\nhttps://www.geeksforgeeks.org/iterative-merge-sort/ https://www.techiedelight.com/iterative-merge-sort-algorithm-bottom-up/ Quicksort iterative with a stack\nhttps://www.geeksforgeeks.org/iterative-quick-sort/ Bubble sort recursive\nGiordano, D., \u0026 Maiorana, F. (2015, March). Teaching algorithms: Visual language vs flowchart vs textual language. In 2015 IEEE Global Engineering Education Conference (EDUCON) (pp. 499-504). IEEE. ",
    "description": "In this chapter, we learned how to search for values in an array using a linear search method. Then, we explored four different sorting algorithms, and compared them based on their time complexity. Finally, we learned how we can use a sorted array to perform a faster binary search and saw how we can increase our performance by sorting our array before searching in certain situations.\nSearching and sorting are two of the most common operations performed in computer programs, and it is very important to have a deep understanding of how they work.",
    "tags": [],
    "title": "Searching and Sorting Summary",
    "uri": "/cc310/7-searching-and-sorting/27-searching-and-sorting-summary/"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/cc310/categories/"
  },
  {
    "breadcrumb": "",
    "content": "This is the homepage",
    "description": "This is the homepage",
    "tags": [],
    "title": "CC 310 Textbook",
    "uri": "/cc310/"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/cc310/tags/"
  }
]
