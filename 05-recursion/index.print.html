




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="def: recursion (noun) - see recursion">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Recursion :: CC 310 Textbook">
    <meta name="twitter:description" content="def: recursion (noun) - see recursion">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/05-recursion/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Recursion :: CC 310 Textbook">
    <meta property="og:description" content="def: recursion (noun) - see recursion">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Recursion :: CC 310 Textbook">
    <meta itemprop="description" content="def: recursion (noun) - see recursion">
    <meta itemprop="dateModified" content="2024-06-29T14:21:25-05:00">
    <meta itemprop="wordCount" content="6">
    <title>Recursion :: CC 310 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc310/05-recursion/" rel="canonical" type="text/html" title="Recursion :: CC 310 Textbook">
    <link href="/cc310/05-recursion/index.xml" rel="alternate" type="application/rss+xml" title="Recursion :: CC 310 Textbook">
    <link href="/cc310/05-recursion/tele.html" rel="alternate" type="text/html" title="Recursion :: CC 310 Textbook">
    <link href="/cc310/05-recursion/embed.html" rel="alternate" type="text/html" title="Recursion :: CC 310 Textbook">
    <link href="/cc310/css/fontawesome-all.min.css?1719695057" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1719695057" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1719695057" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1719695057" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1719695057" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1719695057" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1719695057" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1719695057" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1719695057" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1719695057" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1719695057" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1719695057" rel="stylesheet">
    <link href="/cc310/css/print.css?1719695057" rel="stylesheet" media="print">
    <link href="/cc310/css/format-print.css?1719695057" rel="stylesheet">
    <script src="/cc310/js/variant.js?1719695057"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1719695057" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc310/05-recursion/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Recursion</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/04-list/19-summary/" title="Lists Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/05-recursion/01-recursion-intro/" title="Introducing Recursion (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 25</div>

<h1 id="recursion">Recursion</h1>

<p>def: recursion (noun) - see <em>recursion</em></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Recursion</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introducing-recursion">Introducing Recursion</h1>


<a href="https://www.youtube.com/watch?v=GALIjmSovzM">YouTube Video</a>

<p>We are now used to using functions in our programs that allow us to decompose complex problems into smaller problems that are easier to solve. Now, we will look at a slight wrinkle in how we use functions. Instead of simply having functions call other functions, we now allow for the fact that a function can actually call itself! When a function calls itself, we call it <em>recursion</em>.</p>
<p>Using recursion often allows us to solve complex problems elegantly&mdash;with only a few lines of code. Recursion is an alternative to using loops and, theoretically, any function that can be solved with loops can be solved with recursion and vice versa.</p>
<h2 id="example-palindromes">Example: Palindromes</h2>
<p>So why would a function want to call itself? When we use recursive functions, we are typically trying to break the problem down into smaller versions of itself. For example, suppose we want to check to see if a word is a palindrome (i.e., it is spelled the same way forwards and backwards). How would we do this recursively? Typically, we would check to see if the first and last characters were the same. If so, we would check the rest of the word between the first and last characters. We would do this over and over until we got down to the 0 or 1 characters in the middle of the word. Let&rsquo;s look at what this might look like in pseudocode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function isPalindrome (String S) returns Boolean
</span></span><span class="line"><span class="cl">    if length of S &lt; 2 then
</span></span><span class="line"><span class="cl">        return true
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return (first character in S == last character in S) and 
</span></span><span class="line"><span class="cl">                isPalindrome(substring of S without first and last character)
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>First, we&rsquo;ll look at the <code>else</code> part of the <code>if</code> statement. Essentially, this statement determines if the first and last characters of <code>S</code> match, and then calls itself recursively to check the rest of the word <code>S</code>. Of course, if the first and last characters of <code>S</code> match and the rest of the string is a palindrome, the function will return <code>true</code>. However, we can&rsquo;t keep calling <code>isPalindrome</code> recursively forever. At some point we have to stop. That is what the <code>if</code> part of the statement does. We call this our base case. When we get to the point where the length of the string we are checking is <code>0</code> or <code>1</code> (i.e., <code>&lt; 2</code>), we know we have reached the middle of the word. Since all strings of length 0 or 1 are, by definition, palindromes, we return <code>true</code>.</p>
<h2 id="key-idea-break-up-the-problem">Key Idea: Break Up the Problem</h2>
<p>The key idea of recursion is to break the problem into simpler subproblems until you get to the point where the solution to the problem is trivial and can be solved directly; this is the base case. The algorithm design technique is a form of divide-and-conquer called <em>decrease-and-conquer</em>. In decrease-and-conquer, we reduce our problem into smaller versions of the larger problem.</p>
<p>A recursive program is broken into two parts:</p>
<ul>
<li>a <strong>base case</strong>&mdash;a simple version of the problem that can be solved directly, and</li>
<li>a <strong>recursive case</strong>&mdash;a general solution to the problem that uses smaller versions of the problem to compute the solution to the larger problem.</li>
</ul>
<p>The base case is generally the final case we consider in a recursive function and serves to both end the recursive calls and to start the process of returning the final answer to our problem. To avoid endless cycles of recursive calls, it is imperative that we check to ensure that:</p>
<ol>
<li>a base case exists where no further recursive calls are made, and</li>
<li>it is possible to reach the base case; the recursive case must ensure that we are moving closer to the base case with each recursive call.</li>
</ol>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="example-reversing-a-string">Example: Reversing a String</h1>

<p>Suppose we must write a program that reads in a sequence of keyboard characters and prints them in reverse order. The user ends the sequence by typing an asterisk character <code>*</code>.</p>
<p>We could solve this problem using an array, but since we do not know how many characters might be entered before the <code>*</code>, we could not be sure the program would actually work. However, we can use a recursive function since its ability to save the input data is not limited by a predefined array size.</p>
<p>Our solution would look something like this. We&rsquo;ve also numbered the lines to make the following discussion easier to understand.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">REVERSE</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">read</span> <span class="n">CHARACTER</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="n">CHARACTER</span> <span class="o">==</span> <span class="err">`</span><span class="o">*</span><span class="err">`</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">REVERSE</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="nb">print</span> <span class="n">CHARACTER</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<h2 id="base-case">Base Case</h2>
<p>The function first reads a single character from the keyboard and stores it in <code>CHARACTER</code>. Then, in line 3 it checks to see if the user typed the <code>*</code> character. If so, we simply return, knowing that we have reached the end of the input and need to start printing out the characters we&rsquo;ve read in reverse order. This is the <em>base case</em> for this recursive function.</p>
<h2 id="recursive-case">Recursive Case</h2>
<p>If the <code>CHARACTER</code> we read in was not an <code>*</code>, line 6 will recursively call <code>REVERSE</code> to continue reading characters. Once the function returns (meaning that we have gotten an <code>*</code> character and started the return process) the function prints the <code>CHARACTER</code> in line 7 and then returns itself.</p>
<h2 id="behind-the-scenes">Behind the Scenes</h2>
<p>Now let&rsquo;s look at what happens within the computer when we run <code>REVERSE</code>. Let&rsquo;s say the program user wants to enter the three characters from the keyboard: <code>n</code>, <code>o</code>, and <code>w</code> followed by the <code>*</code> character. The following figure illustrates the basic concept of what is going on in the computer.</p>
<p><a href="#R-image-804bd35197161726f069f489ce892f62" class="lightbox-link"><img alt="Reverse Head Recursive Activation Stack" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.2.reverse-head.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-804bd35197161726f069f489ce892f62"><img alt="Reverse Head Recursive Activation Stack" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.2.reverse-head.png"></a></p>
<p>The arrows in the figure represent the order of execution of the statements in the computer. Each time we execute the recursive call to <code>REVERSE</code> in line 6, we create a new instance of the function, which starts its execution back at the beginning of the function (line 2). Then, when the function executes <code>return</code>, control reverts back to the next statement to be executed (line 7) in the calling instance of the function.</p>
<p>It&rsquo;s important to understand that each instance of the function has its own set of variables whose values are unique to that instance. When we read <code>n</code> into the <code>CHARACTER</code> variable in the first instance of <code>REVERSE</code> it is not affected by anything that happens in the second instance of <code>REVERSE</code>.  Therefore, reading the <code>o</code> into <code>CHARACTER</code> in the second instance of <code>REVERSE</code> does not affect the value of <code>CHARACTER</code> in the first instance of <code>REVERSE</code>.</p>
<p>During the execution of the first instance of <code>REVERSE</code>, the user enters the character <code>n</code> so the <code>if</code> condition is <code>false</code> and we execute the <code>else</code> part of the statement, which calls the <code>REVERSE</code> function. (Note that before we actually start the second instance of <code>REVERSE</code>, the operating system stores the statement where we will pick up execution once the called function returns.) When the second instance of <code>REVERSE</code> is started, a new copy of all variables is created as well to ensure we do not overwrite the values from the first instance.</p>
<p>The execution of the second instance of  <code>REVERSE</code> runs exactly like the first instance except that the user enters the character <code>o</code> instead of <code>n</code>. Again, the <code>else</code> part of the <code>if</code> statement is executed, which calls the <code>REVERSE</code> function. When the third instance of <code>REVERSE</code> is executed, the user now inputs <code>w</code>, which again causes a new instance of <code>REVERSE</code> to be called.</p>
<p>Finally, in the fourth instance of <code>REVERSE</code>, the user inputs the <code>*</code> character, which causes the <code>if</code> part of the statement to execute, which performs our <code>return</code> statement. Once the <code>return</code> from the base case of our recursive function is performed, it starts the process of ending all the instances of the <code>REVERSE</code> function and creating the solution. When instance 4 of the <code>REVERSE</code> function returns, execution starts at the <code>write</code> statement (line 7) of instance 3. Here the character <code>w</code> is printed, and the function returns to instance 2. The same process is carried out in instance 2, which prints the <code>o</code> character and returns. Likewise, instance 1 prints its character <code>n</code> and then returns. The screen should now show the full output of the original call to <code>REVERSE</code> , which is &ldquo;won&rdquo;.</p>
<p>Recursion has allowed us to create a very simple and elegant solution to the problem of reversing an arbitrary number of characters. While you can do this in a non-recursive way using loops, the solution is not that simple. If you don&rsquo;t believe us, just try it! (Yes, that is a challenge.)</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="implementing-recursion">Implementing Recursion</h1>


<a href="https://www.youtube.com/watch?v=CwAAKKRSWI0">YouTube Video</a>

<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">REVERSE2</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">read</span> <span class="n">CHARACTER</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="n">CHARACTER</span> <span class="o">==</span> <span class="err">`</span><span class="o">*</span><span class="err">`</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="nb">print</span> <span class="n">CHARACTER</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">REVERSE2</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>The <code>REVERSE2</code> function in the previous quiz actually prints the characters entered by the user in the same order in which they are typed. Notice how this small variation in the instruction order significantly changed the outcome of the function. To get a better understanding of why this occurs, we will delve into the order of execution in a little more depth.</p>
<h2 id="head-and-tail-recursion">Head and Tail Recursion</h2>
<p>From the output of our original <code>REVERSE</code> function, we could argue that recursive function calls are carried out in a LIFO (last in, first out) order. Conversely, the output of the second version of the function <code>REVERSE2</code>, would lead us to believe that recursive function calls are carried out in FIFO (first in, first out) order. However, the ordering of the output is really based on how we structure our code within the recursive function itself, not the order of execution of the recursive functions.</p>
<p>To produce a LIFO ordering, we use a method called <em>head recursion</em>, which causes the function to make a recursive call first, then calculates the results once the recursive call returns. To produce a FIFO ordering, we use a method called <em>tail recursion</em>, which is when the function makes all of its necessary calculations before making a recursive call. With the <code>REVERSE</code> and <code>REVERSE2</code> functions, this is simply a matter of swapping lines 6 and 7.</p>
<p>While some functions require the use of either head or tail recursion, many times we have the choice of which one to use. The choice is not necessarily just a matter of style, as we shall see next.</p>
<h2 id="tracing-program-execution">Tracing Program Execution</h2>
<p>Before we finish our discussion of head and tail recursion, we need to make sure we understand how a recursive function actually works in the computer. To do this, we will use a new example. Let&rsquo;s assume we want to print all numbers from 0 to $N$, where $N$ is provided as a parameter. A recursive solution to this problem is shown below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">OUTPUT</span><span class="p">(</span><span class="n">integer</span> <span class="n">N</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        <span class="nb">print</span> <span class="n">N</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="nb">print</span> <span class="s2">&#34;Calling to OUTPUT &#34;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">OUTPUT</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="nb">print</span> <span class="s2">&#34;Returning from OUTPUT &#34;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="nb">print</span> <span class="n">N</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>Notice that we have added some extra <code>print</code> statements (lines 5 and 7) to the function just to help us keep track of when we have called <code>OUTPUT</code> and when that call has returned. This function is very similar to the <code>REVERSE</code> function above, we just don&rsquo;t have to worry about reading a character each time the function runs. Now, if we call <code>OUTPUT</code> with an initial parameter of <code>3</code>, we get the following output. We&rsquo;ve also marked these lines with letters to make the following discussion simpler.</p>
<div class="highlight"><pre tabindex="0"><code>Calling to OUTPUT 2         (a)
Calling to OUTPUT 1         (b)
Calling to OUTPUT 0         (c)
0                           (d)
Returning from OUTPUT 0     (e)
1                           (f)
Returning from OUTPUT 1     (g)
2                           (h)
Returning from OUTPUT 2     (i)
3                           (j)</code></pre></div><p>Lines a, b, and c show how the function makes all the recursive calls before any output or computation is performed. Thus, this is an example of head recursion which produces a LIFO ordering.</p>
<p>Once we get to the call of <code>OUTPUT(0)</code>, the function prints out <code>0</code> (line d) and we start the return process. When we return from the call to <code>OUTPUT(0)</code> we immediately print out <code>N</code>, which is <code>1</code> and return. We continue this return process from lines g through j and eventually return from the original call to <code>OUTPUT</code> having completed the task.</p>
<h2 id="looking-under-the-covers">Looking Under the Covers</h2>
<p>Now that we have seen how recursion works in practice, we will pull back the covers and take a quick look at what is going on underneath. To be able to call the same function over and over, we need to be able to store the appropriate data related to each function call to ensure we can treat it as a unique instance of the function. While we do not make copies of the code, we do need to make copies of other data. Specifically, when function <code>A</code> calls function <code>B</code>, we must save the following information:</p>
<ul>
<li>the memory address of the current parameters,</li>
<li>the address of the statement in function <code>A</code> to be executed when <code>B</code> returns (called the <em>return address</em>),</li>
<li>the address of the memory location that will contain the value returned by the function (the <em>value address</em>), and</li>
<li>all the local variables of function <code>B</code>.</li>
</ul>
<p>We call this information the <em>activation record</em> for function <code>A</code>. When a call to <code>B</code> is made, this information is stored in a stack data structure known as the <em>activation stack</em>, and execution begins at the first instruction in function <code>B</code>. Upon completion of function <code>B</code>, the following steps are performed.</p>
<ol>
<li>The return address is read from the activation stack.</li>
<li>The information stored about function B is removed from the activation stack, leaving the information stored for function A on top of the stack.</li>
<li>Execution begins at the return address in function A.</li>
</ol>
<p>Next, we will look at how we use the activation stack to implement recursion. For this we will use a simple <code>MAIN</code> program that calls our simplified <code>OUTPUT</code> function (where we have removed all the print statements used to track our progress).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">MAIN</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">OUTPUT</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="nb">print</span> <span class="p">(</span><span class="s2">&#34;Done&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">end</span> <span class="n">function</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">function</span> <span class="n">OUTPUT</span><span class="p">(</span><span class="n">integer</span> <span class="n">N</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="nb">print</span> <span class="n">N</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">OUTPUT</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="nb">print</span> <span class="n">N</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>When we run <code>MAIN</code>, the only record on the activation stack is the record for <code>MAIN</code>. Since it has not been &ldquo;called&rdquo; from another function, it does not contain a return address. It also has no local variables, so the record is basically empty as shown below.</p>
<p><a href="#R-image-aebdd753ad70331751131450bb209b3e" class="lightbox-link"><img alt="Main Activation Record" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.4.mainstack.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-aebdd753ad70331751131450bb209b3e"><img alt="Main Activation Record" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.4.mainstack.png"></a></p>
<p>However, when we execute line 2 in <code>MAIN</code>, we call the function <code>OUTPUT</code> with a parameter of <code>3</code>. This causes the creation of a new function activation record with the return address of line 3 in the calling <code>MAIN</code> function and a parameter for <code>N</code>, which is <code>3</code>. Again, there are no local variables in <code>OUTPUT</code>. The stack activation is shown in figure <strong>a</strong> below.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>a</strong></th>
<th style="text-align:center"><strong>b</strong></th>
<th style="text-align:center"><strong>c</strong></th>
<th style="text-align:center"><strong>d</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#R-image-2240f94fd4480ba462d4462397956dc1" class="lightbox-link"><img alt="Activation Stack 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.4.stack1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2240f94fd4480ba462d4462397956dc1"><img alt="Activation Stack 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.4.stack1.png"></a></td>
<td style="text-align:center"><a href="#R-image-1a262c353eb0ad5716fe7d278382294d" class="lightbox-link"><img alt="Activation Stack 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.4.stack2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1a262c353eb0ad5716fe7d278382294d"><img alt="Activation Stack 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.4.stack2.png"></a></td>
<td style="text-align:center"><a href="#R-image-15fce30a29374abe05ecbd994d650fd7" class="lightbox-link"><img alt="Activation Stack 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.4.stack3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-15fce30a29374abe05ecbd994d650fd7"><img alt="Activation Stack 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.4.stack3.png"></a></td>
<td style="text-align:center"><a href="#R-image-0b570544e16f93a361257d63ec54a760" class="lightbox-link"><img alt="Activation Stack 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.4.stack4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0b570544e16f93a361257d63ec54a760"><img alt="Activation Stack 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.4.stack4.png"></a></td>
</tr>
</tbody>
</table>
<p>Following the execution for <code>OUTPUT</code>, we will eventually make our recursive call to <code>OUTPUT</code> in line 10, which creates a new activation record on the stack as shown above in <strong>b</strong>. This time, the return address will be line 11 and the parameter <code>N</code> is <code>2</code>.</p>
<p>Execution of the second instance of <code>OUTPUT</code> will follow the first instance, eventually resulting in another recursive call to <code>OUTPUT</code> and a new activation record as shown in <strong>c</strong> above. Here the return address is again <code>5</code> but now the value of parameter <code>N</code> is <code>1</code>.  Execution of the third instance of <code>OUTPUT</code> yields similar results, giving us another activation record on the stack <strong>d</strong> with the value of parameter <code>N</code> being <code>0</code>.</p>
<p>Finally, the execution of the fourth instance of <code>OUTPUT</code> will reach our base case of <code>N == 0</code>. Here we will <code>write 0</code> in line 8 and then <code>return</code>. This return will cause us to start execution back in the third instance of <code>OUTPUT</code> at the line indicated by the return value, or in this case, 11. The stack activation will now look like <strong>e</strong> in the figure below.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>e</strong></th>
<th style="text-align:center"><strong>f</strong></th>
<th style="text-align:center"><strong>g</strong></th>
<th style="text-align:center"><strong>h</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#R-image-f7bd7698afcc9bd5b246eaa048f4e417" class="lightbox-link"><img alt="Activation Stack 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.4.stack3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f7bd7698afcc9bd5b246eaa048f4e417"><img alt="Activation Stack 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.4.stack3.png"></a></td>
<td style="text-align:center"><a href="#R-image-0481012b00abc6e9f14a611fb980923d" class="lightbox-link"><img alt="Activation Stack 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.4.stack2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0481012b00abc6e9f14a611fb980923d"><img alt="Activation Stack 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.4.stack2.png"></a></td>
<td style="text-align:center"><a href="#R-image-24ce6ea05912ebe97fccaf759e4c540c" class="lightbox-link"><img alt="Activation Stack 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.4.stack1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-24ce6ea05912ebe97fccaf759e4c540c"><img alt="Activation Stack 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.4.stack1.png"></a></td>
<td style="text-align:center"><a href="#R-image-edb2087b0ba87fec3ae3f72ffae2d27e" class="lightbox-link"><img alt="Main Activation Record" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.4.mainstack.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-edb2087b0ba87fec3ae3f72ffae2d27e"><img alt="Main Activation Record" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.4.mainstack.png"></a></td>
</tr>
</tbody>
</table>
<p>When execution begins in the third instance of <code>OUTPUT</code> at line 11, we again write the current value of <code>N</code>, which is <code>1</code>, and we then <code>return</code>. We follow this same process, returning to the second instance of <code>OUTPUT</code>, then the first instance of <code>OUTPUT</code>. Once the initial instance of <code>OUTPUT</code> completes, it returns to line 3 in <code>MAIN</code>, where the <code>print(&quot;Done&quot;)</code> statement is executed and <code>MAIN</code> ends.</p>
<h2 id="performance">Performance</h2>
<p>While recursion is a very powerful technique, its expressive power has an associated cost in terms of both time and space. Anytime we call a function, a certain amount of memory space is needed to store information on the activation stack. In addition, the process of calling a function takes extra time since we must store parameter values and the return address, etc. before restarting execution. In the general case, a recursive function will take more time and more memory than a similar function computed using loops.</p>
<h2 id="recursion-versus-iteration">Recursion Versus Iteration</h2>
<p>It is possible to demonstrate that any function with a recursive structure can be transformed into an iterative function that uses loops and vice versa. It is also important to know how to use both mechanisms because there are advantages and disadvantages for both iterative and recursive solutions. While we&rsquo;ve discussed the fact that loops are typically faster and take less memory than similar recursive solutions, it is also true that recursive solutions are generally more elegant and easier to understand. Recursive functions can also allow us to find solutions to problems that are complex to write using loops.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="example-factorials">Example: Factorials</h1>

<p>The most popular example of using recursion is calculating the factorial of a positive integer $N$. The factorial of a positive integer $N$ is just the product of all the integers from $1$ to $N$. For example, the factorial of $5$, written as $5!$, is calculated as $5 * 4 * 3 * 2 * 1 = 120$. The definition of the factorial function itself is recursive.</p>
$$
\text{fact}(N) = N  *  \text{fact}(N - 1)
$$
<p>The corresponding pseudocode is shown below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function FACT(N)
</span></span><span class="line"><span class="cl">    if N == 1
</span></span><span class="line"><span class="cl">        return 1
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return N * FACT(N-1)
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>The recursive version of the factorial is slower than the iterative version, especially for high values of $N$. However, the recursive version is simpler to program and more elegant, which typically results in programs that are easier to maintain over their lifetimes.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="tree-recursion">Tree Recursion</h1>


<a href="https://www.youtube.com/watch?v=R6rXXaVx7DU">YouTube Video</a>

<p>In the previous examples we saw recursive functions that call themselves one time within the code. This type of recursion is called <em>linear recursion</em>, where head and tail recursion are two specific types of linear recursion.</p>
<p>In this section we will investigate another type of recursion called <em>tree recursion</em>, which occurs when a function calls itself two or more times to solve a single problem. To illustrate tree recursion, we will use a simple recursive function <code>MAX</code>, which finds the maximum of $N$ elements in an array. To calculate the maximum of $N$ elements we will use the following recursive algorithm.</p>
<ol>
<li>Compute the maximum of the first $N/2$ elements and store in <code>MAX1</code>.</li>
<li>Compute the maximum of the last $N/2$ elements and store in <code>MAX2</code>.</li>
<li>Compare <code>MAX1</code> and <code>MAX2</code> to find the maximum of all elements.</li>
</ol>
<p>Our process recursively decomposes the problem by searching for the maximum in the first $N/2$ elements and the second $N/2$ elements until we reach the base case. In this problem, the base case is when we either have 1 or 2 elements in the array. If we just have 1, we return that value. If we have 2, we return the larger of those two values. An overview of the process is shown below.</p>
<p><a href="#R-image-2ffce04b6fd80603e2d8406e49da1804" class="lightbox-link"><img alt="Tree Recursion" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.6.tree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2ffce04b6fd80603e2d8406e49da1804"><img alt="Tree Recursion" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.6.tree.png"></a></p>
<p>The pseudocode for the algorithm is shown below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function MAX(VALUES, START, END)
</span></span><span class="line"><span class="cl">    print &#34;Called MAX with start = &#34; + START + &#34;, end = &#34; + END
</span></span><span class="line"><span class="cl">    if END â€“ START = 0
</span></span><span class="line"><span class="cl">        return VALUES[START]
</span></span><span class="line"><span class="cl">    else if END â€“ START = 1
</span></span><span class="line"><span class="cl">        if VALUES(START) &gt; VALUES(END)
</span></span><span class="line"><span class="cl">            return VALUES[START]
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return VALUES[END]
</span></span><span class="line"><span class="cl">        end if
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        MIDDLE = ROUND((END â€“ START) / 2) 
</span></span><span class="line"><span class="cl">        MAX1 = MAX(VALUES, START, START + MIDDLE â€“ 1)
</span></span><span class="line"><span class="cl">        MAX2 = MAX(VALUES, START + MIDDLE, END)
</span></span><span class="line"><span class="cl">        if MAX1 &gt; MAX2
</span></span><span class="line"><span class="cl">            return MAX1
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return MAX2
</span></span><span class="line"><span class="cl">        end if
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>The following block shows the output from the <code>print</code> line in the <code>MAX</code> function above. The initial call to the function is <code>MAX(VALUES, 0, 15)</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">Called MAX with start = 0, end = 7
</span></span><span class="line"><span class="cl">Called MAX with start = 0, end = 3
</span></span><span class="line"><span class="cl">Called MAX with start = 0, end = 1
</span></span><span class="line"><span class="cl">Called MAX with start = 2, end = 3
</span></span><span class="line"><span class="cl">Called MAX with start = 4, end = 7
</span></span><span class="line"><span class="cl">Called MAX with start = 4, end = 5
</span></span><span class="line"><span class="cl">Called MAX with start = 6, end = 7
</span></span><span class="line"><span class="cl">Called MAX with start = 8, end = 15
</span></span><span class="line"><span class="cl">Called MAX with start = 8, end = 11
</span></span><span class="line"><span class="cl">Called MAX with start = 8, end = 9
</span></span><span class="line"><span class="cl">Called MAX with start = 10, end = 11
</span></span><span class="line"><span class="cl">Called MAX with start = 12, end = 15
</span></span><span class="line"><span class="cl">Called MAX with start = 12, end = 13
</span></span><span class="line"><span class="cl">Called MAX with start = 14, end = 15</span></span></code></pre></div><p>As you can see, <code>MAX</code> decomposes the array each time it is called, resulting in 14 instances of the <code>MAX</code> function being called. If we had performed head or tail recursion to compare each value in the array, we would have to have called <code>MAX</code> 16 times. While this may not seem like a huge savings, as the value of $N$ grows, so do the savings.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="example-fibonacci-numbers">Example: Fibonacci Numbers</h1>


<a href="https://www.youtube.com/watch?v=Qw_SJrtYI88">YouTube Video</a>

<p>Next, we will look at calculating Fibonacci numbers using a tree recursive algorithm. Fibonacci numbers are given by the following recursive formula.</p>
$$
f_n = f_{n-1} + f_{n-2}
$$
<p>Notice that Fibonacci numbers are defined recursively, so they should be a perfect application of tree recursion! However, there are cases where recursive functions are too inefficient compared to an iterative version to be of practical use. This typically happens when the recursive solutions to a problem end up solving the same subproblems multiple times. Fibonacci numbers are a great example of this phenomenon.</p>
<h2 id="calculating-fibonacci-numbers">Calculating Fibonacci Numbers</h2>
<p>To complete the definition, we need to specify the base case, which includes two values for the first two Fibonacci numbers: <code>FIB(0) = 0</code> and <code>FIB(1) = 1</code>. The first Fibonacci numbers are $0, 1, 1, 2, 3, 5, 8, 13, 21 â€¦$.</p>
<p>Producing the code for finding Fibonacci numbers is very easy from its definition. The extremely simple and elegant solution to computing Fibonacci numbers recursively is shown below.</p>
<div class="highlight"><pre tabindex="0"><code>function FIB(N)
    if N == 0
        return 0
    else if N == 1
        return 1
    else
        return FIB(N-1) + FIB(N-2)
    end if
end function</code></pre></div><p>The following pseudocode performs the same calculations for the iterative version.</p>
<div class="highlight"><pre tabindex="0"><code>function FIBIT(N)
    FIB1 = 1
    FIB2 = 0
    for (I = 2 to N)
        FIB = FIB1 + FIB2
        FIB2 = FIB1
        FIB1 = FIB
    end loop
end function</code></pre></div><p>While this function is not terribly difficult to understand, there is still quite a bit of mental gymnastics required to see how this implements the computation of Fibonacci numbers and even more to prove that it does so correctly. However, as we will see later, the performance improvements of the iterative solution are worth it.</p>
<p>If we analyze the computation required for the 6th Fibonacci number in both the iterative and recursive algorithms, the truth becomes evident. The recursive algorithm calculates the 5th Fibonacci number by recursively calling <code>FIB(4)</code> and <code>FIB(3)</code>. In turn, <code>FIB(4)</code> calls <code>FIB(3)</code> and <code>FIB(2)</code>. Notice that <code>FIB(3)</code> is actually calculated twice! This is a problem. If we calculate the 36th Fibonacci number, the values of many Fibonacci numbers are calculated repeatedly, over and over.</p>
<h2 id="tracing-the-program">Tracing the Program</h2>
<p>To clarify our ideas further, we can consider the recursive tree resulting from the trace of the program to calculate the 6th Fibonacci number. Each of the computations highlighted in the diagram will have been computed previously.</p>
<p><a href="#R-image-e0ce03eaf5c5c998c006c43da1b9a85f" class="lightbox-link"><img alt="Fibonacci Tree Recursion" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.8.fib1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e0ce03eaf5c5c998c006c43da1b9a85f"><img alt="Fibonacci Tree Recursion" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.8.fib1.png"></a></p>
<p>If we count the recomputations, we can see how we calculate the 4th Fibonacci number twice, the 3rd Fibonacci number three times, and the 2nd Fibonacci five times. All of this is due to the fact the we do not consider the work done by other recursive calls. Furthermore, the higher our initial number, the worse the situation grows, and at a very rapid pace.</p>
<h2 id="memoization">Memoization</h2>
<p>To avoid recomputing the same Fibonacci number multiple times, we can save the results of various calculations and reuse them directly instead of recomputing them. This technique is called <em>memoization</em>, which can be used to optimize some functions that use tree recursion.</p>
<p>To implement memoization, we simply store the values the first time we compute them in an array. The following pseudocode shows an efficient algorithm that uses an array, called <code>FA</code>, to store and reuse Fibonacci numbers.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function FIBOPT(N)
</span></span><span class="line"><span class="cl">    if N == 0
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">    else if N == 1
</span></span><span class="line"><span class="cl">        return 1
</span></span><span class="line"><span class="cl">    else if FA[N] == -1
</span></span><span class="line"><span class="cl">        FA[N] = FIBOPT(N-1) + FIBOPT(N-2)
</span></span><span class="line"><span class="cl">        return FA[N]
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return FA[N]
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>We assume that each element in <code>FA</code> has been initialized to <code>-1</code>. We also assume that <code>N</code> is greater than <code>0</code> and that the length of <code>FA</code> is larger than the Fibonacci number <code>N</code> that we are trying to compute. (Of course, we would normally put these assumptions in our precondition; however, since we are focusing on the recursive nature of the function, we will not explicitly show this for now.) The cases where <code>N == 0</code> and <code>N == 1</code> are the same as we saw in our previous <code>FIB</code> function. There is no need to store these values in the array when we can return them directly, since storing them in the array takes additional time. The interesting cases are the last two. First, we check to see if <code>FA[N] == -1</code>, which would indicate that we have not computed the Fibonacci number for <code>N</code> yet. If we have not yet computed <code>N</code>&rsquo;s Fibonacci number, we recursively call <code>FIBOPT(N-1)</code> and <code>FIBOPT(N-2)</code> to compute its value and then store it in the array and return it. If, however, we have already computed the Fibonacci for <code>N</code> (i.e., if <code>FA[N]</code> is not equal to <code>-1</code>), then we simply return the value stored in the array, <code>FA[N]</code>.</p>
<p>As shown in our original call tree below, using the <code>FIBOPT</code> function, none of the function calls in red will be made at all. While the function calls in yellow will be made, they will simply return a precomputed value from the <code>FA</code> array. Notice that for <code>N = 6</code>, we save 14 of the original 25 function calls required for the <code>FIB</code> function, or a $56\%$ savings. As <code>N</code> increases, the savings grow even more.</p>
<p><a href="#R-image-50ccfeaffd74b6756b9e3e5f8072d029" class="lightbox-link"><img alt="Fibonacci Tree Recursion with Memoization" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.8.fib2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-50ccfeaffd74b6756b9e3e5f8072d029"><img alt="Fibonacci Tree Recursion with Memoization" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.8.fib2.png"></a></p>

  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Memoization in Python</div>
  <div class="box-content">

<p>Memoization in Python can also be done using <a href="https://www.codecademy.com/resources/docs/python/memoization" rel="external" target="_blank">dictionaries</a> or the <a href="https://docs.python.org/3/library/functools.html#functools.cache" rel="external" target="_blank">functools.cache</a> method decorator.</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="example-tower-of-hanoi">Example: Tower of Hanoi</h1>

<p>There are some problems where an iterative solution is difficult to implement and is not always immediately intuitive, while a recursive solution is simple, concise and easy to understand. A classic example is the problem of the <em><a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi" rel="external" target="_blank">Tower of Hanoi</a></em>.</p>
<p>The Tower of Hanoi is a game that lends itself to a recursive solution. Suppose we have three towers on which we can put discs. The three towers are indicated by a letter, A, B, or C.</p>
<p>Now, suppose we have $N$ discs all of different sizes. The discs are stacked on tower A based on their size, smaller discs on top. The problem is to move all the discs from one tower to another by observing the following rules:</p>
<ol>
<li>we can move only one disc at a time, and we must move the disc that is at the top of a tower first, and</li>
<li>a larger disc can never be put on top of a smaller disc.</li>
</ol>
<p>To try to solve the problem let&rsquo;s start by considering a simple case: we want to move two discs from tower A to tower C. As a convenience, suppose we number the discs in ascending order by assigning the number 1 to the larger disc. The solution in this case is simple and consists of the following steps:</p>
<ol>
<li>move disc 2 from tower A to tower B,</li>
<li>move disc 1 from tower A to tower C, and</li>
<li>move disc 2 from Tower B to tower C.</li>
</ol>
<p>The following figure shows how the algorithm works.</p>
<p><a href="#R-image-fbbda98beb28a81a54a2d8dbbf1ad781" class="lightbox-link"><img alt="Tower of Hanoi" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/6/6.9.tower.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fbbda98beb28a81a54a2d8dbbf1ad781"><img alt="Tower of Hanoi" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/6/6.9.tower.png"></a></p>
<p>It is a little more difficult with three discs, but after a few tries the proper algorithm emerges. With our knowledge of recursion, we can come up with a simple and concise solution. Since we already know how to move two discs from one place to another, we can solve the problem recursively.</p>
<ol>
<li>Move discs 3 and 2 from tower A to B.</li>
<li>Move disc 1 from tower A to C.</li>
<li>Move discs 3 and 2 from tower B to C.</li>
</ol>
<p>In formulating our solution, we assumed that we could move two discs from one tower to another, since we have already solved that part of the problem above. In step 1, we use this solution to move the top two discs from tower A to B. Then, in step 3, we again use that solution to move two discs from tower B to C.
This process can now easily be generalized to the case of N discs as described below.</p>
<ol>
<li>Move the first N-1 discs from tower A to B.</li>
<li>Move disc 1 from tower A to C.</li>
<li>Move N -1 discs from tower B to C.</li>
</ol>
<p>The algorithm is captured in the following pseudocode. Here <code>N</code> is the total number of discs, <code>ORIGIN</code> is the tower where the discs are currently located, and <code>DESTINATION</code> is the tower where they need to be moved. Finally, <code>TEMP</code> is a temporary tower we can use to help with the move. All the parameters are integers.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function HANOI(N, ORIGIN, DESTINATION, TEMP)
</span></span><span class="line"><span class="cl">    if N &gt;= 0
</span></span><span class="line"><span class="cl">        HANOI(N-1, ORIGIN, TEMP, DESTINATION)
</span></span><span class="line"><span class="cl">        Move disc N from ORIGIN to DESTINATION
</span></span><span class="line"><span class="cl">        HANOI(N-1, TEMP, DESTINATION, ORIGIN)
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">    return
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>The function moves the $N$ discs from the source tower to the destination tower using a temporary tower. To do this, it calls itself to move the first $N-1$ discs from the source tower to the temporary tower. It then moves the bottom disc from the source tower to the destination tower. The function then moves the $N-1$ discs present in the temporary tower into the destination tower.</p>
<p>The list of movements to solve the three-disc problem is shown below.</p>
<ol>
<li>move disc 3 from ORIGIN to DESTINATION</li>
<li>move disc 2 from ORIGIN to TEMP</li>
<li>move disc 3 from DESTINATION to TEMP</li>
<li>move disc 1 from ORIGIN to DESTINATION</li>
<li>move disc 3 from TEMP to ORIGIN</li>
<li>move disc 2 from TEMP to DESTINATION</li>
</ol>
<p>Iterative solutions to the Tower of Hanoi problem do exist, but it took many researchers several years to find an efficient solution. The simplicity of finding the recursive solution presented here should convince you that recursion is an approach you should definitely keep in your bag of tricks!</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="converting-recursion-to-iteration">Converting Recursion to Iteration</h1>

<p>Iteration and recursion have the same expressive power, which means that any problem that has a recursive solution also has an iterative solution and vice versa. There are also standard techniques that allow you to transform a recursive program into an equivalent iterative version. The simplest case is for tail recursion, where the recursive call is the last step in the function. There are two cases of tail recursion to consider when converting to an iterative version.</p>
<ol>
<li>If the recursive function does not have any parameters or the parameters are passed by reference, the conversion is very simple. We just use a simple while loop.</li>
<li>If the recursive function uses parameters passed by value, the conversion is a little more complicated. In general, if the last statement a function <code>f(x)</code> executes is a call to itself, <code>f(y)</code> with parameter <code>y</code>, the recursive call can be replaced by an assignment statement, <code>x = y</code>, and by looping back to the beginning of function <code>f</code>.</li>
</ol>
<p>The approach above only solves the conversion problem in the case of tail recursion. However, as an example, consider our original <code>FACT</code> function and its iterative version <code>FACT2</code>. Notice that in <code>FACT2</code> we had to add a variable <code>fact</code> to keep track of the actual computation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function FACT(N)
</span></span><span class="line"><span class="cl">    if N == 1
</span></span><span class="line"><span class="cl">        return 1
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return N * FACT(N-1)
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function FACT2(N)
</span></span><span class="line"><span class="cl">   fact = 1 
</span></span><span class="line"><span class="cl">   while N &gt; 0
</span></span><span class="line"><span class="cl">       fact = fact * N
</span></span><span class="line"><span class="cl">       N = N - 1
</span></span><span class="line"><span class="cl">   end while
</span></span><span class="line"><span class="cl">   return fact
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>The conversion of non-tail recursive functions typically uses two loops to iterate through the process, effectively replacing recursive calls. The first loop executes statements before the original recursive call, while the second loop executes the statements after the original recursive call. The process also requires that we use a stack to save the parameter and local variable values each time through the loop. Within the first loop, all the statements that precede the recursive call are executed, and then, before the loop terminates, the values of interest are pushed onto the stack. The second loop starts by popping the values saved on the stack and then executing the remaining statements that come after the original recursive call. This is typically much more difficult than the conversion process for tail recursion.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="recursion-summary">Recursion Summary</h1>

<p>In this module, we explored the use of <em>recursion</em> to write concise solutions for a variety of problems. Recursion allows us to call a function from within itself, using either <em>head recursion</em>, <em>tail recursion</em> or <em>tree recursion</em> to solve smaller instances of the original problem.</p>
<p>Recursion requires a <em>base case</em>, which tells our function when to stop calling itself and start returning values, and a <em>recursive case</em> to handle reducing the problem&rsquo;s size and calling the function again, sometimes multiple times.</p>
<p>We can use recursion in many different ways, and any problem that can be solved iteratively can also be solved recursively. The power in recursion comes from its simplicity in code&mdash;some problems are much easier to solve recursively than iteratively.</p>
<p>Unfortunately, in general a recursive solution requires more computation time and memory than an iterative solution. We can use techniques such as <em>memoization</em> to greatly improve the time it takes for a recursive function to execute, especially in the case of calculating Fibonacci numbers where subproblems are overlapped.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc310/commit/05c48f27a6bd3fa923b5f7511c2110a0ab3257a7">Jun 29, 2024</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc310/js/clipboard.min.js?1719695057" defer></script>
    <script src="/cc310/js/perfect-scrollbar.min.js?1719695057" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cc310/js/mathjax/tex-mml-chtml.js?1719695057"></script>
    <script src="/cc310/js/theme.js?1719695057" defer></script>
  </body>
</html>
