




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Welcome! This page is the main page for Lists">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Lists :: CC 310 Textbook">
    <meta name="twitter:description" content="Welcome! This page is the main page for Lists">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/9-lists/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Lists :: CC 310 Textbook">
    <meta property="og:description" content="Welcome! This page is the main page for Lists">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Lists :: CC 310 Textbook">
    <meta itemprop="description" content="Welcome! This page is the main page for Lists">
    <meta itemprop="datePublished" content="2021-08-17T00:00:00+00:00">
    <meta itemprop="dateModified" content="2021-08-17T10:22:02-05:00">
    <meta itemprop="wordCount" content="9">
    <title>Lists :: CC 310 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc310/9-lists/" rel="canonical" type="text/html" title="Lists :: CC 310 Textbook">
    <link href="/cc310/9-lists/index.xml" rel="alternate" type="application/rss+xml" title="Lists :: CC 310 Textbook">
    <link href="/cc310/9-lists/tele.html" rel="alternate" type="text/html" title="Lists :: CC 310 Textbook">
    <link href="/cc310/9-lists/embed.html" rel="alternate" type="text/html" title="Lists :: CC 310 Textbook">
    <link href="/cc310/css/fontawesome-all.min.css?1719522555" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1719522555" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1719522555" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1719522555" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1719522555" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1719522555" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1719522555" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1719522555" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1719522555" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1719522555" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1719522555" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1719522555" rel="stylesheet">
    <link href="/cc310/css/print.css?1719522555" rel="stylesheet" media="print">
    <link href="/cc310/css/format-print.css?1719522555" rel="stylesheet">
    <script src="/cc310/js/variant.js?1719522555"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1719522555" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc310/9-lists/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Lists</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/8-queues/8-queues-summary/" title="Queues Summary (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/9-lists/1-what-is-a-list-/" title="What is a List? (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 45</div>

<h1 id="lists">Lists</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Lists</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Lists</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="what-is-a-list">What is a List?</h1>


<a href="https://www.youtube.com/watch?v=F1uVJeej-WM">YouTube Video</a>

<p>A list is a data structure that holds a sequence of data, such as the shopping list shown below. Each list has a head item and a tail item, with all other items placed linearly between the head and the tail. As we pick up items in the store, we will remove them, or cross them off the list. Likewise, if we get a text from our housemate to get some cookies, we can add them to the list as well.</p>
<p><a href="#R-image-5bac29a11e907461e6df269bdf999dee" class="lightbox-link"><img alt="Shopping List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.1.shopping.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5bac29a11e907461e6df269bdf999dee"><img alt="Shopping List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.1.shopping.png"></a>^[Source: https://www.agclassroom.org/teacher/matrix/lessonplan.cfm?lpid=367]</p>
<p>Lists are actually very general structures that we can use for a variety of purposes. One common example is the history section of a web browser. The web browser actually creates a list of past web pages we have visited, and each time we visit a new web page it is added to the list. That way, when we check our history, we can see all the web pages we have visited recently in the order we visited them. The list also allows us to scroll through the list and select one to revisit or select another one to remove from the history altogether.</p>
<p>Of course, we have already seen several instances of lists so far in programming, including arrays, stacks, and queues. However, lists are much more flexible than the arrays, stacks, and queues we have studied so far. Lists allow us to add or remove items from the head, tail, or anywhere in between. We will see how we can actually implement stacks and queues using lists later in this module.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="lists-in-the-real-world">Lists in the Real World</h1>

<p>Most of us see and use lists every day. We have a list for shopping as we saw above, but we may also have a &ldquo;to do&rdquo; list, a list of homework assignments, or a list of movies we want to watch. Some of us are list-makers and some are not, but we all know a list when we see it.</p>
<p><a href="#R-image-56fc91bd5eee429270f881a2c51d9690" class="lightbox-link"><img alt="Playlist" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.2.playlist.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-56fc91bd5eee429270f881a2c51d9690"><img alt="Playlist" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.2.playlist.png"></a>^[Source: https://wiki.videolan.org/index.php?title=File:Basic_playlist_default.png&amp;oldid=59730]</p>
<p>However, there are other lists in the real world that we might not even think of as a list. For instance, a playlist on our favorite music app is an example of a list. A music app lets us move forward or backward in a list or choose a song randomly from a list. We can even reorder our list whenever we want.</p>
<p>All the examples we&rsquo;ve seen for stacks and queues can be thought of as lists as well. Stacks of chairs or moving boxes, railroad trains, and cars going through a tollbooth are all examples of special types of lists.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="lists-in-code">Lists in Code</h1>

<h2 id="the-problem-with-arrays">The Problem With Arrays</h2>
<p>To this point, we have been using arrays as our underlying data structures for implementing linear data structures such as stacks and queues. Given that with stacks and queues we only put items into the array and remove from either the start or end of the data structure, we have been able to make arrays work. However, there are some drawbacks to using arrays for stacks and queues as well as for more general data structures.</p>
<ol>
<li>We can run out of room in our array for our stacks or queues.</li>
<li>There is no good way to use memory efficiently. We have to use expensive &ldquo;double&rdquo; and &ldquo;halve&rdquo; capacity operations for stacks and queues when we need to use more or less memory.</li>
<li>Inserting an item into the middle of a sorted list will be very costly in memory. In an array, we will have to move several items to keep the list in order.</li>
</ol>
<p>While drawbacks 1 and 2 above can be overcome (albeit rather awkwardly) when using arrays for stacks and queues, drawback 3 becomes a real problem when trying to use more general list structures. If we insert an item into the middle of an array, we must move several other items &ldquo;down&rdquo; the array to make room.</p>
<p>If for example, if we want to insert the number 5 into the sorted array shown below, we have to carry out several steps:</p>
<p><a href="#R-image-f96ec9ab5758e149eef8452dfcf11c22" class="lightbox-link"><img alt="Array Insertion 0" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.3.insert0.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f96ec9ab5758e149eef8452dfcf11c22"><img alt="Array Insertion 0" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.3.insert0.png"></a></p>
<ol>
<li>Find the index of the first item whose value is greater than the number we want to insert into the array. We will call this index <code>i</code>,</li>
<li>Shift each item from index <code>i</code>  to the end of the list down one place location in the array,</li>
<li>Insert the new item into the array at index <code>i</code>, and</li>
<li>Update the index to the tail of the list.</li>
</ol>
<p>In our example, step 1 will loop through each item of the array until we find the first number in the array greater than 5. As shown below, the number 7 is found in index 3.</p>
<p><a href="#R-image-d9af3e4a775899f32af5b0fcddc26755" class="lightbox-link"><img alt="Array Insertion 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.3.insert1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d9af3e4a775899f32af5b0fcddc26755"><img alt="Array Insertion 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.3.insert1.png"></a></p>
<p>Next, we will use another loop to move each item from index <code>i</code> to the end of the array down by one index number as shown below.</p>
<p><a href="#R-image-53bea912581483c84e1f8f2f69b8f706" class="lightbox-link"><img alt="Array Insertion 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.3.insert2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-53bea912581483c84e1f8f2f69b8f706"><img alt="Array Insertion 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.3.insert2.png"></a></p>
<p>Finally, we will insert our new number, 5, into the array at index 3 and increment tail to 8.</p>
<p><a href="#R-image-6b68e0d71f383f48ed23872818a657fe" class="lightbox-link"><img alt="Array Insertion 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.3.insert3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6b68e0d71f383f48ed23872818a657fe"><img alt="Array Insertion 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.3.insert3.png"></a></p>
<p>In this operation, if we have $N$ items, we either compare or move all of them, which would require $N$ operations. Of course, this operation runs in order $N$ time.</p>
<p>The same problem occurs when we remove an item from the array. In this case we must perform the following steps:</p>
<ol>
<li>Search the array to find the first occurrence of the desired number to remove,</li>
<li>Continue searching until we find the last occurrence of the desired number to remove,</li>
<li>Shift each item after the last occurrence of our desired number &ldquo;up&rdquo; the array, once for each desired number being removed from the array, and</li>
<li>Update the index to the tail of the list.</li>
</ol>
<h2 id="a-more-flexible-approach">A More Flexible Approach</h2>
<p>Instead of using arrays to try to hold our lists, a more flexible approach is to build our own list data structure that relies on a set of objects that are all linked together through references to each other. In the figure below we have created a list of numbers that are linked to each other. Each object contains both the number as well as a reference to the next number in the list. Using this structure, we can search through each item in the list by starting sequentially from the beginning and performing a linear search much like we did with arrays. However, instead of explicitly keeping track of the end of the list, we use the convention that the reference in the last item of the list is set to <code>0</code>, which we call <code>null</code>. If a reference is set to <code>null</code> we interpret this to mean that there is no next item in the list. This &ldquo;linked list&rdquo; structure also makes inserting items into the middle of the list easier. All we need to do is find the location in the list where we want to insert the item and then adjust the references to include the new item into the list.</p>
<p><a href="#R-image-fcc7b8d95c3faf5de0723fa90089c1e1" class="lightbox-link"><img alt="Singly Linked List Overview" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.3.overview.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fcc7b8d95c3faf5de0723fa90089c1e1"><img alt="Singly Linked List Overview" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.3.overview.png"></a></p>
<p>The following figure shows a slightly more complex version of a linked list, called a &ldquo;doubly linked list&rdquo;. Instead of just having each item in the list reference the next item, it references the previous item in the list as well. The main advantage of doubly linked lists is that we can easily traverse the list in either the forward or backward direction. Doubly linked lists are useful in applications to implement undo and redo functions, and in web browser histories where we want the ability to go forward and backward in the history.</p>
<p><a href="#R-image-51edc4df53ae30142ecb03817e898245" class="lightbox-link"><img alt="Doubly Linked List Overview" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.3.double.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-51edc4df53ae30142ecb03817e898245"><img alt="Doubly Linked List Overview" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.3.double.png"></a></p>
<p>We will investigate each of these approaches in more detail below and will reimplement both our stack and queue operations using linked lists instead of arrays.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="singly-linked-lists">Singly Linked Lists</h1>


<a href="https://www.youtube.com/watch?v=U-abMlixblw">YouTube Video</a>

<h2 id="linked-node">Linked Node</h2>
<p>To solve the disadvantages of arrays, we need a data structure that allows us to insert and remove items in an ordered collection in constant time, independently from the number of items in the data structure.</p>
<p>The solution lies in creating our own specialized data structure where each node contains the data of interest as well as a reference, or pointer to the next node in the list. Of course, we would also need to have a pointer to the first node in the list, which we call the <code>head</code>.</p>
<p>The figure below shows how we can construct a linked list data structure. The <code>head</code> entity shown in the figure is a variable that contains a pointer to the first node in the list, in this case the node containing <code>-2</code>. Each node in the list is an object that has two main parts: the data that it holds, and a pointer to the next item in the list.</p>
<p><a href="#R-image-5296d2780de5e9fac4a7d5ced9e35b44" class="lightbox-link"><img alt="Linked Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.listnode.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5296d2780de5e9fac4a7d5ced9e35b44"><img alt="Linked Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.listnode.png"></a></p>
<p>The class representation of a singly linked list <code>Node</code> is shown below. As discussed above, we have two attributes: <code>data</code>, which holds the data of the node, and <code>next</code>, which is a reference or pointer to the next node. We also use a constructor and a standard <code>toString</code> operation to appropriately create a string representation for the data stored in the node.</p>
<p><a href="#R-image-d14c8d8c5c8b5c1d1db6294b96255fe0" class="lightbox-link"><img alt="Linked Node UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.listnodeuml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d14c8d8c5c8b5c1d1db6294b96255fe0"><img alt="Linked Node UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.listnodeuml.png"></a></p>
<h2 id="linked-list">Linked List</h2>
<p>A list is represented by a special variable <code>head</code> that contains a pointer to the first item in the list. If the <code>head</code> is <code>null</code> (equal to <code>0</code>), then we have an empty list, which is a list with no items in it.</p>
<p>However, if we have items in the list, <code>head</code> will point to a node as shown in the figure below. This node has some data (in this case <code>-2</code>) and its own pointer that points to the next node in the list. As we can see in our example, <code>head</code> points to a sequence of five nodes that makes up our list. The node with the data 67 in it is the last item in the list since its pointer is <code>null</code>. We often refer to this condition as having a <code>null</code> pointer.</p>
<p><a href="#R-image-34621b37cb62231666c4b7cfb7aca65e" class="lightbox-link"><img alt="Linked List Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.single.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-34621b37cb62231666c4b7cfb7aca65e"><img alt="Linked List Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.single.png"></a></p>
<p>While we will not show them explicitly in this module, each pointer is actually an address in memory. If we have a pointer to node <code>X</code> in our node, that means that we actually store the address of <code>X</code> in memory in our node.</p>
<h2 id="linked-list-class">Linked List Class</h2>
<p>To capture the necessary details for a singly linked list, we put everything into a class. The singly linked list class has two attributes:</p>
<ul>
<li><code>list</code>&mdash;the pointer to the first node in the list, and</li>
<li><code>size</code>&mdash;an integer to keep track of the number of items in the list.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">Class SingleLinkedList 
</span></span><span class="line"><span class="cl">    Node head
</span></span><span class="line"><span class="cl">    Integer size = 0</span></span></code></pre></div><p>While we would normally create getter and setter methods for each attribute in the class, to simplify and clarify our pseudocode below we use &ldquo;dot notation&rdquo; to refer directly to the attributes in the node. The following table illustrates our usage in this module.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Use</th>
<th style="text-align:center">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>node</code></td>
<td style="text-align:center"><a href="#R-image-bfcad95172f44e2011ff2f437b9cfa06" class="lightbox-link"><img alt="Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.node.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bfcad95172f44e2011ff2f437b9cfa06"><img alt="Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.node.png"></a></td>
</tr>
<tr>
<td style="text-align:center"><code>node.next</code></td>
<td style="text-align:center"><a href="#R-image-79cb87ecdf989aabf05e801def06ac09" class="lightbox-link"><img alt="Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.node.next.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-79cb87ecdf989aabf05e801def06ac09"><img alt="Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.node.next.png"></a></td>
</tr>
<tr>
<td style="text-align:center"><code>node.next.next</code></td>
<td style="text-align:center"><a href="#R-image-86ebec995c20e6d4565ac9e67855a7a8" class="lightbox-link"><img alt="Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.node.next.next.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-86ebec995c20e6d4565ac9e67855a7a8"><img alt="Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.node.next.next.png"></a></td>
</tr>
<tr>
<td style="text-align:center"><code>head</code></td>
<td style="text-align:center"><a href="#R-image-e471c4518058b2352db3d704b661490b" class="lightbox-link"><img alt="Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.head.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e471c4518058b2352db3d704b661490b"><img alt="Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.head.png"></a></td>
</tr>
<tr>
<td style="text-align:center"><code>head.next</code></td>
<td style="text-align:center"><a href="#R-image-85d4f1a96ca2f542779adb39e6820c01" class="lightbox-link"><img alt="Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.4.head.next.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-85d4f1a96ca2f542779adb39e6820c01"><img alt="Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.4.head.next.png"></a></td>
</tr>
</tbody>
</table>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="singly-linked-lists---insertion">Singly Linked Lists - Insertion</h1>


<a href="https://www.youtube.com/watch?v=2TVtKD6jvQw">YouTube Video</a>

<p>Given the structure of our linked list, we can easily insert a new node at any location in the list. However, for our purposes we are generally interested in inserting new nodes at the beginning of the list, at some specific location in the list, or in the appropriate order if the list is sorted.</p>
<h2 id="inserting-at-the-beginning">Inserting at the Beginning</h2>
<p>Inserting a node at the beginning of a list is straightforward. We just have to be careful about the order we use when swapping pointers. In the <code>prepend</code> code below, line 1 creates the new node to be stored in the list. Next, line 2 assigns the pointer in the new node to point to the pointer held by the <code>head</code>. If there was an item already in the list, <code>head</code> will point to the previous first item in the list. If the list was empty, <code>head</code> will have been <code>null</code> and thus the <code>node.next</code> will become <code>null</code> as well. Line 3 assigns <code>head</code> to point to the new node and line 4 increments our size variable.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function prepend(data)
</span></span><span class="line"><span class="cl">    node = new Node(data)	(1) 
</span></span><span class="line"><span class="cl">	node.next = head 	    (2)
</span></span><span class="line"><span class="cl">	head = node			    (3)
</span></span><span class="line"><span class="cl">	size = size + 1		    (4)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>We show this process in the following example. The figure below shows the initial state as we enter the <code>prepend</code> operation. Our list has three items in it, an &ldquo;a&rdquo;, &ldquo;W&rdquo;, and &ldquo;Q&rdquo; and we want to add the new node &ldquo;M&rdquo; in front of item &ldquo;a&rdquo;.</p>
<p><a href="#R-image-0b8379501029c1a0fccf3fe3b3257a98" class="lightbox-link"><img alt="Singly Linked List Prepend 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0b8379501029c1a0fccf3fe3b3257a98"><img alt="Singly Linked List Prepend 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert1.png"></a></p>
<p>The figure below shows the effect of the first step of the operation. This step creates a new node for &ldquo;M&rdquo; and changes <code>next</code> to point at the same node as the pointer held by <code>head</code>, which is the address of the first item in the list, &ldquo;a&rdquo;.</p>
<p><a href="#R-image-ae9339bc2574197f1ec03208dd435164" class="lightbox-link"><img alt="Singly Linked List Prepend 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ae9339bc2574197f1ec03208dd435164"><img alt="Singly Linked List Prepend 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert2.png"></a></p>
<p>The result of performing line 3 in the operation is shown below. In line 3 we simply change <code>head</code> to point to our new node, instead of node &ldquo;a&rdquo;. Notice now that the new node has been fully inserted into the list.</p>
<p><a href="#R-image-11135b84bb5d02be27abb3e60716c5eb" class="lightbox-link"><img alt="Singly Linked List Prepend 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-11135b84bb5d02be27abb3e60716c5eb"><img alt="Singly Linked List Prepend 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert3.png"></a></p>
<p>And, if we redraw our diagram a bit, we get a nice neat list!</p>
<p><a href="#R-image-c1357e9ef55ae4febca541af016e93ca" class="lightbox-link"><img alt="Singly Linked List Prepend 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c1357e9ef55ae4febca541af016e93ca"><img alt="Singly Linked List Prepend 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.singleinsert4.png"></a></p>
<p>Since there are no loops in the <code>prepend</code> operation, <code>prepend</code> runs in constant time.</p>
<h2 id="inserting-in-the-middle">Inserting in the Middle</h2>
<p>Inserting a node at a given index in the linked list is a little more difficult than inserting a node at the beginning of the list. First, we have to find the proper location to insert the new node before we can actually insert it. However, since we are given an index number, we simply need to follow the linked list to the appropriate index and then perform the insertion.</p>
<p>We do have a precondition to meet before we proceed, however. We need to make sure that the index provided to the operation is not less than 0 and that it is not greater than the size of the list, which is checked in line 2. If the precondition is not satisfied, we raise an exception in line 3.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function insertAt(data, index)	        (1)
</span></span><span class="line"><span class="cl">		if index &lt; 0 or index &gt; size	(2)
</span></span><span class="line"><span class="cl">			raise exception	            (3)
</span></span><span class="line"><span class="cl">		elseif index == 0	            (4)
</span></span><span class="line"><span class="cl">			prepend(data)		        (5)
</span></span><span class="line"><span class="cl">		else
</span></span><span class="line"><span class="cl">			curr = head.next	        (6)
</span></span><span class="line"><span class="cl">			prev = head		            (7)
</span></span><span class="line"><span class="cl">			node = new Node(data)	    (8)
</span></span><span class="line"><span class="cl">		for i = 1 to index – 1	        (9)
</span></span><span class="line"><span class="cl">			prev = curr	                (10)
</span></span><span class="line"><span class="cl">			curr = curr.next	        (11)
</span></span><span class="line"><span class="cl">		end for			                (12)
</span></span><span class="line"><span class="cl">		prev.next = node	            (13)
</span></span><span class="line"><span class="cl">		node.next = curr	            (14)
</span></span><span class="line"><span class="cl">		size = size + 1	                (15)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Lines 4 and 5 check to see if the <code>index</code> is 0, which means that we want to insert it as the first item in the list. Since this is the same as the <code>prepend</code> operation we&rsquo;ve already defined, we simply call that operation. While this may not seem like a big deal, it is actually more efficient and helps us to simplify the code in the rest of the operation.</p>
<p>The operation uses <code>curr</code> to keep track of which node in the list we are currently looking at, thus we initialize <code>curr</code> to point at the first node in the list in line 6.  To allow us to swap pointers once we find the appropriate place in the list, we keep track of the node previous to <code>curr</code> as well by using the variable <code>pre</code>. This variable is initialized to <code>head</code> in line 7, and line 8 creates the new node we will insert into our list. After line 8, our <code>list</code>, <code>node</code>, and <code>previous</code> pointers would look like the following (assuming the index passed in was <code>2</code>).</p>
<p><a href="#R-image-b3557da54d48eb65a5f314b2299f4a39" class="lightbox-link"><img alt="Singly Linked List Insert 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.insertat1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b3557da54d48eb65a5f314b2299f4a39"><img alt="Singly Linked List Insert 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.insertat1.png"></a></p>
<p>At this point we start our walk through the list using the <code>for</code> loop in lines 9 - 12. Specifically, with an <code>index</code> of 2 we will actually go through the loop exactly one time, from <code>1 to 1</code>. Each time through the loop, lines 10 and 11 will cause <code>curr</code> and <code>prev</code> to point at the next nodes in the list. At the end of one time through our loop, our example will be as shown below.</p>
<p><a href="#R-image-5ed697f6c71ffb3890dab981cfecb222" class="lightbox-link"><img alt="Singly Linked List Insert 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.insertat2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5ed697f6c71ffb3890dab981cfecb222"><img alt="Singly Linked List Insert 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.insertat2.png"></a></p>
<p>Now, the only thing left to do is update the <code>next</code> pointer of node &ldquo;3&rdquo; to point at <code>node</code> (line 13), and <code>node.next</code> to point at <code>curr</code> node (line 14), while line 15 increments the size attribute. The updated list is shown below.</p>
<p><a href="#R-image-d1ff3ace0febb2d6378224792f832c10" class="lightbox-link"><img alt="Singly Linked List Insert 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.5.insertat3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d1ff3ace0febb2d6378224792f832c10"><img alt="Singly Linked List Insert 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.5.insertat3.png"></a></p>
<p>The <code>insertAt</code> operation, while being quite flexible and useful, can potentially loop through each node in the list. Therefore, it runs in order $N$ time.</p>
<h2 id="inserting-in-order">Inserting in Order</h2>
<p>When we want to insert an item into an ordered list, we need to find the right place in the list to actually insert the new node. Essentially, we need to search the list to find two adjacent nodes where the first node&rsquo;s data is less than or equal to <code>data</code> and the second node&rsquo;s data is greater than <code>data</code>. This process requires a linear search of the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function insertOrdered(data) 
</span></span><span class="line"><span class="cl">		curr = head			                (1)
</span></span><span class="line"><span class="cl">	index = 0				                (2)
</span></span><span class="line"><span class="cl">	while curr != NULL AND curr.data &lt; data	(3) 
</span></span><span class="line"><span class="cl">		index = index + 1	                (4)
</span></span><span class="line"><span class="cl">		curr = curr.next	                (5)
</span></span><span class="line"><span class="cl">	end while
</span></span><span class="line"><span class="cl">	insertAt(data, index)	                (6)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Notice that we do not have a precondition since we will search the list for the appropriate place to insert the new node, even if the list is currently empty. In line 1, we create a <code>curr</code> variable to point to the current node we are checking in the list, while in line 2 we initialize an <code>index</code> variable to keep track of the index of <code>curr</code> in the list.</p>
<p>Next, lines 3 – 5 implement a loop that searches through the list to find a node where the data in that node is greater than or equal to the data we are trying to put into the list. We also check to see if we are at the end of the list. Inside the loop, we increment <code>index</code> and point <code>curr</code> to the next node in the list.</p>
<p>Once we find the appropriate place in the list, we simply call the <code>insertAt</code> operation to perform the actual insertion. Using the <code>insertAt</code> operation provides a nice, easy to understand operation. However, we do suffer a little in efficiency since both operations loop through the list to the location where we want to insert the new data node. However, since the <code>insertAt</code> call is not embedded within the loop, our <code>insertOrdered</code> operation still runs in order $N$ time.</p>
<p>Since the previous example inserts the number 2 into the list (which falls between -1 and 3), the results of running the <code>insertOrdered</code> operation will be the same output as the result of the <code>insertAt</code> operation as shown above.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="singly-linked-lists---removal">Singly Linked Lists - Removal</h1>

<p>The process of removing a node from a linked list is fairly straightforward. First, we find the node we want to remove from the list and then change the <code>next</code> pointer from the previous node in the list to the next node in the list.  This effectively bypasses the node we want to remove. For instance, if we want to remove node &ldquo;3&rdquo; from the following list,</p>
<p><a href="#R-image-7010b65bb33567f45fd6bd76b98a4597" class="lightbox-link"><img alt="Linked List Remove 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.6.remove1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7010b65bb33567f45fd6bd76b98a4597"><img alt="Linked List Remove 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.6.remove1.png"></a></p>
<p>we simply change the <code>next</code> pointer in the &ldquo;-2&rdquo; node to point to node &ldquo;18&rdquo; instead of node &ldquo;3&rdquo;. Since no other nodes are pointing at node &ldquo;3&rdquo; it is effectively removed from our list as shown below. We then return the data in that node to the requesting function. Eventually, the garbage collector will come along and realize that nothing is referencing node &ldquo;3&rdquo; and put it back into available memory.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<h1 id="garbage-collector">Garbage Collector</h1>
<p>Many programming languages, including Java and Python, automatically manage memory for us. So, as we create or delete objects in memory, a special subroutine called the <em>garbage collector</em> will find and remove any objects that we are no longer using. This will help free up memory so we can use it again.</p>
<p>Other languages, such as C, require us to do that manually. So, whenever we stop using objects, we would have to also remember to free the memory used by that object. Thankfully, we don&rsquo;t have to worry about that in this course!</p>
</div>
</div>
<h2 id="removing-at-the-beginning">Removing at the Beginning</h2>
<p>Removing an item at the beginning of a list is extremely simple. After checking our precondition in line 1, which ensures that the list is not empty, we create a temporary copy of the data in the first node in line 3 so we can return it later in line 6. However, the actual removal of the first node simply requires us to point <code>head</code> to the second node in the list (line 4), which is found at <code>head.next</code>. This effectively skips over the first node in the list. Finally, we decrement our <code>size</code> variable in line 5 to keep it consistent with the number of nodes now in the list. Since there are no loops, <code>removeFirst</code> runs in constant time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeFirst() returns data
</span></span><span class="line"><span class="cl">		if size == 0			(1)
</span></span><span class="line"><span class="cl">			raise exception	    (2)
</span></span><span class="line"><span class="cl">		end if
</span></span><span class="line"><span class="cl">		temp = head.data		(3)
</span></span><span class="line"><span class="cl">	head = head.next 	        (4)
</span></span><span class="line"><span class="cl">	size = size – 1		        (5)
</span></span><span class="line"><span class="cl">	return temp			        (6)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="removing-in-the-middle">Removing in the Middle</h2>
<p>Removing a node at a specific index in the list is more difficult than simply removing the first node in the list since we have to walk through the list to find the node we want to remove before we can actually remove it. In addition, while walking through the list, we must keep track of the current node as well as the previous node, since removing a node requires us to change the previous node in the list.</p>
<p>In our <code>removeAt</code> operation below, we first check our precondition in line 1 to ensure that the <code>index</code> provided is a valid index in the list. If it is, we check to see if <code>index</code> is 0 in line 3 and call the <code>removeFirst</code> operation in line 4 if it is.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeAt(index) returns data
</span></span><span class="line"><span class="cl">    if index &lt; 0 OR index &gt; size – 1	(1)
</span></span><span class="line"><span class="cl">        raise exception	                (2)
</span></span><span class="line"><span class="cl">    else if index == 0	                (3)
</span></span><span class="line"><span class="cl">        return removeFirst()            (4)
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        curr = head.next	            (5)
</span></span><span class="line"><span class="cl">        prev = head		                (6)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for i = 1 to index - 1 	        (7)
</span></span><span class="line"><span class="cl">            prev = curr	                (8)
</span></span><span class="line"><span class="cl">            curr = curr.next	        (9)
</span></span><span class="line"><span class="cl">        end for
</span></span><span class="line"><span class="cl">        prev.next = curr.next	        (10)
</span></span><span class="line"><span class="cl">        size = size – 1	                (11)
</span></span><span class="line"><span class="cl">        return curr.data	            (12)
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Before we start our walk through the list using the <code>for</code> loop in lines 7 - 9, we declare two variables in lines 5 and 6:</p>
<ul>
<li><code>curr</code> points to the current node in our walk, and</li>
<li><code>prev</code> points to the node before <code>curr</code> in the list.</li>
</ul>
<p>Lines 7 – 9 are the <code>for</code> loop that we use to walk through the list to find the node at <code>index</code>. We simply update the values of <code>prev</code> and <code>curr</code> each time through the loop to point to the next node in the list.</p>
<p>Once we complete the <code>for</code> loop, <code>curr</code> is pointing at the node we want to remove and <code>prev</code> points at the previous node. Thus, we simply set <code>prev.next = curr.next</code> to bypass the <code>curr</code> node, decrement our size attribute by 1 to retain consistency, and return the data associated with the <code>curr</code> node.</p>
<p>Like the <code>insertAt</code> operation, the <code>removeAt</code> operation uses a loop and thus runs in order $N$ time.</p>
<h2 id="removing-instances-of-a-node">Removing Instances of a Node</h2>
<p>If we want to remove all occurrences of a specific node from the list, we take the data we want to remove from the list and then search all nodes in the list, removing any whose data matches the data from the input node. We will return the number of nodes removed from the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeData(data)
</span></span><span class="line"><span class="cl">	curr = head			            (1)
</span></span><span class="line"><span class="cl">	index = 0				        (2)
</span></span><span class="line"><span class="cl">	while (curr != null) 	        (3)
</span></span><span class="line"><span class="cl">		if (curr.data == data) 	    (4)
</span></span><span class="line"><span class="cl">			removeAt(index)	        (5)
</span></span><span class="line"><span class="cl">		end if
</span></span><span class="line"><span class="cl">		index = index + 1	        (6)
</span></span><span class="line"><span class="cl">		curr = curr.next	        (7)
</span></span><span class="line"><span class="cl">	end while	
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>To simplify this operation, we will call the <code>removeAt</code> operation to actually remove the node from the list, leaving this operation to simply find the nodes whose data match the input <code>data</code>.  We will use two variables in this operation:</p>
<ul>
<li><code>curr</code> will point to the current node we are checking, and</li>
<li><code>index</code> will keep track of the index of the <code>curr</code> node so we can use the <code>removeAt</code> operation.</li>
</ul>
<p>The main part of the operation is a <code>while</code> loop (lines 3 – 7) that walks through the list, node by node. For each node in the list, we check if its data matches the input <code>data</code> in line 5, and then call <code>removeAt</code> to remove it from the list if it does. Then, each time through the loop, we increment <code>index</code> in line 7 and then point <code>curr</code> to the next node in the list in line 8. When our loop exits, we have removed all the nodes whose data matched the input <code>data</code>.</p>
<p>Since we walk through the entire list, the <code>removeData</code> operation runs in order $N$ time.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="singly-linked-lists---other-operations">Singly Linked Lists - Other Operations</h1>

<h2 id="isempty">isEmpty</h2>
<p>The list <code>isEmpty</code> operation is rather straightforward. We simply need to return the truth of whether <code>head.next</code> has a null pointer. Obviously, <code>isEmpty</code> runs in constant time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function isEmpty() returns boolean
</span></span><span class="line"><span class="cl">    return head == NULL       (1)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="peek">peek</h2>
<p>The <code>peek</code> operation is designed to return the data from the last node inserted into the list, which is the node pointed at by <code>head</code>. This is easy to do; however, we must ensure that we check to see if the list is empty in line 1 before we return the <code>head.data</code> in line 3. Due to its simple structure, the run time of the <code>peek</code> operation is constant.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function peek() returns data
</span></span><span class="line"><span class="cl">	if isEmpty()			(1)
</span></span><span class="line"><span class="cl">		raise exception		(2)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	return head.data		(3)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="peekend">peekEnd</h2>
<p>The <code>peekEnd</code> operation is designed to return the first node inserted into the list, which is now the last node in the list. Like the <code>peek</code> operation, we must ensure the list is not empty in line 1 before actually searching for the end of the list. Lines 3 – 5 walk through the list using a <code>while</code> statement until <code>curr.next</code> is null, signifying that <code>curr</code> is pointing at the last node in the queue. Finally, line 6 simply returns the <code>data</code> in the last node. Since <code>peekEnd</code> must walk through the entire list to find the last node, it runs in order $N$ time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function peekEnd() returns data
</span></span><span class="line"><span class="cl">	if isEmpty()			    (1)
</span></span><span class="line"><span class="cl">		raise exception		    (2)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">    curr = head 			    (3)
</span></span><span class="line"><span class="cl">    while curr.next != null		(4)
</span></span><span class="line"><span class="cl">        curr = curr.next		(5)
</span></span><span class="line"><span class="cl">    end while
</span></span><span class="line"><span class="cl">    return curr.data			(6)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="list-based-stacks">List-Based Stacks</h1>


<a href="https://www.youtube.com/watch?v=Chs-MJlCbdg">YouTube Video</a>

<p>If we implement a stack using a singly linked list, we can simplify many things about the implementation. First of all, we can totally remove the <code>isFull</code>, <code>doubleCapacity</code>, and <code>halveCapacity</code> operations since we can grow and shrink our list-based stack as needed. The rest of the operations can be implemented directly with list operations. The front of the list will be the top of the stack since the operations to insert and remove items from the front of list are very efficient.</p>
<p>To implement our stack, we assume we have declared a linked list object named <code>list</code>.</p>
<h2 id="push">Push</h2>
<p>As expected, the <code>push</code> operation is almost trivial. We simply call the list <code>prepend</code> operation to insert the data into the front of the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function push(data)
</span></span><span class="line"><span class="cl">	list.prepend(data)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="pop">Pop</h2>
<p>Like <code>push</code>, the <code>pop</code> operation is also easily implemented using the <code>removeFirst</code> operation of our linked list. As long as the list is not empty, we simply return the data from the first item when we remove it from the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function pop() returns data
</span></span><span class="line"><span class="cl">	if list.isEmpty() then
</span></span><span class="line"><span class="cl">		throw exception
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">    return list.removeFirst().data
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="isempty">isEmpty</h2>
<p>The <code>isEmpty</code> operation is even easier. It is implemented by simply returning the results of the list <code>isEmpty</code> operation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function isEmpty() return boolean
</span></span><span class="line"><span class="cl">	return list.isEmpty()
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="peek">Peek</h2>
<p>The stack <code>peek</code> operation is also straightforward. To implement the <code>peek</code> operation we simply return the results from the list <code>peek</code> operation, which returns the <code>data</code> from the first node in the list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function peek() returns data
</span></span><span class="line"><span class="cl">    return list.peek()
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>As we can see, each of the major operations for a stack is implemented easily using list operations that run in constant time. This makes list-based stacks extremely efficient data structures to use.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="doubly-linked-lists">Doubly Linked Lists</h1>


<a href="https://www.youtube.com/watch?v=qMF9aPVFwNo">YouTube Video</a>

<p>With singly linked lists, each node in the list had a pointer to the next node in the list. This structure allowed us to grow and shrink the list as needed and gave us the ability to insert and delete nodes at the front, middle, or end of the list. However, we often had to use two pointers when manipulating the list to allow us to access the previous node in the list as well as the current node. One way to solve this problem and make our list even more flexible is to allow a node to point at both the previous node in the list as well as the next node in the list. We call this a doubly linked list.</p>
<p>The concept of a doubly linked list is shown below. Here, each node in the list has a link to the next node and a link to the previous node. If there is no previous or next node, we set the pointers to null.</p>
<p><a href="#R-image-2c5fb21c9e934b01693caa0d40969fb7" class="lightbox-link"><img alt="Doubly Linked List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.3.double.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2c5fb21c9e934b01693caa0d40969fb7"><img alt="Doubly Linked List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.3.double.png"></a></p>
<h2 id="doubly-linked-node">Doubly Linked Node</h2>
<p>A doubly linked list node is the same as a singly linked list node with the addition of the <code>previous</code> attribute that points to the previous node in the list as shown below.</p>
<p><a href="#R-image-91241c573875e8e90f14df13b337d6ff" class="lightbox-link"><img alt="Doubly Linked List Node" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.10.doublenode.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-91241c573875e8e90f14df13b337d6ff"><img alt="Doubly Linked List Node" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.10.doublenode.png"></a></p>
<p>The class representation of a doubly linked list <code>Node</code> is shown below. As discussed above, we have three attributes:</p>
<ul>
<li><code>data</code>, which holds the data of the node,</li>
<li><code>next</code>, which is a pointer to the next node, and</li>
<li><code>previous</code>, which is a pointer to the previous node.</li>
</ul>
<p>We also use a constructor and the standard <code>toString</code> operation to create a string for the data stored in the node.</p>
<p><a href="#R-image-b48185d7f017835c2651e05210a783c7" class="lightbox-link"><img alt="Doubly Linked List Node UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.10.doublenodeuml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b48185d7f017835c2651e05210a783c7"><img alt="Doubly Linked List Node UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.10.doublenodeuml.png"></a></p>
<h2 id="doubly-linked-list">Doubly Linked List</h2>
<p>As with our singly linked list, we start off a doubly linked list with a pointer to the first node in the list, which we call <code>head</code>. However, if we also store the pointer to the last node in the list, we can simplify some of our insertion and removal operations as well as reduce the time complexity of operations that insert, remove, or peek at the last node in the list.</p>
<p>The figure below shows a doubly linked list with five nodes. The variable <code>head</code> points to the first node in the list, while the variable <code>tail</code> points to the last node in the list. Each node in the list now has two pointers, <code>next</code> and <code>previous</code>, which point to the appropriate node in the list. Notice that the first node&rsquo;s <code>previous</code> pointer is null, while the last node&rsquo;s <code>next</code> pointer is also null.</p>
<p><a href="#R-image-bc0638578e4da2fa426375ee4d7b6857" class="lightbox-link"><img alt="Doubly Linked List Detail" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.10.double.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bc0638578e4da2fa426375ee4d7b6857"><img alt="Doubly Linked List Detail" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.10.double.png"></a></p>
<h2 id="doubly-linked-list-class">Doubly Linked List Class</h2>
<p>Like we did for our singly linked list, we capture the necessary details for our doubly linked list in a class. The doubly linked list class has four attributes:</p>
<ul>
<li><code>head</code>&mdash;the pointer to the first node in the list,</li>
<li><code>tail</code>&mdash;the pointer to the last node in the list,</li>
<li><code>current</code>&mdash;the pointer to the current node used by the iterator, and</li>
<li><code>size</code>&mdash;an integer to keep track of the number of items in the list.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">Class DoubleLinkedList 
</span></span><span class="line"><span class="cl">    Node head
</span></span><span class="line"><span class="cl">    Node tail
</span></span><span class="line"><span class="cl">    Node current
</span></span><span class="line"><span class="cl">    Integer size = 0</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="doubly-linked-lists---insertion">Doubly Linked Lists - Insertion</h1>

<p>Insertion in doubly linked lists is similar to what we saw in the singly linked list with two exceptions:</p>
<ol>
<li>We must update both the <code>previous</code> and <code>next</code> pointers in all affected nodes.</li>
<li>We can use the <code>tail</code> pointer to make the insertion of data at the end of the list very efficient.</li>
</ol>
<h2 id="inserting-at-the-beginning">Inserting at the Beginning</h2>
<p>Inserting at the beginning of a doubly linked list is almost as straightforward as in a singly linked list. We just need to make sure that we update the <code>previous</code> pointer in each affected node. After creating the new <code>node</code> in line 1, we check to see if the list is empty in line 2. If it is empty, then we only have to worry about updating the <code>head</code> and <code>tail</code> pointers to both point at <code>node</code> in lines 3 and 4. If the list is not empty, we have the situation shown below.</p>
<p><a href="#R-image-43f71844dd0f9c1fc3265627be99c541" class="lightbox-link"><img alt="Doubly Linked List Insert 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-43f71844dd0f9c1fc3265627be99c541"><img alt="Doubly Linked List Insert 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert1.png"></a></p>
<p>To insert a node at the beginning of the list, we set <code>head.previous</code> (the <code>previous</code> pointer in the first node in the list) to point to the new node in line 5.</p>
<p><a href="#R-image-5badc2fda95b10a1cd88024274497e0c" class="lightbox-link"><img alt="Doubly Linked List Insert 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5badc2fda95b10a1cd88024274497e0c"><img alt="Doubly Linked List Insert 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert2.png"></a></p>
<p>Next, we set the <code>next</code> pointer in the new node to point to where <code>head</code> is currently pointing in line 6, which is the first node in the list.</p>
<p><a href="#R-image-f8c6182e7fe1e34b05cac26e1c1600ec" class="lightbox-link"><img alt="Doubly Linked List Insert 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f8c6182e7fe1e34b05cac26e1c1600ec"><img alt="Doubly Linked List Insert 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert3.png"></a></p>
<p>Finally, we update <code>head</code> to point to the new <code>node</code> and then increment the size in line 8.</p>
<p><a href="#R-image-62c88a8258ef33b4b6d68046b64db82b" class="lightbox-link"><img alt="Doubly Linked List Insert 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-62c88a8258ef33b4b6d68046b64db82b"><img alt="Doubly Linked List Insert 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert4.png"></a></p>
<p>With a little bit of reformatting, we can see that we&rsquo;ve successfully inserted our new node in the list.</p>
<p><a href="#R-image-ab7ee01097ef6ab6ca95c9fbee55eae9" class="lightbox-link"><img alt="Doubly Linked List Insert 5" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.11.insert5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ab7ee01097ef6ab6ca95c9fbee55eae9"><img alt="Doubly Linked List Insert 5" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.11.insert5.png"></a></p>
<p>The pseudocode for this operation is given below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function prepend(data)
</span></span><span class="line"><span class="cl">	node = new Node(data)	    (1)
</span></span><span class="line"><span class="cl">	if size == 0	            (2)
</span></span><span class="line"><span class="cl">		head = node	            (3)
</span></span><span class="line"><span class="cl">		tail = node	            (4)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		head.previous = node	(5)
</span></span><span class="line"><span class="cl">		node.next = head	    (6)
</span></span><span class="line"><span class="cl">		head = node	            (7)
</span></span><span class="line"><span class="cl">	end 
</span></span><span class="line"><span class="cl">	size = size + 1	            (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Since there are no loops in the <code>prepend</code> code, the code runs in constant time.</p>
<h2 id="inserting-in-the-middle">Inserting in the Middle</h2>
<p>Inserting a new node at some arbitrary index in a doubly linked list is similar to the same operation in a singly linked list with a couple of changes.</p>
<ol>
<li>If the index is at the end of the list, we can use an efficient <code>append</code> operation (defined below) to insert the node at the end of the list.</li>
<li>When walking through the list to the correct index, we do not need to keep track of the previous node.</li>
<li>We will have to update both the <code>previous</code> and <code>next</code> pointers in all affected nodes.</li>
</ol>
<p>Lines 1 and 2 in the code check to ensure that the index is a valid number, then we check to see if we are inserting at the beginning or end of the list in lines 2 and 4. If we are, we simply call the appropriate method, either <code>prepend</code> or <code>append</code>.</p>
<p>If none of those conditions exist, then we start the process of walking through the list to find the node at <code>index</code>. To do this, we need to create the new node we want to insert and then create a temporary pointer <code>curr</code> that we will use to point to the current node on our walk.</p>
<p>Lines 10 and 11 form the loop that walks through the list until we get to the desired index. When the loop ends, we will want to insert the new <code>node</code> between <code>curr</code> and <code>curr.next</code>. Thus, we set the appropriate values for the new node&rsquo;s <code>next</code> and <code>previous</code> pointers in line 12 and 13. Then, we set the <code>previous</code> pointer in <code>node.next</code> to point back to <code>node</code> in line 14 and then set <code>curr.next</code> to point at the new node. Finally, we increment <code>size</code> by 1.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function insertAt(data, index)
</span></span><span class="line"><span class="cl">	if index &lt; 0 OR index &gt; size	(1)
</span></span><span class="line"><span class="cl">		raise exception	            (2)
</span></span><span class="line"><span class="cl">	else if index == 0	            (3)
</span></span><span class="line"><span class="cl">		prepend(data)	            (4)
</span></span><span class="line"><span class="cl">	else if index == size	        (5)
</span></span><span class="line"><span class="cl">		append(data)	            (6)
</span></span><span class="line"><span class="cl">	else				            (7)
</span></span><span class="line"><span class="cl">		node = new node(data)	    (8)
</span></span><span class="line"><span class="cl">		curr = head	                (9)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		for i = 1 to index -1	    (10)
</span></span><span class="line"><span class="cl">			curr = curr.next	    (11)
</span></span><span class="line"><span class="cl">		end for
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		node.next = curr.next	    (12) 
</span></span><span class="line"><span class="cl">		node.previous = curr	    (13)
</span></span><span class="line"><span class="cl">		node.next.previous = node	(14)
</span></span><span class="line"><span class="cl">		curr.next = node	        (15)
</span></span><span class="line"><span class="cl">		size = size + 1	            (16)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Although <code>prepend</code> and <code>append</code> run in constant time, the general case will cause us to walk through the list using a <code>for</code> loop. Therefore, the <code>insertAt</code> operation runs in order $N$ time.</p>
<h2 id="inserting-at-the-end">Inserting at the End</h2>
<p>Since we have added the <code>tail</code> pointer to the doubly linked list class, we can make adding a node at the end of the list run in constant time instead of order $N$ time. In fact, if you look at the code below for the <code>append</code> operation, it is exactly the same as the constant time <code>prepend</code> operation except we have replaced the <code>head</code> pointer with the <code>tail</code> pointer in lines 5 – 7.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function append(data)
</span></span><span class="line"><span class="cl">	node = new node(data)	     (1)
</span></span><span class="line"><span class="cl">	if size == 0	             (2)
</span></span><span class="line"><span class="cl">		tail = node	             (3)
</span></span><span class="line"><span class="cl">		head = node	             (4)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		tail.next = node	     (5)
</span></span><span class="line"><span class="cl">		node.previous = tail 	 (6)
</span></span><span class="line"><span class="cl">		tail = node	             (7)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	size = size + 1	             (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="doubly-linked-lists---removal-and-peek">Doubly Linked Lists - Removal and Peek</h1>

<p>The process of removing a node from a doubly linked list is really no more difficult than from a singly linked list. The only difference is that instead of changing just one pointer, we now also need to modify the <code>previous</code> pointer in the node following the node we want to remove. For instance, if we want to remove node &ldquo;3&rdquo; from the following list,</p>
<p><a href="#R-image-0ded65219e67345b979e1b5d15db4a13" class="lightbox-link"><img alt="Doubly Linked List Detail" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.10.double.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0ded65219e67345b979e1b5d15db4a13"><img alt="Doubly Linked List Detail" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.10.double.png"></a></p>
<p>we simply modify the <code>next</code> pointer in node &ldquo;-2&rdquo; to point to node &ldquo;23&rdquo;. Then, we modify the <code>previous</code> pointer in node &ldquo;23&rdquo; to point to node &ldquo;-2&rdquo;. We then return the data in that node to the requesting function.</p>
<p><a href="#R-image-d7b3047eba38baa08eb880c507ff58fe" class="lightbox-link"><img alt="Doubly Linked List Remove" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/9/9.12.remove.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d7b3047eba38baa08eb880c507ff58fe"><img alt="Doubly Linked List Remove" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/9/9.12.remove.png"></a></p>
<h2 id="removing-at-the-beginning">Removing at the Beginning</h2>
<p>The <code>remove</code> operation removes the first node in the list. First, we check to ensure that there is at least one node in the list in line 1 and raise an exception if there is not. Now, the process is simple. We simply create a temporary pointer <code>temp</code> that points to the node we are going to delete in line 3 and then point <code>head</code> to <code>head.next</code>, which is the second node in the list. Then, in line 5, we check to see if the list is empty (<code>head == null</code>) and set <code>tail</code> to <code>null</code> if it is (it was pointing at the node we just removed). If the list is not empty, we do not need to worry about updating <code>tail</code>; however, we do need to set the <code>previous</code> pointer of the first node in the list to <code>null</code> (it was also pointing at the node we just removed). Finally, we decrement <code>size</code> in line 8 and then return the data in the node we just removed in line 9. Obviously, the operation runs in constant time since there are no loops.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function remove() returns data
</span></span><span class="line"><span class="cl">	if size == 0	            (1)
</span></span><span class="line"><span class="cl">		raise exception	        (2)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	temp = head		            (3)
</span></span><span class="line"><span class="cl">	head = head.next	        (4)
</span></span><span class="line"><span class="cl">	if head == null	            (5)
</span></span><span class="line"><span class="cl">		tail = null	            (6)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		head.previous = null	(7)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	size = size – 1	            (8)
</span></span><span class="line"><span class="cl">	return temp.data	        (9)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="removing-in-the-middle">Removing in the Middle</h2>
<p>Removing a node at a specific index is very similar to the way we did it in singly linked lists. First, if we have an invalid <code>index</code> number, we raise an exception in line 2. Otherwise we check for the special cases of removing the first or last node in the list and calling the appropriate operations in lines 3 – 6.
If we have no special conditions, we create a temporary pointer <code>curr</code> and then walk through our list in lines 7 – 9. Once we reach the node we want to remove, we simply update the next node&rsquo;s <code>previous</code> pointer (line 10) and the previous node&rsquo;s <code>next</code> pointer (line 11) and we have effectively removed the node from the list. We then decrement size in line 12 and return the <code>data</code> from the removed node in line 13.</p>
<p>Since the operation relies on a loop to walk through the list, the operation runs in order $N$ time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeAt(index) returns data
</span></span><span class="line"><span class="cl">	if index &lt; 0 OR index &gt; size – 1	    (1)
</span></span><span class="line"><span class="cl">		raise exception	                    (2)
</span></span><span class="line"><span class="cl">	else if (index == 0)	                (3)
</span></span><span class="line"><span class="cl">		return remove()	                    (4)
</span></span><span class="line"><span class="cl">	else if index == size – 1	            (5)
</span></span><span class="line"><span class="cl">		return removeLast()	                (6)
</span></span><span class="line"><span class="cl">	else	
</span></span><span class="line"><span class="cl">		curr = head.next;	                (7)
</span></span><span class="line"><span class="cl">        for i = 1 to index -1 	            (8)
</span></span><span class="line"><span class="cl">            curr = curr.next	            (9)
</span></span><span class="line"><span class="cl">        end for
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        curr.next.previous = curr.previous	(10)
</span></span><span class="line"><span class="cl">        curr.previous.next = curr.next	    (11)
</span></span><span class="line"><span class="cl">        size = size – 1	                    (12)
</span></span><span class="line"><span class="cl">        return curr.data	                (13)
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="removing-at-the-end">Removing at the End</h2>
<p>Since we have added the <code>tail</code> pointer to the doubly linked list class, we can make removing a node at the end of the list run in constant time instead of running in order $N$ time. In fact, if you look at the code below for the <code>removeLast</code> operation, it is almost exactly the same as the constant time <code>removeFirst</code> operation. The only difference is that we have replaced the <code>head</code> pointer with the <code>tail</code> pointer and <code>head.next</code> with <code>tail.previous</code> in lines 3 – 7.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeLast() returns data
</span></span><span class="line"><span class="cl">	if size == 0	        (1)
</span></span><span class="line"><span class="cl">		raise exception	    (2)
</span></span><span class="line"><span class="cl">	end if	
</span></span><span class="line"><span class="cl">	temp = tail		        (3)
</span></span><span class="line"><span class="cl">	tail = tail.previous	(4)
</span></span><span class="line"><span class="cl">	if tail == null	        (5)
</span></span><span class="line"><span class="cl">		head = null	        (6)
</span></span><span class="line"><span class="cl">	else	
</span></span><span class="line"><span class="cl">		tail.next = null	(7)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	size = size – 1	        (8)
</span></span><span class="line"><span class="cl">	return temp.data	    (9)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="peekend">PeekEnd</h2>
<p>Another operation impacted by the addition of the <code>tail</code> pointer is the <code>peekEnd</code> operation. Since we can access the last node in the list directly, we just need to make sure that the list is not empty, which we do in lines 1 and 2. Then, we can return the <code>tail.data</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function peekEnd() returns data
</span></span><span class="line"><span class="cl">	if isEmpty()	        (1)
</span></span><span class="line"><span class="cl">		raise exception 	(2)
</span></span><span class="line"><span class="cl">	else	
</span></span><span class="line"><span class="cl">		return tail.data	(3)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="list-iterators">List Iterators</h1>


<a href="https://www.youtube.com/watch?v=iHeF6fzVIL8">YouTube Video</a>

<p>An iterator is a set of operations a data structure provides to allow users to access the items in the data structure sequentially, without requiring them to know its underlying representation. There are many reasons users might want to access the data in a list. For instance, users may want to make a copy of their list or count the number of times a piece of data was stored in the list. Or, the user might want to delete all data from a list that matches a certain specification. All of these can be handled by the user using an iterator.</p>
<p>At a minimum, iterators have two operations: <code>reset</code> and <code>getNext</code>. Both of these operations use the list class&rsquo;s <code>current</code> attribute to keep track of the iterator&rsquo;s current node.</p>
<h2 id="reset">Reset</h2>
<p>The <code>reset</code> operation initializes or reinitializes the <code>current</code> pointer. It is typically used to ensure that the iterator starts at the beginning of the list. All that is required is for the <code>current</code> attribute be set to <code>null</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function reset()
</span></span><span class="line"><span class="cl">	current = null
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="get-next">Get Next</h2>
<p>The main operation of the iterator is the <code>getNext</code> operation. Basically, the <code>getNext</code> operation returns the next available node in the list if one is available.  It returns <code>null</code> if the list is empty or if <code>current</code> is pointing at the last node in the list.</p>
<p>Lines 1 and 2 in the <code>getNext</code> operation check to see if we have an empty list, which results in returning the <code>null</code> value. If we have something in the list but <code>current</code> is <code>null</code>, this indicates that the <code>reset</code> operation has just been executed and we should return the data in the first node. Therefore, we set <code>current = head</code> in line 4.  Otherwise, we set the <code>current</code> pointer to point to the next node in the list in line 5.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function getNext() returns data
</span></span><span class="line"><span class="cl">	if isEmpty()	            (1)
</span></span><span class="line"><span class="cl">		return null	            (2)
</span></span><span class="line"><span class="cl">	end if 
</span></span><span class="line"><span class="cl">	if current == null	        (3)
</span></span><span class="line"><span class="cl">		current = head	        (4)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		current = current.next	(5)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">	if current == null	        (6)
</span></span><span class="line"><span class="cl">		return null	            (7)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		return current.data	    (8)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Next we return the appropriate data. If <code>current == null</code> we are at the end of the list and so we return the <code>null</code> value in line 7. If <code>current</code> is not equal to <code>null</code>, then it is pointing at a node in the list, so we simply return <code>current.data</code> in line 8.</p>
<h2 id="remove-current">Remove current</h2>
<p>While not technically part of the basic iterator interface, the <code>removeCurrent</code> operation is an example of operations that can be provided to work hand-in-hand with a list iterator. The <code>removeCurrent</code> operation allows the user to utilize the iterator operations to find a specific piece of data in the list and then remove that data from the list. Other operations that might be provided include being able to replace the data in the current node, or even insert a new piece of data before or after the current node.</p>
<p>The <code>removeCurrent</code> operation starts by checking to make sure that <code>current</code> is really pointing at a node. If it is not, then the condition is caught in line 1 and an exception is raised in line 2. Next, we set the <code>next</code> pointer in the previous node to point to the current node&rsquo;s <code>next</code> pointer in lines 3 – 5, taking into account whether the current node is the first node in the list. After that, we set the next node&rsquo;s <code>previous</code> pointer to point back at the previous node in line 6 – 8, considering whether the node is the last node in the list. Finally, we decrement <code>size</code> in line 9.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function removeCurrent()
</span></span><span class="line"><span class="cl">	if current == null		                        (1)
</span></span><span class="line"><span class="cl">		raise exception	                            (2)
</span></span><span class="line"><span class="cl">	end if 
</span></span><span class="line"><span class="cl">	if current.previous != null	                    (3)
</span></span><span class="line"><span class="cl">		current.previous.next = current.next	    (4)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		head = current.next	                        (5)
</span></span><span class="line"><span class="cl">	end
</span></span><span class="line"><span class="cl">	if current.next != null	                        (6)
</span></span><span class="line"><span class="cl">		current.next.previous = current.previous	(7)
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">		tail = current.previous	                    (8)
</span></span><span class="line"><span class="cl">	end if
</span></span><span class="line"><span class="cl">    current = current.previous                      (9)
</span></span><span class="line"><span class="cl">	size – size – 1	                                (10)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="using-an-iterator">Using an Iterator</h2>
<p>There are several applications for list iterators. For our example, we will use the case where we need a function to delete all instances of data in the list that match a given piece of data. Our <code>deleteAll</code> function resides outside the <code>list</code> class, so we will have to pass in the <code>list</code> we want to delete the <code>data</code> from.
We start the operation by initializing the list iterator in line 1, followed by getting the first piece of data in the list in line 2. Next, we&rsquo;ll enter a <code>while</code> loop and stay in that loop as long as our copy of the current node in the list, <code>listData</code>, is not <code>null</code>. When it becomes <code>null</code>, we are at the end of the list and we can exit the loop and the function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function deleteAll(list, data)
</span></span><span class="line"><span class="cl">	list.reset()	                (1)
</span></span><span class="line"><span class="cl">	listData = list.getNext()	    (2)
</span></span><span class="line"><span class="cl">	while listData != null	        (3)
</span></span><span class="line"><span class="cl">		if listData == data	        (4)
</span></span><span class="line"><span class="cl">			list.removeCurrent()	(5)
</span></span><span class="line"><span class="cl">		end if	
</span></span><span class="line"><span class="cl">		listData = list.getNext()	(6)
</span></span><span class="line"><span class="cl">	end while
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Once in the list, it&rsquo;s a matter of checking if our <code>listData</code> is equal to the <code>data</code> we are trying to match. If it is, we call the list&rsquo;s <code>removeCurrent</code> operation. Then, at the bottom of the list, we get the next piece of data from the list using the list iterator&rsquo;s <code>getNext</code> operation.</p>
<p>By using a list iterator and a limited set of operations on the current data in the list, we can allow list users to manipulate the list while ensuring that the integrity of the list remains intact. Since we do not know ahead of time how a list will be used in a given application, an iterator with associated operations can allow the user to use the list in application-specific ways without having to add new operations to the list data structure.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="list-based-queues">List-Based Queues</h1>


<a href="https://www.youtube.com/watch?v=abQW7BnD4_c">YouTube Video</a>

<p>Implementing a queue with a doubly linked list is straightforward and efficient. The core queue operations (<code>enqueue</code>, <code>dequeue</code>, <code>isEmpty</code>, and <code>peek</code>) can all be implemented by directly calling list operations that run in constant time. The only other major operation is the <code>toString</code> operation, which is also implemented by directly calling the list <code>toString</code> operation; however, it runs in order $N$ time due to the fact that the list <code>toString</code> operation must iterate through each item in the list.</p>
<p>The key queue operations and their list-based implementations are shown below.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:left">Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>enqueue</code></td>
<td style="text-align:left"><pre><code>function enqueue (data)<br>    list.append(data)<br>end function</code></pre></td>
</tr>
<tr>
<td style="text-align:center"><code>dequeue</code></td>
<td style="text-align:left"><pre><code>function dequeue() returns data<br>    return removeFirst()<br>end function</code></pre></td>
</tr>
<tr>
<td style="text-align:center"><code>isEmpty</code></td>
<td style="text-align:left"><pre><code>function isEmpty() returns Boolean<br>    return list.isEmpty()<br>end function</code></pre></td>
</tr>
<tr>
<td style="text-align:center"><code>peek</code></td>
<td style="text-align:left"><pre><code>function peek() returns data<br>    return list.peek()<br>end function</code></pre></td>
</tr>
<tr>
<td style="text-align:center"><code>toString</code></td>
<td style="text-align:left"><pre><code>function toString() returns data<br>    return list.toString()<br>end function</code></pre></td>
</tr>
</tbody>
</table>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="lists-summary">Lists Summary</h1>

<p>In this module, we introduced the concept of a linked list, discussing both singly and doubly linked lists. Both kinds of lists are made up of nodes that hold data as well as references (also known as pointers) to other nodes in the list. Singly linked lists use only a single pointer, <code>next</code>, to connect each node to the next node in the list. While simple, we saw that a singly linked list allowed us to efficiently implement a stack without any artificial bounds on the number of items in the list.</p>
<p>With doubly linked lists, we added a <code>previous</code> pointer that points to the previous node. This makes the list more flexible and makes it easier to insert and remove nodes from the list. We also added a <code>tail</code> pointer to the class, which keeps track of the last node in the list. The <code>tail</code> pointer significantly increased the efficiency of working with nodes at the end of the list. Adding the <code>tail</code> pointer allowed us to implement all the major queue operations in constant time.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc310/commit/301ec8aaa3405c30b07aa146ef1fa7f85a5af97c">Aug 17, 2021</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc310/js/clipboard.min.js?1719522555" defer></script>
    <script src="/cc310/js/perfect-scrollbar.min.js?1719522555" defer></script>
    <script src="/cc310/js/theme.js?1719522555" defer></script>
  </body>
</html>
