




  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming by Contract and Introduction to Performance :: CC 310 Textbook</title>
    <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/</link>
    <description>Welcome! This page is the main page for Programming by Contract and Introduction to Performance</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Jun 2024 14:46:21 -0500</lastBuildDate>
    <atom:link href="https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Programming by Contract</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/1-programming-by-contract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/1-programming-by-contract/</guid>
      <description>In this course, we will learn how to develop several different data structures, and then use those data structures in programs that implement several different types of algorithms. However, one of the most difficult parts of programming is clearly explaining what a program should do and how it should perform.&#xA;So far, we’ve used UML class diagrams to discuss the structure of a program. It can give us information about the classes, attributes, and methods that our program will contain, as well as the overall relationships between the classes.</description>
    </item>
    <item>
      <title>Preconditions</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/2-preconditions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/2-preconditions/</guid>
      <description>First, let’s discuss preconditions. A precondition is an expectation applied to any parameters and existing variables when a method or function is called. Phrased a different way, the preconditions should all be true before the method is called. If all of the preconditions are met, the function can proceed and is expected to function properly. However, if any one of the preconditions are not met, the function may either reach an exception, prompt the user to correct the issue, or produce invalid output, depending on how it is written.</description>
    </item>
    <item>
      <title>Postconditions</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/3-postconditions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/3-postconditions/</guid>
      <description>Next, we can discuss postconditions. A postcondition is a statement that is guaranteed to be true after a method is executed, provided all of the preconditions were met. If any one of the preconditions were not met, then we can’t count on the postcondition being true either. This is the most important concept surrounding preconditions and postconditions.&#xA;Info If the preconditions of a method are all true when a method is called, then we may assume the postconditions are true after the method is complete, provided it is written correctly.</description>
    </item>
    <item>
      <title>Invariants</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/4-invariants/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/4-invariants/</guid>
      <description>Another concept related to preconditions and postconditions is the loop invariant. A loop invariant is a statement should be true after each iteration of a loop, provided the loop’s preconditions are all true before the start of the loop. Yes, that’s right—we can think of a loop as a miniature method within a method, with its own set of preconditions and postconditions.&#xA;Example - Maximum For this example, let’s consider a method maximum(numbers) that gets an array of numbers as input, and returns the maximum value stored in that list.</description>
    </item>
    <item>
      <title>Correctness</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/5-correctness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/5-correctness/</guid>
      <description>If we have defined the correct preconditions, postconditions, and invariants for our code, we can then use those to prove that our code correctly performs its intended operation.&#xA;In this course, we won’t ask you to do any of this yourself, but it is important to understand what is going on in the background and how this process works. We can use the concepts of preconditions and postconditions when grading your code using our Autograder—in fact, that’s really how it works!</description>
    </item>
    <item>
      <title>Unit Testing</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/6-unit-testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/6-unit-testing/</guid>
      <description>Once we’ve written a program, how can we verify that it works correctly? There are many ways to do this, but one of the most common is unit testing.&#xA;Unit Testing Unit testing a program involves writing code that actually runs the program and verifies that it works correctly. In addition, many unit tests will also check that the program produces appropriate errors when given bad input, or even that it won’t crash when given invalid input.</description>
    </item>
    <item>
      <title>Performance of Algorithms</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/7-performance-of-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/7-performance-of-algorithms/</guid>
      <description>The performance of our algorithms is very important, since the difference between good algorithms and bad algorithms on very large data sets can often be measured in terms of days of execution time. Thus, efficiency will be one of the key issues we will look at when designing algorithms.&#xA;For example, one simple problem involves finding the largest sum of contiguous elements in an array. So, if we have the array:</description>
    </item>
    <item>
      <title>Max and Min - Linear</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/8-max-and-min---linear/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/8-max-and-min---linear/</guid>
      <description>Let’s start by considering one number from the list at a time.&#xA;Base Case When we have received just one number, this number is both the maximum and the minimum. In the initial state, you have max holding the maximum, and min holding the minimum. The invariant is the following:&#xA;The variable max holds the maximum of all the numbers considered so far The variable min holds the minimum of all the numbers considered so far The algorithm is depicted by the following flowchart and pseudocode:</description>
    </item>
    <item>
      <title>Max and Min - Pairs</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/9-max-and-min---pairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/9-max-and-min---pairs/</guid>
      <description>Another solution consists of comparing the numbers in pairs, instead of one at a time.&#xA;Base Case When we have received just one number, this number is both the maximum and the minimum. In the initial state, you have max holding the maximum, and min holding the minimum. The invariant is the following:&#xA;The variable max holds the maximum of all the numbers considered so far The variable min holds the minimum of all the numbers considered so far The algorithm is depicted by the following flowchart and pseudocode:</description>
    </item>
    <item>
      <title>Time Complexity</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/10-time-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/10-time-complexity/</guid>
      <description>It is very useful to compare the two solutions to choose one. In general, you can compare the two solutions by considering:&#xA;The time required to execute it The amount of memory it requires The number of instructions used, and also the understandability of the code Time Complexity To compare programs in terms of the time we can estimate the running time, or time it takes to complete its work.</description>
    </item>
    <item>
      <title>Space Complexity</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/11-space-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/11-space-complexity/</guid>
      <description>We can also look at a program based on the amount of space, or memory, that it uses. In this case, we are looking at the number of variables that are needed, and also the size of any lists, arrays, or more advanced data structures used.&#xA;The comparison in terms of space leads us to observe that the linear solution uses, in addition to the input value x for each iteration of the loop, also the max and min variables.</description>
    </item>
    <item>
      <title>Code Complexity</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/12-code-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/12-code-complexity/</guid>
      <description>Lastly, when analyzing a program, we must also consider the complexity of the code used to write the program. Code complexity can refer to many things, but in general we use it to describe how many lines of code are included the program, as well as how easy it is to understand what the program does.&#xA;Lines of Code One of the most common ways to measure the size of a program is the number of lines of code, or LOC, of the program.</description>
    </item>
    <item>
      <title>Programming by Contract and Performance Summary</title>
      <link>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/13-programming-by-contract-and-performance-summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cc310/3-programming-by-contract-and-introduction-to-performance/13-programming-by-contract-and-performance-summary/</guid>
      <description>In this module, we covered two major topics that will help us understand the data structures and algorithms we’ll learn in this course. First, we learned about the use of preconditions, postconditions, and loop invariants to help describe the exact specifications of how methods and loops should operate in code. We’ll use these as the basis of unit tests in this course to help prove the correctness of data structures and algorithms we are asked to develop throughout the course.</description>
    </item>
  </channel>
</rss>