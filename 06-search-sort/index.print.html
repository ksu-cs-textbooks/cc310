




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Methods for finding and organizing data!">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Searching &amp; Sorting :: CC 310 Textbook">
    <meta name="twitter:description" content="Methods for finding and organizing data!">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/06-search-sort/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Searching &amp; Sorting :: CC 310 Textbook">
    <meta property="og:description" content="Methods for finding and organizing data!">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Searching &amp; Sorting :: CC 310 Textbook">
    <meta itemprop="description" content="Methods for finding and organizing data!">
    <meta itemprop="dateModified" content="2024-07-03T10:50:03-05:00">
    <meta itemprop="wordCount" content="6">
    <title>Searching &amp; Sorting :: CC 310 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc310/06-search-sort/" rel="canonical" type="text/html" title="Searching &amp; Sorting :: CC 310 Textbook">
    <link href="/cc310/06-search-sort/index.xml" rel="alternate" type="application/rss+xml" title="Searching &amp; Sorting :: CC 310 Textbook">
    <link href="/cc310/06-search-sort/tele.html" rel="alternate" type="text/html" title="Searching &amp; Sorting :: CC 310 Textbook">
    <link href="/cc310/06-search-sort/embed.html" rel="alternate" type="text/html" title="Searching &amp; Sorting :: CC 310 Textbook">
    <link href="/cc310/css/fontawesome-all.min.css?1720021866" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1720021866" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1720021866" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1720021866" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1720021866" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1720021866" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1720021866" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1720021866" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1720021866" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1720021866" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1720021866" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1720021866" rel="stylesheet">
    <link href="/cc310/css/print.css?1720021866" rel="stylesheet" media="print">
    <link href="/cc310/css/format-print.css?1720021866" rel="stylesheet">
    <script src="/cc310/js/variant.js?1720021866"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1720021866" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc310/06-search-sort/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Searching &amp; Sorting</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/05-recursion/09-summary/" title="Recursion Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/06-search-sort/01-searching/" title="Searching (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 6</div>

<h1 id="searching--sorting">Searching &amp; Sorting</h1>

<p>Methods for finding and organizing data!</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Searching &amp; Sorting</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="searching">Searching</h1>

<p>In this course, we are learning about many different ways we can store data in our programs, using arrays, queues, stacks, lists, maps, and more. We&rsquo;ve already covered a few of these data structures, and we&rsquo;ll learn about the others in upcoming modules. Before we get there, we should also look at a couple of the most important operations we can perform on those data structures.</p>
<p>Consider the classic example of a data structure containing information about students in a school. In the simplest case, we could use an array to store objects created from a <code>Student</code> class, each one representing a single student in the school.</p>
<p>As we&rsquo;ve seen before, we can easily create those objects and store them in our array. We can even iterate through the array to find the maximum age or minimum GPA of all the students in our school.
However, what if we want to just find a single student&rsquo;s information? To do that, we&rsquo;ll need to discuss one of the most commonly used data structure operations: searching.</p>
<h2 id="what-is-searching">What is Searching?</h2>
<p>Searching typically involves finding a piece of information, or a value stored in a data structure or calculated within a specific domain. For example, we might want to find out if a specific word is found in an array of character strings. We might also want to find an integer that meets a specific criterion, such as finding an integer that is the sum of the two preceding integers. For this module, we will focus on finding values in data structures.</p>
<p>In general, we can search for</p>
<ol>
<li>a specific value,</li>
<li>a sequence of values, or</li>
<li>values with specific properties such as the minimum or maximum value.</li>
</ol>
<p>The data structure can be thought of more generally as a container, which can be</p>
<ol>
<li>one dimensional, such as a list or a one-dimensional array,</li>
<li>multi-dimensional, such as a two-dimensional array or a matrix, or</li>
<li>a problem-specific data structure.</li>
</ol>
<p>For the examples in this module, we&rsquo;ll generally use a simple finite array as our container. However, it shouldn&rsquo;t be too difficult to figure out how to expand these examples to work with a larger variety of data structures. In fact, as we introduce more complex data structures in this course, we&rsquo;ll keep revisiting the concept of searching and see how it applies to the new structure.</p>
<p>In general, containers can be either ordered or unordered. In many cases, we may also use the term <em>sorted</em> to refer to an ordered container, but technically an ordered container just enforces <em>an</em> ordering on values, but they may not be in a sorted order. As long as we understand what the ordering is, we can use that to our advantage, as we&rsquo;ll see later.</p>
<p>Searches in an unordered container generally require a <em>linear search</em>, where every value in the container must be compared against our search value. On the other hand, search algorithms on ordered containers can take advantage of this ordering to make their searches more efficient. A good example of this is <em>binary search</em>. Let&rsquo;s begin by looking at the simplest case, linear search.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="linear-search">Linear Search</h1>


<a href="https://www.youtube.com/watch?v=-V75q4CnlXw">YouTube Video</a>

<p>When searching for a number in an unordered array, our search algorithms are typically designed as functions that take two parameters:</p>
<ol>
<li>the number to find, and</li>
<li>the array to search.</li>
</ol>
<p>Our search functions then return an index to the number within the array.</p>
<p>In this module, we will develop a couple of examples of searching an array for a specific number.</p>
<p>Finding the first occurrence of a number in an unordered array is a fairly straightforward process. A black box depiction of this function is shown below. There are two inputs, <code>array</code> and <code>number</code>, and a single output, the <code>index</code> of the first occurrence of the <code>number</code> in <code>array</code>.</p>
<p><a href="#R-image-8d2631f705749b7611d949c122cf94ce" class="lightbox-link"><img alt="Function Diagram" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.2.function.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8d2631f705749b7611d949c122cf94ce"><img alt="Function Diagram" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.2.function.png"></a></p>
<p>We can also include the search function as a method inside of the container itself. In that case, we donâ€™t have to accept the container as a parameter, since the method will know to refer to the object it is part of.</p>
<p>Of course, when we begin designing an algorithm for our function we should think about two items immediately: the preconditions and the postconditions of the function. For this function, they are fairly simple.</p>
<p>The precondition for <code>find</code> is that the <code>number</code> provided as input is compatible with the type of data held by the provided <code>array</code>. In this case, we have no real stipulations on <code>array</code>. It does not need to actually have any data in it, nor does it have to be ordered or unordered.</p>
<p>Our postcondition is also straightforward. The function should return the index of <code>number</code> if it exists in the array. However, if <code>number</code> is not found in the array, then <code>-1</code> is returned. Depending on how we wish to implement this function, it could also return another default index or throw an exception if the desired value is not found. However, most searching algorithms follow the convention of returning an invalid index of <code>-1</code> when the value is not found in the array, so that&rsquo;s what we&rsquo;ll use in our examples.</p>
<p><strong>Preconditions:</strong></p>
<ul>
<li>The number to be searched for is compatible with data in the array</li>
</ul>
<p><strong>Postconditions:</strong></p>
<ul>
<li>The function returns the index of number in the array</li>
<li>The function returns -1 if the number to be searched for is not found in the array</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="searching-for-a-value">Searching for a Value</h1>

<p>To search for a single number in our array, we will use a loop to search each location in the array until we find the number. The general idea is to iterate over all the elements in the array until we either find the number we are searching for or there are no other elements in the array.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">function</span> <span class="n">FIND</span><span class="p">(</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">loop</span> <span class="n">INDEX</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">size</span> <span class="n">of</span> <span class="n">ARRAY</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span> <span class="o">==</span> <span class="n">NUMBER</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">            <span class="k">return</span> <span class="n">INDEX</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">end</span> <span class="k">for</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>As we can see in line 1, the function takes both a <code>number</code> and <code>array</code> parameter. We then enter a <code>for</code> loop in line 2 to loop through each location in the array. We keep track of the current location in the array using the <code>index</code> variable. For each location, we compare <code>number</code> against the value in the <code>array</code> at location <code>index</code>. If we find the number, we simply return the value of <code>index</code> in line 4.  If we do not find the number anywhere in the array, the loop will exit, and the function will return <code>-1</code> in line 8.</p>
<p>Below is an example of how to execute this algorithm on example data.  Step 1 shows the initial state of the variables in the function the first time through the loop. Both <code>array</code> and <code>number</code> are passed to the function but we do not modify either of them in the function. The <code>index</code> variable is the <code>for</code> loop variable, which is initially set to <code>0</code> the first time through the loop. In line 3, the function compares the number in <code>array[index]</code> against the value of <code>number</code>. In this step, since <code>index</code> is <code>0</code>, we use <code>array[0]</code>, which is <code>8</code>. Since <code>8</code> is not equal to the value of <code>number</code>, which is <code>3</code>, we do nothing in the <code>if</code> statement and fall to the <code>end for</code> statement in line 6. Of course, this just sends us back to the <code>for</code> statement in line 2.</p>
<p>The second time through the <code>for</code> loop is shown as Step 2 in the figure. We follow the same logic as above and compare <code>array[1]</code>, or 4, against <code>number</code>, which is still 3. Since these values are not equal, we skip the rest of the <code>if</code> statement and move on to Step 3.</p>
<p>In Step 3, <code>index</code> is incremented to <code>2</code>, thus pointing at <code>array[2]</code>, whose value is <code>3</code>. Since this value is equal to the value of <code>number</code>, we carry out the <code>if</code> part of the statement. Line 4 returns the value of <code>2</code>, which is the first location in <code>array</code> that holds the value of <code>number</code>.</p>
<p><a href="#R-image-54a58e233e99c04f95a8e92b8d1e59d7" class="lightbox-link"><img alt="Linear Search Diagram" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.3.linear.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-54a58e233e99c04f95a8e92b8d1e59d7"><img alt="Linear Search Diagram" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.3.linear.png"></a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="searching-for-the-last-value">Searching for the Last Value</h1>

<p>Our <code>find</code> algorithm above will find the first instance of <code>number</code> in the <code>array</code> and return the index of that instance. However, we might also be interested in finding the last instance of <code>number</code> in <code>array</code>. Looking at our original <code>find</code> algorithm, it should be easy to find the last value by simply searching the array in reverse order, as shown in the following figure.</p>
<p><a href="#R-image-d3956928be2d538a73bd262a363edbbe" class="lightbox-link"><img alt="Linear Search Last Value" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.4.linearreverse.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d3956928be2d538a73bd262a363edbbe"><img alt="Linear Search Last Value" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.4.linearreverse.png"></a></p>
<p>We will use the same example as above, except we will start searching backwards from the end of the array. In Step 1, we see that <code>index</code> is initialized to 7 and we compare <code>array[7]</code> against <code>number</code>, which are not the same. Thus, we continue to Step 2, where we decrement <code>index</code> to 6. Here <code>array[6]</code> is still not equal to <code>number</code>, so we continue in the loop. Finally, in Step 3, we decrement <code>index</code> to 5. Now <code>array[5]</code> contains the number <code>3</code>, which is equal to our <code>number</code> and we return the current <code>index</code> value.</p>
<p>Luckily for us, we can change our <code>for</code> loop index to decrement from the end of the array (<code>size of array - 1</code>) to the beginning (<code>0</code>). Thus, by simply changing line 3 in our original function, we can create a new function that searches for the last instance of <code>number</code> in <code>array</code>. The new function is shown below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">function</span> <span class="n">REVERSEFIND</span><span class="p">(</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">loop</span> <span class="n">INDEX</span> <span class="kn">from</span> <span class="nn">size</span> <span class="n">of</span> <span class="n">ARRAY</span> <span class="err">â€“</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">0</span> <span class="n">step</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span> <span class="o">==</span> <span class="n">NUMBER</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">            <span class="k">return</span> <span class="n">INDEX</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">end</span> <span class="k">for</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>Obviously, the <code>for</code> loop in line 2 holds the key to searching our array in reverse order. We start at the end of the array by using the index <code>size of array - 1</code> and then decrement the value of <code>index</code> (via the <code>step -1</code> qualifier) each time through the loop until we reach 0. The remainder of the function works exactly like the <code>find</code> function.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="recursive-linear-search">Recursive Linear Search</h1>

<p>We looked at an iterative version of the <code>find</code> function above. But what would it take to turn that function into a recursive function? While for this particular function, there is not a lot to be gained from the recursive version, it is still instructive to see how we would do it. We will find recursive functions more useful later on in the module.</p>
<p>In this case, to implement a recursive version of the function, we need to add a third parameter, <code>index</code>, to tell us where to check in the array. We assume that at the beginning of a search, <code>index</code> begins at 0. Then, if <code>number</code> is not in location <code>index</code> in the <code>array</code>, <code>index</code> will be incremented before making another recursive call. Of course, if <code>number</code> is in location <code>index</code>, we will return the number of <code>index</code>. The pseudocode for the <code>findR</code> function is shown below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">function</span> <span class="n">FINDR</span> <span class="p">(</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">,</span> <span class="n">INDEX</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="k">if</span> <span class="n">INDEX</span> <span class="o">&gt;=</span> <span class="n">size</span> <span class="n">of</span> <span class="n">ARRAY</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span> <span class="o">==</span> <span class="n">NUMBER</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="k">return</span> <span class="n">INDEX</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">        <span class="k">return</span> <span class="n">FINDR</span> <span class="p">(</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">,</span> <span class="n">INDEX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>First, we check to see if <code>index</code> has moved beyond the bounds of the array, which would indicate that we have searched all the locations in <code>array</code> for <code>number</code>. If that is the case, then we return <code>-1</code> in line 3 indicating that we did not find <code>number</code> in <code>array</code>. Next, we check to see if <code>number</code> is found in <code>array[index]</code> in line 4. If it is, the we are successful and return the index. However, if we are not finished searching and we have not found <code>number</code>, then we recursively call <code>findR</code> and increment <code>index</code> by 1 to search the next location.</p>
<p>An example of using the <code>findR</code> function is shown below. The top half of the figure shows the state of the data in the initial call to the <code>findR</code> function (instance 1). The bottom half of the figure shows the recursive path through the function. The beginning of instance 1 shows the <code>if</code> statement in line 2. In instance 1, since we have not searched the entire array (line 2) and <code>array[0]</code> is not equal to <code>number</code> (line 4), we fall down to the <code>else</code> part function and execute line 7, the recursive call. Since <code>index</code> is <code>0</code> in instance 1, we call instance 2 of the function with an <code>index</code> of 1.</p>
<p>In instance 2, the same thing happens as in instance 1 and we fall down to the <code>else</code> part of the <code>if</code> statement. Once again, we call a new instance of <code>findR</code>, this time with <code>index</code> set at 2. Now, in instance 3, <code>array[index]</code> is equal to <code>number</code> in line 4 and so we execute the <code>return index</code> statement in line 5.  The value of <code>index</code> (2) is returned to instance 2, which, in line 7, simply returns the value of 2 to instance 1. Again, in line 7, instance 1 returns that same value (2) to the original calling function.</p>
<p><a href="#R-image-2807f90b772f05fe14203ba423b7d2fb" class="lightbox-link"><img alt="Recursive Linear Search" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.5.recursivelinear.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2807f90b772f05fe14203ba423b7d2fb"><img alt="Recursive Linear Search" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.5.recursivelinear.png"></a></p>
<p>Notice that the actual process of searching the array is the same for both the iterative and recursive functions. It is only the implementation of that process that is different between the two.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="searching-for-a-minimum">Searching for a Minimum</h1>

<p>We may also want to search through a data structure to find an item with a specific property. For example, we could search for the student with the maximum age, or the minimum GPA. For this example, let&rsquo;s consider the case where we&rsquo;d like to find the minimum value in an array of integers.</p>
<p>Searching for the minimum number in an unordered array is a different problem than searching for a specific number. First of all, we do not know what number we are searching for. And, since the array is not ordered, we will have to check each and every number in the array.</p>
<p>The input parameters of our new function will be different from the <code>find</code> function above, since we do not have a number to search for. In this case, we only have an array of numbers as an input parameter. The output parameter, however, is the same. We still want to return the index of the minimum number in the array. In this case, we will return <code>-1</code> if there is no minimum number, which can only happen if there is no data in the array when we begin.</p>
<p><strong>Preconditions:</strong></p>
<ul>
<li>The data in the array can be sorted</li>
</ul>
<p><strong>Postconditions:</strong></p>
<ul>
<li>The function returns the minimum number of the data in the array</li>
<li>The function returns -1 if the array is empty</li>
</ul>
<p>Our preconditions and postconditions are also simple. Our precondition is simply that we have an array whose data can be sorted. This is important, because it means that we can compare two elements in the array and determine which one has a smaller value. Otherwise, we couldn&rsquo;t determine the minimum value at all!</p>
<p>Our postcondition is that we return the minimum number of the data in the array, or <code>-1</code> if the array is empty.</p>
<p>The function <code>findMin</code> is shown below. First, we check to see if the array is empty. If it is, we simply return <code>-1</code> in line 3. If not, we assume the location <code>0</code> contains the minimum number in the array, and set <code>min</code> equal to 0 in line 5. Then we loop through each location in the array (starting with 1) in line 6 and set <code>min</code> equal to the minimum of the array data at the current <code>index</code>  and the data at <code>min</code>. (Note: if the array only has a single number in it, the for loop will not actually execute since <code>index</code> will be initialized to 1, which is already larger than the size of the <code>array â€“ 1</code>, which is 0.) Once we complete the loop, we will be guaranteed that we have the index of the minimum number in the array.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">FINDMIN</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">if</span> <span class="n">ARRAY</span> <span class="ow">is</span> <span class="n">empty</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">MIN</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">loop</span> <span class="n">INDEX</span> <span class="kn">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">size</span> <span class="n">of</span> <span class="n">ARRAY</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">MIN</span><span class="p">]</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="n">MIN</span> <span class="o">=</span> <span class="n">INDEX</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">end</span> <span class="k">for</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">return</span> <span class="n">MIN</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>Next, we will walk through the algorithm using our example array in the figure below. Step 1 shows the initial time through the loop. In line 5, <code>min</code> is set to <code>0</code> by default and in line 6, <code>index</code> is set equal to <code>1</code>. Line 7 then computes whether <code>array[1] &lt; array[0]</code>. In this case, it is and we set <code>min = 1</code> (which is reflected in the next step where <code>min</code> has the value <code>1</code>).</p>
<p><a href="#R-image-4a9e3576eec3505aaed299f744a6ba17" class="lightbox-link"><img alt="Finding Minimum Diagram" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.6.minimum.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4a9e3576eec3505aaed299f744a6ba17"><img alt="Finding Minimum Diagram" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.6.minimum.png"></a></p>
<p>Step 2 will end up comparing <code>array[2] &lt; array[1]</code>, since <code>min</code> is now 1 and <code>index</code> has been incremented to 2 via the <code>for</code> loop. In this case, <code>array[2]</code> is less than <code>array[1]</code> so we update <code>min</code> again, this time to 2.</p>
<p>Step 3 follows the same process; however, this time the value in <code>array[3]</code> is 55, which is greater than the current minimum of 3 in <code>array[2]</code>. Therefore, <code>min</code> is not updated. Step 4 finds the minimum value in the array of <code>-3</code> at index 4 and so updates <code>min</code> to 4. However, steps 5, 6, and 7 do not find new minimum values. Thus, when the loop exits after Step 6, <code>min</code> is set to 4 and this value is returned to the calling program in line 11.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="linear-search-time-complexity">Linear Search Time Complexity</h1>

<p>We&rsquo;ve examined many different versions of a linear search algorithm. We can find the first occurrence of a number in an array, the last occurrence of that number, or a value with a particular property, such as the minimum value. Each of these are examples of a linear search, since we look at each element in the container sequentially until we find what we are looking for.</p>
<p>So, what would be the time complexity of this process? To understand that, we must consider what the worst-case input would be. For this discussion, we&rsquo;ll just look at the <code>find</code> function, but the results are similar for many other forms of linear search. The pseudocode for <code>find</code> is included below for reference.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">function</span> <span class="n">FIND</span><span class="p">(</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">loop</span> <span class="n">INDEX</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">size</span> <span class="n">of</span> <span class="n">ARRAY</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span> <span class="o">==</span> <span class="n">NUMBER</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">            <span class="k">return</span> <span class="n">INDEX</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">end</span> <span class="k">for</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>How would we determine what the worst-case input for this function would be? In this case, we want to come up with the input that would require the most steps to find the answer, regardless of the size of the container. Obviously, it would take more steps to find a value in a larger container, but that doesn&rsquo;t really tell us what the worst-case input would be.</p>
<p>Therefore, the time complexity for a linear search algorithm is clearly proportional to the number of items that we need to search through, in this case the size of our array. Whether we use an iterative algorithm or a recursive algorithm, we still need to search the array one item at a time. We&rsquo;ll refer to the size of the array as $N$.</p>
<p>Here&rsquo;s the key: when searching for minimum or maximum values, the search will always take exactly $N$ comparisons since we have to check each value. However, if we are searching for a specific value, the actual number of comparisons required may be fewer than $N$.</p>
<p>To build a worst-case input for the <code>find</code> function, we would search for the situation where the value to find is either the last value in the array, or it is not present at all. For example, consider the array we&rsquo;ve been using to explore each linear search algorithm so far.</p>
<p><a href="#R-image-76d5763a374720a63a94f362a86afc1f" class="lightbox-link"><img alt="Array of Numbers" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.7.array.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-76d5763a374720a63a94f362a86afc1f"><img alt="Array of Numbers" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.7.array.png"></a></p>
<p>What if we are trying to find the value 55 in this array? In that case, we&rsquo;ll end up looking at 4 of the 8 elements in the array. This would take $N/2$ steps. Can we think of another input that would be worse?</p>
<p>Consider the case where we try to find 0 instead. Will that be worse? In that case, we&rsquo;ll need to look at all 8 elements in the array before we find it. That requires $N$ steps!</p>
<p>What if we are asked to find 1 in the array? Since 1 is not in the array, we&rsquo;ll have to look at every single element before we know that it can&rsquo;t be found. Once again, that requires $N$ steps.</p>
<p>We could say that in the worst-case, a linear search algorithm requires &ldquo;on the order of $N$&rdquo; time to find an answer. Put another way, if we double the size of the array, we would also need to double the expected number of steps required to find an item in the worst case. We sometimes call this linear time, since the number of steps required grows at the same rate as the size of the input.</p>
<h2 id="can-we-do-better">Can We Do Better?</h2>
<p>Our question now becomes, &ldquo;Is a search that takes on the order of $N$ time really all that bad?&rdquo;. Actually, it depends. Obviously, if $N$ is a small number (less than 1000 or so) it may not be a big deal, if you only do a single search. However, what if we need to do many searches? Is there something we can do to make the process of searching for elements even easier?</p>
<p><a href="#R-image-b4159ea2dd28609d6d0fb82102020e54" class="lightbox-link"><img alt="Stack of Files" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.7.files.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b4159ea2dd28609d6d0fb82102020e54"><img alt="Stack of Files" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.7.files.png"></a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>Let&rsquo;s consider the real world once again for some insights. For example, think of a pile of loose papers on the floor. If we wanted to find a specific paper, how would we do it?</p>
<p>In most cases, we would simply have to perform a linear search, picking up each paper one at a time and seeing if it is the one we need. This is pretty inefficient, especially if the pile of papers is large.</p>
<p><a href="#R-image-b23174874254bbbfe3df6fd111d92179" class="lightbox-link"><img alt="File Cabinet" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.7.cabinet.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b23174874254bbbfe3df6fd111d92179"><img alt="File Cabinet" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.7.cabinet.png"></a><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>What if we stored the papers in a filing cabinet and organized them somehow? For example, could we sort the papers by title in alphabetical order? Then, when we want to find a particular paper, we can just skip to the section that contains files with the desired first letter and go from there. In fact, we could even do this for the second and third letter, continuing to jump forward in the filing cabinet until we found the paper we need.</p>
<p>This seems like a much more efficient way to go about searching for things. In fact, we do this naturally without even realizing it. Most computers have a way to sort files alphabetically when viewing the file system, and anyone who has a collection of items has probably spent time organizing and alphabetizing the collection to make it easier to find specific items.</p>
<p>Therefore, if we can come up with a way to organize the elements in our array, we may be able to make the process of finding a particular item much more efficient. In the next section, we&rsquo;ll look at how we can use various sorting algorithms to do just that.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>File:FileStack retouched.jpg. (2019, January 17). Wikimedia Commons, the free media repository. Retrieved 22:12, March 23, 2020 from <a href="https://commons.wikimedia.org/w/index.php?title=File:FileStack_retouched.jpg&oldid=335159723" rel="external" target="_blank">https://commons.wikimedia.org/w/index.php?title=File:FileStack_retouched.jpg&oldid=335159723</a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>File:Istituto agronomico per l&rsquo;oltremare, int., biblioteca, schedario 05.JPG. (2016, May 1). Wikimedia Commons, the free media repository. Retrieved 22:11, March 23, 2020 from <a href="https://commons.wikimedia.org/w/index.php?title=File:Istituto_agronomico_per_l%27oltremare,_int.,_biblioteca,_schedario_05.JPG&oldid=194959053" rel="external" target="_blank">https://commons.wikimedia.org/w/index.php?title=File:Istituto_agronomico_per_l%27oltremare,_int.,_biblioteca,_schedario_05.JPG&oldid=194959053</a>.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="sorting">Sorting</h1>

<p>Sorting is the process we use to organize an ordered container in a way that we understand what the ordering of the values represents. Recall that an ordered container just enforces an ordering between values, but that ordering may appear to be random. By sorting an ordered container, we can enforce a specific ordering on the elements in the container, allowing us to more quickly find specific elements as we&rsquo;ll see later in this chapter.</p>
<h2 id="ascending-and-descending-order">Ascending and Descending Order</h2>
<p>In most cases, we sort values in either ascending or descending order. Ascending order means that the smallest value will be first, and then each value will get progressively larger until the largest value, which is at the end of the container. Descending order is the opposite&mdash;the largest value will be first, and then values will get progressively smaller until the smallest value is last.</p>
<p>We can also define this mathematically. Assume that we have a container called <code>array</code> and two indexes in that container, <code>a</code> and <code>b</code>. If the container is sorted in ascending order, we would say that if <code>a</code> is less than <code>b</code> (that is, the element at index <code>a</code> comes before the element at index <code>b</code>), then the element at index <code>a</code> is less than or equal to the element at index <code>b</code>. More succinctly:</p>
$$
a < b \implies \text{array}[a] \leq \text{array}[b]
$$
<p>Likewise, if the container is sorted in descending order, we would know that if <code>a</code> is less than <code>b</code>, then the element at index <code>a</code> would be greater than or equal to the element at index <code>b</code>. Or:</p>
$$
a < b \implies \text{array}[a] \geq \text{array}[b]
$$
<p>These facts will be important later when we discuss the precondition, postconditions, and loop invariants of algorithms in this section.</p>
<h2 id="sorting-algorithms">Sorting Algorithms</h2>
<p>To sort a collection of data, we can use one of many sorting algorithms to perform that action. While there are many different algorithms out there for sorting, there are a few commonly used algorithms for this process, each one with its own pros, cons, and time complexity. These algorithms are studied extensively by programmers, and nearly every programmer learns how to write and use these algorithms as part of their learning process. In this module, we&rsquo;ll introduce you to the 4 most commonly used sorting algorithms:</p>
<ol>
<li>Selection Sort,</li>
<li>Bubble Sort,</li>
<li>Merge Sort, and</li>
<li>Quicksort.</li>
</ol>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="selection-sort">Selection Sort</h1>


<a href="https://www.youtube.com/watch?v=76NNveliJQM">YouTube Video</a>

<p>The first sorting algorithm we&rsquo;ll learn about is <em>selection sort</em>. The basic idea behind selection sort is to search for the minimum value in the whole container, and place it in the first index. Then, repeat the process for the second smallest value and the second index, and so on until the container is sorted.</p>
<p>Wikipedia includes a great animation that shows this process:</p>
<p><a href="#R-image-ea09461df4923dfe9fd839aa3be03f81" class="lightbox-link"><img alt="Selection Sort GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.9.selection.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ea09461df4923dfe9fd839aa3be03f81"><img alt="Selection Sort GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.9.selection.gif"></a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>In this animation, the element highlighted in blue is the element currently being considered. The red element shows the value that is the minimum value considered, and the yellow elements are the sorted portion of the list.</p>
<h2 id="selection-sort-example">Selection Sort Example</h2>
<p>Let&rsquo;s look at a few steps in this process to see how it works. First, the algorithm will search through the array to find the minimum value. It will start by looking at index 0 as shown in the figure below.</p>
<p><a href="#R-image-1680880a6e7a266e331917b5cac537ef" class="lightbox-link"><img alt="Selection Sort Step 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.9.select1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1680880a6e7a266e331917b5cac537ef"><img alt="Selection Sort Step 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.9.select1.png"></a></p>
<p>Once it reaches the end of the array, it will find that the smallest value 0 is at index 8.</p>
<p><a href="#R-image-d8b28db6d0a468373ee9a5a4fd17d9da" class="lightbox-link"><img alt="Selection Sort Step 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.9.select2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d8b28db6d0a468373ee9a5a4fd17d9da"><img alt="Selection Sort Step 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.9.select2.png"></a></p>
<p>Then, it will <em>swap</em> the minimum item with the item at index 0 of the array, placing the smallest item first. That item will now be part of the sorted array, so we&rsquo;ll shade it in since we don&rsquo;t want to move it again.</p>
<p><a href="#R-image-08b1d61d051635252f58dae4cd4f71bc" class="lightbox-link"><img alt="Selection Sort Step 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.9.select3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-08b1d61d051635252f58dae4cd4f71bc"><img alt="Selection Sort Step 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.9.select3.png"></a></p>
<p>Next, it will reset index to 1, and start searching for the next smallest element in the array. Notice that this time it will not look at the element at index 0, which is part of the sorted array. Each time the algorithm resets, it will start looking at the element directly after the sorted portion of the array.</p>
<p><a href="#R-image-2f779d440e63dde7aef4b905ab499bb8" class="lightbox-link"><img alt="Selection Sort Step 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.9.select4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2f779d440e63dde7aef4b905ab499bb8"><img alt="Selection Sort Step 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.9.select4.png"></a></p>
<p>Once again, it will search through the array to find the smallest value, which will be the value 1 at index 6.</p>
<p><a href="#R-image-accf623bdbdeb16248fa5223d78b8e4b" class="lightbox-link"><img alt="Selection Sort Step 5" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.9.select5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-accf623bdbdeb16248fa5223d78b8e4b"><img alt="Selection Sort Step 5" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.9.select5.png"></a></p>
<p>Then, it will swap the element at index 1 with the minimum element, this time at index 6. Just like before, we&rsquo;ll shade in the first element since it is now part of the sorted list, and reset the index to begin at index 2</p>
<p><a href="#R-image-0ab91cecccdfdd6ff5e145dde2506371" class="lightbox-link"><img alt="Selection Sort Step 6" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.9.select6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0ab91cecccdfdd6ff5e145dde2506371"><img alt="Selection Sort Step 6" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.9.select6.png"></a></p>
<p>This process will repeat until the entire array is sorted in ascending order.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>File:Selection-Sort-Animation.gif. (2016, February 12). Wikimedia Commons, the free media repository. Retrieved 22:22, March 23, 2020 from <a href="https://commons.wikimedia.org/w/index.php?title=File:Selection-Sort-Animation.gif&oldid=187411773" rel="external" target="_blank">https://commons.wikimedia.org/w/index.php?title=File:Selection-Sort-Animation.gif&oldid=187411773</a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="selection-sort-pseudocode">Selection Sort Pseudocode</h1>

<p>To describe our selection sort algorithm, we can start with these basic preconditions and postconditions.</p>
<p><strong>Preconditions:</strong></p>
<ul>
<li>The array stores a type of elements which can be ordered.</li>
</ul>
<p><strong>Postconditions:</strong></p>
<ul>
<li>The array will be sorted in ascending order.</li>
</ul>
<p>We can then represent this algorithm using the following pseudocode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">SELECTIONSORT</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">loop</span> <span class="n">INDEX</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">size</span> <span class="n">of</span> <span class="n">ARRAY</span> <span class="err">â€“</span> <span class="mi">2</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      <span class="n">MININDEX</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="c1"># find minimum index</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">loop</span> <span class="n">INDEX2</span> <span class="kn">from</span> <span class="nn">INDEX</span> <span class="n">to</span> <span class="n">size</span> <span class="n">of</span> <span class="n">ARRAY</span> <span class="err">â€“</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">            <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">MININDEX</span><span class="p">]</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                <span class="n">MININDEX</span> <span class="o">=</span> <span class="n">INDEX</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">end</span> <span class="n">loop</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="c1"># swap elements</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">TEMP</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">MININDEX</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">ARRAY</span><span class="p">[</span><span class="n">MININDEX</span><span class="p">]</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span> <span class="o">=</span> <span class="n">TEMP</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">end</span> <span class="n">loop</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>In this code, we begin by looping through every element in the array except the last one, as seen on line 2. We don&rsquo;t include this one because if the rest of the array is sorted properly, then the last element must be the maximum value.</p>
<p>Lines 3 through 9 are basically the same as what we saw in our <code>findMin</code> function earlier. It will find the index of the minimum value starting at <code>INDEX</code> through the end of the array. Notice that we are starting at <code>INDEX</code> instead of the beginning. As the outer loop moves through the array, the inner loop will consider fewer and fewer elements. This is because the front of the array contains our sorted elements, and we don&rsquo;t want to change them once they are in place.</p>
<p>Lines 11 through 13 will then swap the elements at <code>INDEX</code> and <code>MININDEX</code>, putting the smallest element left in the array at the position pointed to by index.</p>
<p>We can describe the invariant of our outer loop as follows:</p>
<ul>
<li>The array from index 0 through <code>index</code> is sorted in ascending order.</li>
<li>The elements in the array have not changed, only their positions.</li>
</ul>
<p>The second part of the loop invariant is very important. Without that distinction, we could simply place new values into the array before <code>index</code> and satisfy the first part of the invariant. It is always important to specify that the array itself still contains the same elements as before.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="selection-sort-time-complexity">Selection Sort Time Complexity</h1>

<p>Let&rsquo;s look at the time complexity of the selection sort algorithm, just so we can get a feel for how much time this operation takes.</p>
<p>First, we must determine if there is a worst-case input for selection sort. Can we think of any particular input which would require more steps to complete?</p>
<p>In this case, each iteration of selection sort will look at the same number of elements, no matter what they are. So there isn&rsquo;t a particular input that would be considered worst-case. We can proceed with just the general case.</p>
<p>In each iteration of the algorithm we need to search for the minimum value of the remaining elements in the container. If the container has $N$ elements, we would follow the steps below.</p>
<ol>
<li>The first time we need to find the minimum among $N$ elements. This will take $N$ comparisons assuming the element are compared one by one with the minimum.</li>
<li>The second time we need to find the minimum among $N - 1$ elements. This will take $N - 1$ comparisons.</li>
<li>The third time we need to find the minimum among $N - 2$ elements. This will take $N - 2$ comparisons.</li>
<li>&hellip; and so on.</li>
</ol>
<p>This process continues until we have sorted all of the elements in the array. The number of steps will be:</p>
$$
N + (N â€“ 1) + (N â€“ 2) + â€¦ + 2 + 1
$$
<p>While it takes a bit of math to figure out exactly what that means, we can use some intuition to determine an approximate value. For example we could pair up the values like this:</p>
$$
N + [(N â€“ 1) + 1] + [(N â€“ 2) + 2] + ...
$$
<p>When we do that, we&rsquo;ll see that we can create around $N / 2$ pairs, each one with the value of $N$. So a rough approximation of this value is $N * (N / 2)$, which is $N^2 / 2$. When analyzing time complexity, we would say that this is &ldquo;on the order of $N^2$&rdquo; time. Put another way, if the size of $N$ doubles, we would expect the number of steps to go up by a factor of $4$, since $(2 * N)^2 = 4N$.</p>
<p>Later on, we&rsquo;ll come back to this and compare the time complexity of each sorting algorithm and searching algorithm to see how they stack up against each other.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="bubble-sort">Bubble Sort</h1>


<a href="https://www.youtube.com/watch?v=IyyfpADUpaU">YouTube Video</a>

<p>Next, let&rsquo;s look at another sorting algorithm, bubble sort. The basic idea behind bubble sort is to continuously iterate through the array and swap adjacent elements that are out of order. As a side effect of this process, the largest element in the array will be &ldquo;bubbled&rdquo; to the end of the array after the first iteration. Subsequent iterations will do the same for each of the next largest elements, until eventually the entire list is sorted.</p>
<p>Wikipedia includes a great animation that shows this process:</p>
<p><a href="#R-image-115aed892588af39dfc1c3e373db01aa" class="lightbox-link"><img alt="Bubble Sort GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.12.bubble.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-115aed892588af39dfc1c3e373db01aa"><img alt="Bubble Sort GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.12.bubble.gif"></a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>In this animation, the two red boxes slowly move through the array, comparing adjacent elements. If the elements are not in the correct order (that is, the first element is larger than the second element), then it will swap them. Once it reaches the end, the largest element, 8, will be placed at the end and locked in place.</p>
<h2 id="bubble-sort-example">Bubble Sort Example</h2>
<p>Let&rsquo;s walk through a few steps of this process and see how it works. We&rsquo;ll use the array we used previously for selection sort, just to keep things simple. At first, the array will look like the diagram below.</p>
<p><a href="#R-image-a6f0c6cf05ede6741dbdc6d3254c66d8" class="lightbox-link"><img alt="Bubble Sort Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.12.bubble1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a6f0c6cf05ede6741dbdc6d3254c66d8"><img alt="Bubble Sort Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.12.bubble1.png"></a></p>
<p>We&rsquo;ll begin with the <code>index</code> variable pointing at index 0. Our algorithm should compare the values at index 0 and index 1 and see if they need to be swapped. We&rsquo;ll put a bold border around the elements we are currently comparing in the figure below.</p>
<p><a href="#R-image-5bf084ed880815ef658751047a12b8b7" class="lightbox-link"><img alt="Bubble Sort Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.12.bubble2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5bf084ed880815ef658751047a12b8b7"><img alt="Bubble Sort Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.12.bubble2.png"></a></p>
<p>Since the element at index 0 is 8, and the element at index 1 is 5, we know that they must be swapped since 8 is greater than 5. We need to swap those two elements in the array, as shown below.</p>
<p><a href="#R-image-dfdd30920a37a7d742bf878b7faf36d9" class="lightbox-link"><img alt="Bubble Sort Example 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.12.bubble3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dfdd30920a37a7d742bf878b7faf36d9"><img alt="Bubble Sort Example 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.12.bubble3.png"></a></p>
<p>Once those two elements have been swapped, the index variable will be incremented by 1, and we&rsquo;ll look at the elements at indexes 1 and 2 next.</p>
<p><a href="#R-image-b8c975ff3987c26456b86fdba4cdfc70" class="lightbox-link"><img alt="Bubble Sort Example 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.12.bubble4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b8c975ff3987c26456b86fdba4cdfc70"><img alt="Bubble Sort Example 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.12.bubble4.png"></a></p>
<p>Since 8 is greater than 2, we&rsquo;ll swap these two elements before incrementing index to 2 and comparing the next two elements.</p>
<p><a href="#R-image-c2dda83e86f35368643887e0d7614ab3" class="lightbox-link"><img alt="Bubble Sort Example 5" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.12.bubble5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c2dda83e86f35368643887e0d7614ab3"><img alt="Bubble Sort Example 5" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.12.bubble5.png"></a></p>
<p>Again, we&rsquo;ll find that 8 is greater than 6, so we&rsquo;ll swap these two elements and move on to index 3.</p>
<p><a href="#R-image-c01b636c89960d1998f5e2111e403a05" class="lightbox-link"><img alt="Bubble Sort Example 6" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.12.bubble6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c01b636c89960d1998f5e2111e403a05"><img alt="Bubble Sort Example 6" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.12.bubble6.png"></a></p>
<p>Now we are looking at the element at index 3, which is 8, and the element at index 4, which is 9. In this case, 8 is less than 9, so we don&rsquo;t need to swap anything. We&rsquo;ll just increment index by 1 and look at the elements at indexes 4 and 5.</p>
<p><a href="#R-image-0e516d6aa3e03baea04266c48ee367cc" class="lightbox-link"><img alt="Bubble Sort Example 7" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.12.bubble7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0e516d6aa3e03baea04266c48ee367cc"><img alt="Bubble Sort Example 7" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.12.bubble7.png"></a></p>
<p>As we&rsquo;ve done before, we&rsquo;ll find that 9 is greater than 3, so we&rsquo;ll need to swap those two items. In fact, as we continue to move through the array, we&rsquo;ll find that 9 is the largest item in the entire array, so we&rsquo;ll end up swapping it with every element down to the end of the array. At that point, it will be in its final position, so we&rsquo;ll lock it and restart the process again.</p>
<p><a href="#R-image-fd7706b8d67c70cf9cc417a3f8007c02" class="lightbox-link"><img alt="Bubble Sort Example 8" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.12.bubble8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fd7706b8d67c70cf9cc417a3f8007c02"><img alt="Bubble Sort Example 8" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.12.bubble8.png"></a></p>
<p>After making a second pass through the array, swapping elements that must be swapped as we find them, we&rsquo;ll eventually get to the end and find that 8 should be placed at index 8 since it is the next largest value in the array.</p>
<p><a href="#R-image-aefbbe0971b0e16485983d19dbf9952e" class="lightbox-link"><img alt="Bubble Sort Example 9" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.12.bubble9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-aefbbe0971b0e16485983d19dbf9952e"><img alt="Bubble Sort Example 9" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.12.bubble9.png"></a></p>
<p>We can then continue this process until we have locked each element in place at the end of the array.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>File:Bubble-sort-example-300px.gif. (2019, June 12). Wikimedia Commons, the free media repository. Retrieved 22:36, March 23, 2020 from <a href="https://commons.wikimedia.org/w/index.php?title=File:Bubble-sort-example-300px.gif&oldid=354097364" rel="external" target="_blank">https://commons.wikimedia.org/w/index.php?title=File:Bubble-sort-example-300px.gif&oldid=354097364</a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="bubble-sort-pseudocode">Bubble Sort Pseudocode</h1>

<p>To describe our bubble algorithm, we can start with these basic preconditions and postconditions.</p>
<p><strong>Preconditions:</strong></p>
<ul>
<li>The array stores a type of elements which can be ordered.</li>
</ul>
<p><strong>Postconditions:</strong></p>
<ul>
<li>The array will be sorted in ascending order.</li>
</ul>
<p>We can then represent this algorithm using the following pseudocode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">BUBBLESORT</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="c1"># loop through the array multiple times</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">loop</span> <span class="n">INDEX</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">size</span> <span class="n">of</span> <span class="n">ARRAY</span> <span class="err">â€“</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="c1"># consider every pair of elements except the sorted ones</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">loop</span> <span class="n">INDEX2</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">size</span> <span class="n">of</span> <span class="n">ARRAY</span> <span class="err">â€“</span> <span class="mi">2</span> <span class="err">â€“</span> <span class="n">INDEX</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">            <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                <span class="c1"># swap elements if they are out of order</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">                <span class="n">TEMP</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX2</span><span class="p">]</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">                <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">                <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">TEMP</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">end</span> <span class="n">loop</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">end</span> <span class="n">loop</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>In this code, we begin by looping through every element in the array, as seen on line 3. Each time we run this outer loop, we&rsquo;ll lock one additional element in place at the end of the array. Therefore, we need to run it once for each element in the array.</p>
<p>On line 5, we&rsquo;ll start at the beginning of the array and loop to the place where the sorted portion of the array begins. We know that after each iteration of the outer loop, the value <code>index</code> will represent the number of locked elements at the end of the array. We can subtract that value from the end of the array to find where we want to stop.</p>
<p>Line 6 is a comparison between two adjacent elements in the array starting at the index <code>index2</code>. If they are out of order, we use lines 8 through 10 to swap them. That&rsquo;s really all it takes to do a bubble sort!</p>
<p>Looking at this code, we can describe the invariant of our outer loop as follows:</p>
<ul>
<li>The last <code>index</code> elements in the array are in sorted order, and</li>
<li>The elements in the array have not changed, only their positions.</li>
</ul>
<p>Notice how this differs from selection sort, since it places the sorted elements at the beginning of the array instead of the end. However, the result is the same, and by the end of the program we can show that each algorithm has fully sorted the array.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="bubble-sort-time-complexity">Bubble Sort Time Complexity</h1>

<p>Once again, let&rsquo;s look at the time complexity of the bubble sort algorithm and see how it compares to selection sort.</p>
<p>Bubble sort is a bit trickier to analyze than selection sort, because there are really two parts to the algorithm:</p>
<ol>
<li>The number of comparisons, and</li>
<li>The number of swaps.</li>
</ol>
<p>Let&rsquo;s look at each one individually. First, is there a way to reduce the number of comparisons made by this algorithm just by changing the input? As it turns out, there isn&rsquo;t anything we can do to change that based on how it is written. The number of comparisons only depends on the size of the array. In fact, the analysis is exactly the same as selection sort, since each iteration of the outer loop does one fewer comparison. Therefore, we can say that bubble sort has time complexity on the order of $N^2$ time when it comes to comparisons.</p>
<p>What about swaps? This is where it gets a bit tricky. What would be the worst-case input for the bubble sort algorithm, which would result in the largest number of swaps made?</p>
<p>Consider a case where the input is sorted in descending order. The largest element will be first, and the smallest element will be last. If we want the result to be sorted in ascending order, we would end up making $N - 1$ swaps to get the first element to the end of the array, then $N - 2$ swaps for the second element, and so on. So, once again we end up with the same series as before:</p>
$$
(N â€“ 1) + (N â€“ 2) + ... + 2 + 1.
$$
<p>In the worst-case, we&rsquo;ll also end up doing on the order of $N^2$ swaps, so bubble sort has a time complexity on the order of $N^2$ time when it comes to swaps as well.</p>
<h2 id="comparing-selection-sort-and-bubble-sort">Comparing Selection Sort and Bubble Sort</h2>
<p>It seems that both bubble sort and selection sort are in the same order of time complexity, meaning that each one will take roughly the same amount of time to sort the same array. Does that tell us anything about the process of sorting an array?</p>
<p>Here&rsquo;s one way to think about it: what if we decided to compare each element in an array to every other element? How many comparisons would that take? We can use our intuition to know that each element in an array of $N$ elements would require $N â€“ 1$ comparisons, so the total number of comparisons would be $N * (N â€“ 1)$, which is very close to $N^2$.</p>
<p>Of course, once we&rsquo;ve compared each element to every other element, we&rsquo;d know exactly where to place them in a sorted array. One possible conclusion we could make is that there isn&rsquo;t any way to sort an array that runs much faster than an algorithm that runs in the order of $N^2$ time.</p>
<p>Thankfully, that conclusion is incorrect! There are several other sorting algorithms we can use that allow us to sort an array much more quickly than $N^2$ time. Let&rsquo;s take a look at those algorithms and see how they work!</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="merge-sort">Merge Sort</h1>


<a href="https://www.youtube.com/watch?v=MCBt3y_R_Co">YouTube Video</a>

<p>Another commonly used sorting algorithm is <em>merge sort</em>. Merge sort uses a recursive, divide and conquer approach to sorting, which makes it very powerful. It was actually developed to handle sorting data sets that were so large that they couldn&rsquo;t fit on a single memory device, way back in the early days of computing.</p>
<p>The basic idea of the merge sort algorithm is as follows:</p>
<ol>
<li>If the container only contains one or two elements, we can quickly sort that container by swapping the elements if needed.</li>
<li>Otherwise, we should divide the container in half and recursively use merge sort on each half.</li>
<li>Once each half is sorted, we can then merge them back together into a single container.</li>
</ol>
<p>Once again, Wikipedia has a great animation showing this process:</p>
<p><a href="#R-image-a62ffcad1fca29d298be6f7d75fe73c3" class="lightbox-link"><img alt="Merge Sort GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a62ffcad1fca29d298be6f7d75fe73c3"><img alt="Merge Sort GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge.gif"></a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<h2 id="merge-sort-example">Merge Sort Example</h2>
<p>Let&rsquo;s walk through a simple example and see how it works. First, we&rsquo;ll start with the same initial array as before, shown in the figure below. To help us keep track, we&rsquo;ll refer to this function call using the array indexes it covers. It will be <code>mergeSort(0, 9)</code>.</p>
<p><a href="#R-image-b9d3423128e2cb49556d7c1e35ab1895" class="lightbox-link"><img alt="Merge Sort Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b9d3423128e2cb49556d7c1e35ab1895"><img alt="Merge Sort Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge1.png"></a></p>
<p>Since this array contains more than 2 elements, we won&rsquo;t be able to sort it quickly. Instead, we&rsquo;ll divide it in half, and sort each half using merge sort again. Let&rsquo;s continue the process with the first half of the array. We&rsquo;ll use a thick outline to show the current portion of the array we are sorting, but we&rsquo;ll retain the original array indexes to help keep track of everything.</p>
<p><a href="#R-image-63f14800b352c1e05c340ef844431f06" class="lightbox-link"><img alt="Merge Sort Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-63f14800b352c1e05c340ef844431f06"><img alt="Merge Sort Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge2.png"></a></p>
<p>Now we are in the first recursive call, <code>mergeSort(0, 4)</code>,which is looking at the first half of the original array. Once again, we have more than 2 elements, so we&rsquo;ll split it in half and recursively call <code>mergeSort(0, 1)</code> first.</p>
<p><a href="#R-image-0abe97403db24fb3695583a49409e13e" class="lightbox-link"><img alt="Merge Sort Example 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0abe97403db24fb3695583a49409e13e"><img alt="Merge Sort Example 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge3.png"></a></p>
<p>At this point, we now have an array with just 2 elements. We can use one of our base cases to sort that array by swapping the two elements, if needed. In this case, we should swap them, so we&rsquo;ll get the result shown below.</p>
<p><a href="#R-image-3f7118b32d9b64c28c08d304568440cb" class="lightbox-link"><img alt="Merge Sort Example 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3f7118b32d9b64c28c08d304568440cb"><img alt="Merge Sort Example 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge4.png"></a></p>
<p>Now that the first half of the smaller array has been sorted, our recursive call <code>mergeSort(0, 1)</code> will return and we&rsquo;ll look at the second half of the smaller array in the second recursive call, <code>mergeSort(2, 4)</code>, as highlighted below.</p>
<p><a href="#R-image-4d06dbe1ddbb6bfb4f2f27c792a2c2c6" class="lightbox-link"><img alt="Merge Sort Example 5" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4d06dbe1ddbb6bfb4f2f27c792a2c2c6"><img alt="Merge Sort Example 5" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge5.png"></a></p>
<p>As we&rsquo;ve seen before, this array has more than 2 elements, so we&rsquo;ll need to divide it in half and recursively call the function again. First, we&rsquo;ll call <code>mergeSort(2, 2)</code>.</p>
<p><a href="#R-image-fba4f7b2f2ad4ddae9460d2d68d5cb3f" class="lightbox-link"><img alt="Merge Sort Example 6" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fba4f7b2f2ad4ddae9460d2d68d5cb3f"><img alt="Merge Sort Example 6" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge6.png"></a></p>
<p>In this case, the current array we are considering contains a single element, so it is already sorted. Therefore, the recursive call to <code>mergeSort(2, 2)</code> will return quickly, and we&rsquo;ll consider the second part of the smaller array in <code>mergeSort(3, 4)</code>, highlighted below.</p>
<p><a href="#R-image-e97ddc2c760cb84189148a724aaec300" class="lightbox-link"><img alt="Merge Sort Example 7" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e97ddc2c760cb84189148a724aaec300"><img alt="Merge Sort Example 7" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge7.png"></a></p>
<p>Here, we have 2 elements, and this time they are already sorted. So, we don&rsquo;t need to do anything, and our recursive call to <code>mergeSort(3, 4)</code> will return. At this point, we will be back in our call to <code>mergeSort(2, 4)</code>, and both halves of that array have been sorted. We&rsquo;re back to looking at the highlighted elements below.</p>
<p><a href="#R-image-0cbed74c85c0a24ac8ada0540cfca0ef" class="lightbox-link"><img alt="Merge Sort Example 8" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0cbed74c85c0a24ac8ada0540cfca0ef"><img alt="Merge Sort Example 8" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge8.png"></a></p>
<p>Now we have to merge these two arrays together. Thankfully, since they are sorted, we can follow this simple process:</p>
<ol>
<li>Create a temporary array that has the same size as both halves combined.</li>
<li>Look at the first element of each half of the original array. Choose the smaller of the two.</li>
<li>Place that element first in the temporary array.</li>
<li>Repeat steps 2 and 3 until one half is empty.</li>
<li>Place the remaining elements of the half that is not empty at the end of the temporary array.</li>
<li>Replace the original array with the temporary array.</li>
</ol>
<p>Let&rsquo;s take a look at what that process would look like. First, we&rsquo;ll create a new temporary array to store the result.</p>
<p><a href="#R-image-bc98f96a1b4a907738c57d3db9b397b0" class="lightbox-link"><img alt="Merge Sort Example 9" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bc98f96a1b4a907738c57d3db9b397b0"><img alt="Merge Sort Example 9" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge9.png"></a></p>
<p>Next, we will look at the first element in each of the two sorted halves of the original array. In this case, we&rsquo;ll compare 2 and 6, which are highlighted below.</p>
<p><a href="#R-image-81550f19081496c09342d41fcd1322b8" class="lightbox-link"><img alt="Merge Sort Example 10" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge10.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-81550f19081496c09342d41fcd1322b8"><img alt="Merge Sort Example 10" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge10.png"></a></p>
<p>Now we should pick the smaller of those two values, which will be 2. That value will be placed in the new temporary array at the very beginning.</p>
<p><a href="#R-image-e79dc9cd409e6797d07f2f3b753d6639" class="lightbox-link"><img alt="Merge Sort Example 11" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge11.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e79dc9cd409e6797d07f2f3b753d6639"><img alt="Merge Sort Example 11" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge11.png"></a></p>
<p>Next, we should look at the remaining halves of the array. Since the first half is empty, we can just place the remaining elements from the second half into the temporary array.</p>
<p><a href="#R-image-da5892c453ee62036bfddfe835514af4" class="lightbox-link"><img alt="Merge Sort Example 12" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge12.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-da5892c453ee62036bfddfe835514af4"><img alt="Merge Sort Example 12" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge12.png"></a></p>
<p>Finally, we should replace the portion of the original array that we are looking at in this recursive call with the temporary array. In most cases, we&rsquo;ll just copy these elements into the correct places in the original array. In the diagram, we&rsquo;ll just replace them.</p>
<p><a href="#R-image-f7be7e69f4daaa25b8eca91a324ee6db" class="lightbox-link"><img alt="Merge Sort Example 13" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge13.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f7be7e69f4daaa25b8eca91a324ee6db"><img alt="Merge Sort Example 13" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge13.png"></a></p>
<p>There we go! We&rsquo;ve now completed the recursive call <code>mergeSort(2, 4)</code>. We can return from that recursive call and go back to <code>mergeSort(0, 4)</code>.</p>
<p><a href="#R-image-1a3851992b6f13cfe87753f657975f53" class="lightbox-link"><img alt="Merge Sort Example 14" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge14.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1a3851992b6f13cfe87753f657975f53"><img alt="Merge Sort Example 14" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge14.png"></a></p>
<p>Since both halves of the array in <code>mergeSort(0, 4)</code> are sorted, we must do the merge process again.  We&rsquo;ll start with a new temporary array and compare the first element in each half.</p>
<p><a href="#R-image-a8392d1b9af86896ed4c0cbabdf87b4d" class="lightbox-link"><img alt="Merge Sort Example 15" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge15.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a8392d1b9af86896ed4c0cbabdf87b4d"><img alt="Merge Sort Example 15" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge15.png"></a></p>
<p>At this point, we&rsquo;ll see that 2 is the smaller of those elements, so we&rsquo;ll place it in the first slot in the temporary array and consider the next element in the second half.</p>
<p><a href="#R-image-3562f834996f9f4eb8536fe40fa71594" class="lightbox-link"><img alt="Merge Sort Example 16" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge16.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3562f834996f9f4eb8536fe40fa71594"><img alt="Merge Sort Example 16" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge16.png"></a></p>
<p>Next, we&rsquo;ll compare the values 5 and 6, and see that 5 is smaller. It should be placed in the next available element in our temporary array and we should continue onward.</p>
<p><a href="#R-image-78e754f2f067a265c986bdc028f3ea1c" class="lightbox-link"><img alt="Merge Sort Example 17" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge17.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-78e754f2f067a265c986bdc028f3ea1c"><img alt="Merge Sort Example 17" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge17.png"></a></p>
<p>We&rsquo;ll repeat this process again, placing the 6 in the temporary array, then the 8, then finally the 9.  After completing the merge process, we&rsquo;ll have the following temporary array.</p>
<p><a href="#R-image-87f67707747167d7565732c56cd5b4cd" class="lightbox-link"><img alt="Merge Sort Example 18" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge18.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-87f67707747167d7565732c56cd5b4cd"><img alt="Merge Sort Example 18" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge18.png"></a></p>
<p>Finally, we&rsquo;ll replace the original elements with the now merged elements in the temporary array.</p>
<p><a href="#R-image-15f3c6096861af18fb2e4280237bd3ee" class="lightbox-link"><img alt="Merge Sort Example 19" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge19.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-15f3c6096861af18fb2e4280237bd3ee"><img alt="Merge Sort Example 19" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge19.png"></a></p>
<p>There we go! We&rsquo;ve now completed the process in the <code>mergeSort(0, 4)</code> recursive call. Once that returns, we&rsquo;ll be back in our original call to <code>mergeSort(0, 9)</code>. In that function, we&rsquo;ll recursively call the process again on the second half of the array using <code>mergeSort(5, 9)</code>.</p>
<p>Hopefully by now we understand that it will work just like we intended, so by the time that recursive call returns, we&rsquo;ll now have the second half of the array sorted as well.</p>
<p><a href="#R-image-18819045eb1c7f78224feedfce0428cd" class="lightbox-link"><img alt="Merge Sort Example 20" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge20.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-18819045eb1c7f78224feedfce0428cd"><img alt="Merge Sort Example 20" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge20.png"></a></p>
<p>The last step in the original <code>mergeSort(0, 9)</code> function call is to merge these two halves together. So, once again, we&rsquo;ll follow that same process as before, creating a new temporary array and moving through the elements in each half, placing the smaller of the two in the new array. Once we are done, we&rsquo;ll end up with a temporary array that has been populated as shown below.</p>
<p><a href="#R-image-acfc0d9e622a68fbf5cc57d116d2ec0f" class="lightbox-link"><img alt="Merge Sort Example 21" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge21.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-acfc0d9e622a68fbf5cc57d116d2ec0f"><img alt="Merge Sort Example 21" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge21.png"></a></p>
<p>Finally, we&rsquo;ll replace the elements in the original array with the ones in the temporary array, resulting in a completely sorted result.</p>
<p><a href="#R-image-08ffd1b00b04f3c38dd5e3d5a404c35f" class="lightbox-link"><img alt="Merge Sort Example 22" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.15.merge22.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-08ffd1b00b04f3c38dd5e3d5a404c35f"><img alt="Merge Sort Example 22" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.15.merge22.png"></a></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>File:Merge-sort-example-300px.gif. (2020, February 22). Wikimedia Commons, the free media repository. Retrieved 00:06, March 24, 2020 from <a href="https://commons.wikimedia.org/w/index.php?title=File:Merge-sort-example-300px.gif&oldid=397192885" rel="external" target="_blank">https://commons.wikimedia.org/w/index.php?title=File:Merge-sort-example-300px.gif&oldid=397192885</a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="merge-sort-pseudocode">Merge Sort Pseudocode</h1>

<p>Now that we&rsquo;ve seen how merge sort works by going through an example, let&rsquo;s look at the pseudocode of a merge sort function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">MERGESORT</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">START</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="c1"># base case size == 1</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="n">END</span> <span class="o">-</span> <span class="n">START</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1"># base case size == 2</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">if</span> <span class="n">END</span> <span class="o">-</span> <span class="n">START</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="c1"># check if elements are out of order</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">START</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">END</span><span class="p">]</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="c1"># swap if so</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="n">TEMP</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">START</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="n">ARRAY</span><span class="p">[</span><span class="n">START</span><span class="p">]</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">END</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="n">ARRAY</span><span class="p">[</span><span class="n">END</span><span class="p">]</span> <span class="o">=</span> <span class="n">TEMP</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="c1"># find midpoint</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">HALF</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">START</span> <span class="o">+</span> <span class="n">END</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="c1"># sort first half</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">MERGESORT</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">START</span><span class="p">,</span> <span class="n">HALF</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="c1"># sort second half</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">MERGESORT</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">HALF</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="c1"># merge halves</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">MERGE</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">START</span><span class="p">,</span> <span class="n">HALF</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>This function is a recursive function which has two base cases. The first base case is shown in lines 3 through 5, where the size of the array is exactly 1. In that case, the array is already sorted, so we just return on line 4 without doing anything.</p>
<p>The other base case is shown in lines 7 through 15. In this case, the element contains just two elements. We can use the if statement on line 9 to check  if those two elements are in the correct order. If not, we can use lines 11 through 13 to swap them, before returning on line 15.</p>
<p>If neither of the base cases occurs, then we reach the recursive case starting on line 18. First, we&rsquo;ll need to determine the midpoint of the array, which is just the average of the <code>start</code> and <code>end</code> variables. We&rsquo;ll need to remember to make sure that value is an integer by truncating it if needed.</p>
<p>Then, on lines 20 and 22 we make two recursive calls, each one focusing on a different half of the array. Once each of those calls returns, we can assume that each half of the array is now sorted.</p>
<p>Finally, in line 24 we call a helper function known as <code>merge</code> to merge the two halves together. The pseudocode for that process is below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">MERGE</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">START</span><span class="p">,</span> <span class="n">HALF</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">TEMPARRAY</span> <span class="o">=</span> <span class="n">new</span> <span class="n">array</span><span class="p">[</span><span class="n">END</span> <span class="err">â€“</span> <span class="n">START</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">INDEX1</span> <span class="o">=</span> <span class="n">START</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">INDEX2</span> <span class="o">=</span> <span class="n">HALF</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">NEWINDEX</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">loop</span> <span class="k">while</span> <span class="n">INDEX1</span> <span class="o">&lt;=</span> <span class="n">HALF</span> <span class="ow">and</span> <span class="n">INDEX2</span> <span class="o">&lt;=</span> <span class="n">END</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX2</span><span class="p">]</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="n">TEMPARRAY</span><span class="p">[</span><span class="n">NEWINDEX</span><span class="p">]</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX1</span><span class="p">]</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="n">INDEX1</span> <span class="o">=</span> <span class="n">INDEX1</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="n">TEMPARRAY</span><span class="p">[</span><span class="n">NEWINDEX</span><span class="p">]</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX2</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="n">INDEX2</span> <span class="o">=</span> <span class="n">INDEX2</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">NEWINDEX</span> <span class="o">=</span> <span class="n">NEWINDEX</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">end</span> <span class="n">loop</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">loop</span> <span class="k">while</span> <span class="n">INDEX1</span> <span class="o">&lt;=</span> <span class="n">HALF</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="n">TEMPARRAY</span><span class="p">[</span><span class="n">NEWINDEX</span><span class="p">]</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX1</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="n">INDEX1</span> <span class="o">=</span> <span class="n">INDEX1</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="n">NEWINDEX</span> <span class="o">=</span> <span class="n">NEWINDEX</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">end</span> <span class="n">loop</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">loop</span> <span class="k">while</span> <span class="n">INDEX2</span> <span class="o">&lt;=</span> <span class="n">END</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="n">TEMPARRAY</span><span class="p">[</span><span class="n">NEWINDEX</span><span class="p">]</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX2</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="n">INDEX2</span> <span class="o">=</span> <span class="n">INDEX2</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="n">NEWINDEX</span> <span class="o">=</span> <span class="n">NEWINDEX</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">end</span> <span class="n">loop</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">loop</span> <span class="n">INDEX</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">size</span> <span class="n">of</span> <span class="n">TEMPARRAY</span> <span class="err">â€“</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="n">ARRAY</span><span class="p">[</span><span class="n">START</span> <span class="o">+</span> <span class="n">INDEX</span><span class="p">]</span> <span class="o">=</span> <span class="n">TEMPARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">end</span> <span class="n">loop</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>The <code>merge</code> function begins by creating some variables. The <code>tempArray</code> will hold the newly merged array. <code>Index1</code> refers to the element in the first half that is being considered, while <code>index2</code> refers to the element in the second half. Finally, <code>newIndex</code> keeps track of our position in the new array.</p>
<p>The first loop starting on line 6 will continue operating until one half or the other has been completely added to the temporary array. It starts by comparing the first element in each half of the array. Then, depending on which one is smaller, it will place the smaller of the two in the new array and increment the indexes.</p>
<p>Once the first loop has completed, there are two more loops starting on lines 16 and 21. However, only one of those loops will actually execute, since only one half of the array will have any elements left in it to be considered. These loops will simply copy the remaining elements to the end of the temporary array.</p>
<p>Finally, the last loop starting on line 26 will copy the elements from the temporary array back into the source array. At this point, they will be properly merged in sorted order.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="merge-sort-time-complexity">Merge Sort Time Complexity</h1>

<p>Now that we&rsquo;ve reviewed the pseudocode for the merge sort algorithm, let&rsquo;s see if we can analyze the time it takes to complete. Analyzing a recursive algorithm requires quite a bit of math and understanding to do it properly, but we can get a pretty close answer using a bit of intuition about what it does.</p>
<p>For starters, let&rsquo;s consider a diagram that shows all of the different recursive calls made by merge sort, as shown below.</p>
<p><a href="#R-image-d80ebd988ea5f657737b76228f1258e2" class="lightbox-link"><img alt="Merge Sort Time Complexity Diagram 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.17.mergetree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d80ebd988ea5f657737b76228f1258e2"><img alt="Merge Sort Time Complexity Diagram 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.17.mergetree.png"></a></p>
<p>The first thing we should do is consider the worst-case input for merge sort. What would that look like? Put another way, would the values or the ordering of those values change anything about how merge sort operates?</p>
<p>The only real impact that the input would have is on the number of swaps made by merge sort. If we had an input that caused each of the base cases with exactly two elements to swap them, that would be a few more steps than any other input. Consider the highlighted entries below.</p>
<p><a href="#R-image-df2af08933dcd35be2c83bd22cb4c8d5" class="lightbox-link"><img alt="Merge Sort Time Complexity Diagram 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.17.mergetree2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-df2af08933dcd35be2c83bd22cb4c8d5"><img alt="Merge Sort Time Complexity Diagram 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.17.mergetree2.png"></a></p>
<p>If each of those pairs were reversed, we&rsquo;d end up doing that many swaps. So, how many swaps would that be? As it turns out, a good estimate would be $N / 2$ times. If we have an array with exactly 16 elements, there are at most 8 swaps we could make. With 10 elements, we can make at most 4. So, the number of swaps is on the order of N time complexity.</p>
<p>What about the merge operation? How many steps does that take? This is a bit trickier to answer, but let&rsquo;s look at each row of the diagram above. Across all of the calls to merge sort on each row, we&rsquo;ll end up merging all $N$ elements in the original array at least once. Therefore, we know that it would take around $N$ steps for each row in the diagram. We&rsquo;ll just need to figure out how many rows there are.</p>
<p>A better way to phrase that question might be &ldquo;how many times can we recursively divide an array of $N$ elements in half?&rdquo; As it turns out, the answer to that question lies in the use of the logarithm.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Logarithm</div>
  <div class="box-content">

<p>The logarithm is the inverse of exponentiation. For example, we could have the exponentiation formula:</p>
$$
\text{base}^{\text{exponent}} = \text{power}
$$
<p>The inverse of that would be the logarithm
</p>
$$
\text{log}_{\text{base}}(\text{power}) = \text{exponent}
$$
<p>So, if we know a value and base, we can determine the exponent required to raise that base to the given value.</p>
</div>
</div>
<p>In this case, we would need to use the logarithm with base $2$, since we are dividing the array in half each time. So, we would say that the number of rows in that diagram, or the number of levels in our tree would be on the order of $\text{log}_2(N)$. In computer science, we typically write $\text{log}_2$ as $\text{lg}$, so we&rsquo;ll say it is on the order of $\text{lg}(N)$.</p>
<p>To get an idea of how that works, consider the case where the array contains exactly $16$ elements. In that case, the value $\text{lg}(16)$ is $4$, since $2^4 = 16$. If we use the diagram above as a model, we can draw a similar diagram for an array containing $16$ elements and find that it indeed has $4$ levels.</p>
<p>If we double the size of the array, we&rsquo;ll now have $32$ elements. However, even by doubling the size of the array, the value of $\text{lg}(32)$ is just $5$, so it has only increased by $1$. In fact, each time we double the size of the array, the value of $\text{lg}(N)$ will only go up by $1$.</p>
<p>With that in mind, we can say that the merge operation runs on the order of $N * \text{lg}(N)$ time. That is because there are ${\text{lg}(N)}$ levels in the tree, and each level of the tree performs $N$ operations to merge various parts of the array together. The diagram below gives a good graphical representation of how we can come to that conclusion.</p>
<p><a href="#R-image-b2f5ca841c03a1ad723aeaf9af3b77c1" class="lightbox-link"><img alt="Merge Sort Time Complexity Diagram 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.17.mergetree3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b2f5ca841c03a1ad723aeaf9af3b77c1"><img alt="Merge Sort Time Complexity Diagram 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.17.mergetree3.png"></a></p>
<p>Putting it all together, we have $N/2$ swaps, and $N * \text{lg}(N)$ steps for the merge. Since the value $N * \text{lg}(N)$ is larger than $N$, we would say that total running time of merge sort is on the order of $N * \text{lg}(N)$.</p>
<p>Later on in this chapter we&rsquo;ll discuss how that compares to the running time of selection sort and bubble sort and how that impacts our programs.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="quicksort">Quicksort</h1>


<a href="https://www.youtube.com/watch?v=8_jc6gP0RXY">YouTube Video</a>

<p>The last sorting algorithm we will review in this module is quicksort. Quicksort is another example of a recursive, divide and conquer sorting algorithm, and at first glance it may look very similar to merge sort. However, quicksort uses a different process for dividing the array, and that can produce some very interesting results.</p>
<p>The basic idea of quicksort is as follows:</p>
<ol>
<li>Choose a pivot value, called <code>pivotValue</code>. This value could be any random value in the array. In our implementation, we&rsquo;ll simply use the last value.</li>
<li>Partition the values in the container into two parts:
<ol>
<li>the left part contains all the elements less than or equal to the value of <code>pivotValue</code></li>
<li>the right part contains all the elements greater than the value of <code>pivotValue</code></li>
</ol>
</li>
<li>Place <code>pivotValue</code> in between those two parts. We&rsquo;ll call the index of <code>pivotValue</code> the <code>pivotIndex</code>.</li>
<li>Recursively sort the two parts by calling the quicksort procedure again:
<ol>
<li>the first call sorts the values in the container from start to <code>pivotIndex â€“ 1</code></li>
<li>the second call sort the values in the container from <code>pivotIndex + 1</code> to the end</li>
</ol>
</li>
<li>Once the recursive calls are complete, the entire container should be sorted.</li>
</ol>
<p>As with all of the other examples we&rsquo;ve looked at in this module, Wikipedia provides yet another excellent animation showing this process.</p>
<p><a href="#R-image-8b76613d4a1564228727831dca442761" class="lightbox-link"><img alt="Quicksort GIF" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quicksort.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8b76613d4a1564228727831dca442761"><img alt="Quicksort GIF" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quicksort.gif"></a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<h2 id="quicksort-example">Quicksort Example</h2>
<p>Let&rsquo;s look at an example of the quicksort algorithm in action to see how it works. Unlike the other sorting algorithms we&rsquo;ve seen, this one may appear to be just randomly swapping elements around at first glance. However, as we move through the example, we should start to see how it achieves a sorted result, usually very quickly!</p>
<p>We can start with our same initial array, shown below.</p>
<p><a href="#R-image-e86e1911419658ec27c604d96feb6784" class="lightbox-link"><img alt="Quicksort Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e86e1911419658ec27c604d96feb6784"><img alt="Quicksort Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick1.png"></a></p>
<p>The first step is to choose a pivot value. As we discussed above, we can choose any random value in the array. However, to make it simple, we&rsquo;ll just use the last value. We will create two variables, <code>pivotValue</code> and <code>pivotIndex</code>, to help us keep track of things. We&rsquo;ll set <code>pivotValue</code> to the last value in the array, and <code>pivotIndex</code> will initially be set to 0. We&rsquo;ll see why in a few steps.</p>
<p><a href="#R-image-41a5cd313ccc6d389c9f52df08c29c9a" class="lightbox-link"><img alt="Quicksort Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-41a5cd313ccc6d389c9f52df08c29c9a"><img alt="Quicksort Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick2.png"></a></p>
<p>Now, the algorithm will iterate across each element in the array, comparing it with the value in <code>pivotValue</code>. If that value is less than or equal to the <code>pivotValue</code>, we should swap the element at <code>pivotIndex</code> with the value we are looking at in the array. Let&rsquo;s see how this would work.</p>
<p><a href="#R-image-5624b214d2a0a337a3e31865c70ad17d" class="lightbox-link"><img alt="Quicksort Example 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5624b214d2a0a337a3e31865c70ad17d"><img alt="Quicksort Example 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick3.png"></a></p>
<p>We&rsquo;d start by looking at the value at index 0 of the array, which is 8. Since that value is greater than the <code>pivotValue</code>, we do nothing and just look at the next item.</p>
<p><a href="#R-image-9bb2788cece1c1f05f1da0f84deba7eb" class="lightbox-link"><img alt="Quicksort Example 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9bb2788cece1c1f05f1da0f84deba7eb"><img alt="Quicksort Example 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick4.png"></a></p>
<p>Here, we are considering the value 5, which is at index 1 in the array. In this case, that value is less than or equal to the <code>pivotValue</code>. So, we want to swap the current element with the element at our <code>pivotIndex</code>, which is currently 0. Once we do that, we&rsquo;ll also increment our <code>pivotIndex</code> by 1. The diagram below shows these changes before they happen.</p>
<p><a href="#R-image-6662a1b583719db21a6ac823e5c6f4ff" class="lightbox-link"><img alt="Quicksort Example 5" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6662a1b583719db21a6ac823e5c6f4ff"><img alt="Quicksort Example 5" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick5.png"></a></p>
<p>Once we make those changes, our array should look like the following diagram, and we&rsquo;ll be ready to examine the value at index 2.</p>
<p><a href="#R-image-e535d4fd6ea45940db1af99c64db3eb6" class="lightbox-link"><img alt="Quicksort Example 6" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e535d4fd6ea45940db1af99c64db3eb6"><img alt="Quicksort Example 6" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick6.png"></a></p>
<p>Once again, the value 2 at index 2 of the array is less than or equal to the pivot value. So, we&rsquo;ll swap them, increment <code>pivotValue</code>, and move to the next element.</p>
<p><a href="#R-image-43e1b3ff1404b28678cf1c7f48c1f3dd" class="lightbox-link"><img alt="Quicksort Example 7" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-43e1b3ff1404b28678cf1c7f48c1f3dd"><img alt="Quicksort Example 7" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick7.png"></a></p>
<p>We&rsquo;ll continue this process, comparing the next element in the array with the <code>pivotValue</code>, and then swapping that element and the element at the <code>pivotIndex</code> if needed, incrementing the <code>pivotIndex</code> after each swap. The diagrams below show the next few steps. First, since 6 is less than or equal to our <code>pivotValue</code>, we&rsquo;ll swap it with the pivot index and increment.</p>
<p><a href="#R-image-166ab630a464206d32a3a6b782f186bb" class="lightbox-link"><img alt="Quicksort Example 8" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-166ab630a464206d32a3a6b782f186bb"><img alt="Quicksort Example 8" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick8.png"></a></p>
<p>However, since 9 is greater than the pivot index, we&rsquo;ll just leave it as is for now and move to the next element.</p>
<p><a href="#R-image-d975ec33ae4da3ee2e0f2442ede1c9f2" class="lightbox-link"><img alt="Quicksort Example 9" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d975ec33ae4da3ee2e0f2442ede1c9f2"><img alt="Quicksort Example 9" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick9.png"></a></p>
<p>3 is less than or equal to the pivot value, so we&rsquo;ll swap the element at index 3 with the 3 at index 5.</p>
<p><a href="#R-image-fc1f40a0ba72886f453b05b8fd30b3d6" class="lightbox-link"><img alt="Quicksort Example 10" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick10.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fc1f40a0ba72886f453b05b8fd30b3d6"><img alt="Quicksort Example 10" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick10.png"></a></p>
<p>We&rsquo;ll see that the elements at indexes 6, 7 and 8 are all less than or equal to the pivot value. So, we&rsquo;ll end up making some swaps until we reach the end of the list.</p>
<p><a href="#R-image-8308c3d9bf9a4c6c47f6d97356e94b6d" class="lightbox-link"><img alt="Quicksort Example 11" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick11.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8308c3d9bf9a4c6c47f6d97356e94b6d"><img alt="Quicksort Example 11" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick11.png"></a></p>
<p><a href="#R-image-e8f7297c3bc660db2bfa7bf593cb3b56" class="lightbox-link"><img alt="Quicksort Example 12" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick12.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e8f7297c3bc660db2bfa7bf593cb3b56"><img alt="Quicksort Example 12" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick12.png"></a></p>
<p><a href="#R-image-afc03f63328b4e84b21c382ae9647c16" class="lightbox-link"><img alt="Quicksort Example 13" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick13.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-afc03f63328b4e84b21c382ae9647c16"><img alt="Quicksort Example 13" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick13.png"></a></p>
<p>Finally, we have reached the end of the array, which contains our <code>pivotValue</code> in the last element. Thankfully, we can just continue our process one more step. Since the <code>pivotValue</code> is less than or equal to itself, we swap it with the element at the <code>pivotIndex</code>, and increment that index one last time.</p>
<p><a href="#R-image-c219e09963db81a111a418deb93342c0" class="lightbox-link"><img alt="Quicksort Example 14" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick14.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c219e09963db81a111a418deb93342c0"><img alt="Quicksort Example 14" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick14.png"></a></p>
<p>At this point, we have partitioned the initial array into two sections. The first section contains all of the values which are less than or equal to the pivot value, and the second section contains all values greater than the pivot value.</p>
<p><a href="#R-image-05bfa900bc89a863ed85032e553bf105" class="lightbox-link"><img alt="Quicksort Example 15" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.18.quick15.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-05bfa900bc89a863ed85032e553bf105"><img alt="Quicksort Example 15" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.18.quick15.png"></a></p>
<p>This demonstrates the powerful way that quicksort can quickly partition an array based on a pivot value! With just a single pass through the array, we have created our two halves and done at least some preliminary sorting. The last step is to make two recursive calls to quicksort, one that sorts the items from the beginning of the array through the element right before the <code>pivotValue</code>. The other will sort the elements starting after the <code>pivotValue</code> through the end of the array.</p>
<p>Once each of those recursive calls is complete, the entire array will be sorted!</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>File:Sorting quicksort anim.gif. (2019, July 30). Wikimedia Commons, the free media repository. Retrieved 01:14, March 24, 2020 from <a href="https://commons.wikimedia.org/w/index.php?title=File:Sorting_quicksort_anim.gif&oldid=359998181" rel="external" target="_blank">https://commons.wikimedia.org/w/index.php?title=File:Sorting_quicksort_anim.gif&oldid=359998181</a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="quicksort-pseudocode">Quicksort Pseudocode</h1>

<p>Now that we&rsquo;ve seen an example of how quicksort works, let&rsquo;s walk through the pseudocode of a quicksort function. The function itself is very simple, as shown below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">function</span> <span class="n">QUICKSORT</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">START</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="c1"># base case size &lt;= 1</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">if</span> <span class="n">START</span> <span class="o">&gt;=</span> <span class="n">END</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">PIVOTINDEX</span> <span class="o">=</span> <span class="n">PARTITION</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">START</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">QUICKSORT</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">START</span><span class="p">,</span> <span class="n">PIVOTINDEX</span> <span class="err">â€“</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">QUICKSORT</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">PIVOTINDEX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>This implementation of quicksort uses a simple base case on lines 3 through 5 to check if the array is either empty, or contains one element. It does so by checking if the <code>START</code> index is greater than or equal to the <code>END</code> index. If so, it can assume the array is sorted and just return it without any additional changes.</p>
<p>The recursive case is shown on lines 6 - 8. It simply uses a helper function called <code>partition</code> on line 6 to partition the array based on a pivot value. That function returns the location of the pivot value, which is stored in <code>pivotIndex</code>. Then, on lines 7 and 8, the quicksort function is called recursively on the two partitions of the array, before and after the <code>pivotIndex</code>. That&rsquo;s really all there is to it!</p>
<p>Let&rsquo;s look at one way we could implement the <code>partition</code> function, shown below in pseudocode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">PARTITION</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">START</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">PIVOTVALUE</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">END</span><span class="p">]</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">PIVOTINDEX</span> <span class="o">=</span> <span class="n">START</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">loop</span> <span class="n">INDEX</span> <span class="kn">from</span> <span class="nn">START</span> <span class="n">to</span> <span class="n">END</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">PIVOTVALUE</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">            <span class="n">TEMP</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="n">ARRAY</span><span class="p">[</span><span class="n">INDEX</span><span class="p">]</span> <span class="o">=</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">PIVOTINDEX</span><span class="p">]</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="n">ARRAY</span><span class="p">[</span><span class="n">PIVOTINDEX</span><span class="p">]</span> <span class="o">=</span> <span class="n">TEMP</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="n">PIVOTINDEX</span> <span class="o">=</span> <span class="n">PIVOTINDEX</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">end</span> <span class="n">loop</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">return</span> <span class="n">PIVOTINDEX</span> <span class="err">â€“</span> <span class="mi">1</span></span></span></code></pre></div>
<p>This function begins on lines 2 and 3 by setting initial values for the <code>pivotValue</code> by choosing the last element in the array, and then setting the <code>pivotIndex</code> to 0. Then, the loop on lines 4 through 11 will look at each element in the array, determine if it is less than or equal to <code>pivotValue</code>, and swap that element with the element at <code>pivotIndex</code> if so, incrementing <code>pivotIndex</code> after each swap.</p>
<p>At the end, the value that was originally at the end of the array will be at location <code>pivotIndex â€“ 1</code>, so we will return that value back to the <code>quicksort</code> function so it can split the array into two parts based on that value.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="quicksort-time-complexity">Quicksort Time Complexity</h1>

<p>To wrap up our analysis of the quicksort algorithm, let&rsquo;s take a look at the time complexity of the algorithm. Quicksort is a very difficult algorithm to analyze, especially since the selection of the pivot value is random and can greatly affect the performance of the algorithm. So, we&rsquo;ll talk about quicksort&rsquo;s time complexity in terms of two cases, the worst case and the average case. Let&rsquo;s look at the average case first</p>
<h2 id="average-case-complexity">Average case complexity</h2>
<p>What would the average case of quicksort look like? This is a difficult question to answer and requires a bit of intuition and making a few assumptions. The key really lies in how we choose our pivot value.</p>
<p>First, let&rsquo;s assume that the data in our array is equally distributed. This means that the values are evenly spread between the lowest value and the highest value, with no large clusters of similar values anywhere. While this may not always be the case in the real world, often we can assume that our data is somewhat equally distributed.</p>
<p>Second, we can also assume that our chosen pivot value is close to the average value in the array. If the array is equally distributed and we choose a value at random, we have a $50\%$ chance of that value being closer to the average than either the minimum or the maximum value, so this is a pretty safe assumption.</p>
<p>With those two assumptions in hand, we see that something interesting happens. If we choose the average value as our pivot value, quicksort will perfectly partition the array into two equal sized halves! This is a great result, because it means that each recursive call to the function will be working with data that is half the initial array.</p>
<p>If we consider an array that initially contains $15$ elements, and make sure that we always choose the average element as our pivot point, we&rsquo;d end up with a tree of recursive calls that resembles the diagram below.</p>
<p><a href="#R-image-968bf2b0bcab3860c15481e5b5745e0b" class="lightbox-link"><img alt="Quicksort Time Tree 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.20.quicktime.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-968bf2b0bcab3860c15481e5b5745e0b"><img alt="Quicksort Time Tree 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.20.quicktime.png"></a></p>
<p>In this diagram, we see that each level of the tree looks at around $N$ elements. (It is actually fewer, but not by a significant amount so we can just round up to $N$ each time). We also notice that there are 4 levels to the tree, which is closely approximated by $\text{lg}(N)$. This is the same result we observed when analyzing the merge sort algorithm earlier in this module.</p>
<p>So, in the average case, we&rsquo;d say that quicksort runs in the order of $N * \text{lg}(N)$ time.</p>
<h2 id="worst-case-complexity">Worst case complexity</h2>
<p>To consider the worst-case situation for quicksort, we must come up with a way to define what the worst-case input would be. It turns out that the selection of our pivot value is the key here.</p>
<p>Consider the situation where the pivot value is chosen to be the maximum value in the array. What would happen in that case?</p>
<p>Looking at the code, we would see that each recursive call would contain one empty partition, and the other partition would be just one less than the size of the original array. So, if our original array only contained 8 elements, our tree recursion diagram would look similar to the following.</p>
<p><a href="#R-image-21c876b1f628259c37f5aecf2ff90e0b" class="lightbox-link"><img alt="Quicksort Time Tree 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.20.quicktime2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-21c876b1f628259c37f5aecf2ff90e0b"><img alt="Quicksort Time Tree 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.20.quicktime2.png"></a></p>
<p>This is an entirely different result! In this case, since we are only reducing the size of our array by 1 at each level, it would take $N$ recursive calls to complete. However, at each level, we are looking at one fewer element. Is this better or worse than the average case?</p>
<p>It turns out that it is much worse. As we learned in our analysis of selection sort and bubble sort, the series</p>
$$
N + (N â€“ 1) + (N â€“ 2) + ... + 2 + 1
$$
<p>is best approximated by $N^2$. So, we would say that quicksort runs in the order of $N^2$ time in the worst case. This is just as slow as selection sort and bubble sort! Why would we ever call it &ldquo;quicksort&rdquo; if it isn&rsquo;t any faster?</p>
<p>Thankfully, in practice, it is very rare to run into this worst-case performance with quicksort, and in fact most research shows that quicksort is often the fastest of the four sorting algorithms we&rsquo;ve discussed so far. In the next section, we&rsquo;ll discuss these performance characteristics a bit more.</p>
<p>This result highlights why it is important to consider both the worst case and average case performance of our algorithms. Many times we&rsquo;ll write an algorithm that runs well most of the time, but is susceptible to poor performance when given a particular worst-case input.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="performance-of-sorting-algorithms">Performance of Sorting Algorithms</h1>

<p>We introduced four sorting algorithms in this chapter: selection sort, bubble sort, merge sort, and quicksort. In addition, we performed a basic analysis of the time complexity of each algorithm. In this section, we&rsquo;ll revisit that topic and compare sorting algorithms based on their performance, helping us understand what algorithm to choose based on the situation.</p>
<h2 id="overall-comparison">Overall Comparison</h2>
<p>The list below shows the overall result of our time complexity analysis for each algorithm.</p>
<ol>
<li>Selection Sort: $N^2$</li>
<li>Bubble Sort: $N^2$</li>
<li>Merge Sort: $N * \text{lg}(N)$</li>
<li>Quicksort Average Case: $N * \text{lg}(N)$</li>
<li>Quicksort Worst Case: $N^2$</li>
</ol>
<p>We have expressed the amount of time each algorithm takes to complete in terms of the size of the original input $N$. But how does $N^2$ compare to $N * \text{lg}(N)$?</p>
<p>One of the easiest ways to compare two functions is to graph them, just like we&rsquo;ve learned to do in our math classes. The diagram below shows a graph containing the functions $N$, $N^2$, and $N * \text{lg}(N)$.</p>
<p><a href="#R-image-54923212868a4056c8943225be834989" class="lightbox-link"><img alt="Graph 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.21.graph.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-54923212868a4056c8943225be834989"><img alt="Graph 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.21.graph.png"></a></p>
<p>First, notice that the scale along the X axis (representing values of $N$) goes from 0 to 10, while the Y axis (representing the function outputs) goes from 0 to 30. This graph has been adjusted a bit to better show the relationship between these functions, but in actuality they have a much steeper slope than is shown here.</p>
<p>As we can see, the value of $N^2$ at any particular place on the X axis is almost always larger than $N * \text{lg}(N)$, while that function&rsquo;s output is almost always larger than $N$ itself. We can infer from this that functions which run in the order of $N^2$ time will take much longer to complete than functions which run in the order of $N * \text{lg}(N)$ time. Likewise, the functions which run in the order of $N * \text{lg}(N)$ time themselves are much slower than functions which run in linear time, or in the order of $N$ time.</p>
<p>Based on that assessment alone, we might conclude that we should always use merge sort! It is guaranteed to run in $N * \text{lg}(N)$ time, with no troublesome worst-case scenarios to consider, right? Unfortunately, as with many things in the real world, it isn&rsquo;t that simple.</p>
<h2 id="choosing-sorting-algorithms">Choosing Sorting Algorithms</h2>
<p>The choice of which sorting algorithm to use in our programs largely comes down to what we know about the data we have, and how that information can impact the performance of the algorithm. This is true for many other algorithms we will write in this class. Many times there are multiple methods to perform a task, such as sorting, and the choice of which method we use largely depends on what we expect our input data to be.</p>
<p>For example, consider the case where our input data is nearly sorted. In that instance, most of the items are in the correct order, but a few of them, maybe less than $10\%$, are slightly out of order. In that case, what if we used a version of bubble sort that was optimized to stop sorting as soon as it makes a pass through the array without swapping any elements? Since only a few elements are out of order, it may only take a few passes with bubble sort to get them back in the correct places. So even though bubble sort runs in $N^2$ time, the actual time may be much quicker.</p>
<p>Likewise, if we know that our data is random and uniformly distributed, we might want to choose quicksort. Even though quicksort has very slow performance in the worst case, if our data is properly random and distributed, research shows that it will have better real-world performance than most other sorting algorithms in that instance.</p>
<p>Finally, what if we know nothing about our input data? In that case, we might want to choose merge sort as the safe bet. It is guaranteed to be no worse than $N * \text{lg}(N)$ time, even if the input is truly bad. While it might not be as fast as quicksort if the input is random, it won&rsquo;t run the risk of being slow, either.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="binary-search">Binary Search</h1>


<a href="https://www.youtube.com/watch?v=D64RE4R2keI">YouTube Video</a>

<p>Now that we&rsquo;ve learned how to sort the data in our container, let&rsquo;s go back and revisit the concept of searching once again. Does our approach change when we know the data has been sorted?</p>
<p>Our intuition tells us that it should. Recall that we discussed how much easier it would be to find a particular paper in a sorted filing cabinet rather than just searching through a random pile of papers on the floor. The same concept applies to data in our programs.</p>
<p>The most commonly used searching algorithm when dealing with sorted data is <em>binary search</em>. The idea of the algorithm is to compare the value in the middle of the container with the value we are looking for. In this case, let&rsquo;s assume the container is sorted in ascending order, so the smaller elements are before the larger ones. If we compare our desired value with the middle value, there are three possible outcomes:</p>
<ol>
<li>the value in the middle is equal to the desired value. We have found the element!</li>
<li>the value in the middle is less than the desired value. Since the container is ordered in ascending order, we must search for the value in the second half of the container.</li>
<li>the value in the middle is greater than the desired value. Since the container is ordered in ascending order, we must search for the value in the first half of the container.</li>
</ol>
<p>Once an occurrence of the desired value is found, we can also look at the values before it to see if there any more of the desired values in the container. Since it is sorted, they should all be grouped together. If we want our algorithm to return the index of the first occurrence of the desired value, we can simply move toward the front of the array until we find that first occurrence.</p>
<h2 id="binary-search-example">Binary Search Example</h2>
<p>Let&rsquo;s work through a quick example of the binary search algorithm to see how it works in practice. Let&rsquo;s assume we have the array shown in the diagram below, which is already sorted in ascending order. We wish to find out if the array contains the value 5. So, we&rsquo;ll store that in our <code>value</code> variable. We also have variables <code>start</code> and <code>end</code> representing the first and last index in the array that we are considering.</p>
<p><a href="#R-image-5055898c3c80884993761474d7e7ffd1" class="lightbox-link"><img alt="Binary Search Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.22.binary1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5055898c3c80884993761474d7e7ffd1"><img alt="Binary Search Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.22.binary1.png"></a></p>
<p>First, we must calculate the middle index of the array. To do that, we can use the following formula.</p>
$$
\text{int}((\text{start} + \text{end}) / 2)
$$
<p>In this case, we&rsquo;ll find that the middle index is 5.</p>
<p><a href="#R-image-c17d847c5f29947bcd3a934977b4da73" class="lightbox-link"><img alt="Binary Search Example 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.22.binary2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c17d847c5f29947bcd3a934977b4da73"><img alt="Binary Search Example 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.22.binary2.png"></a></p>
<p>Next, we&rsquo;ll compare our desired value with the element at the middle index, which is 2. Since our desired value 5 is greater than 2, we know that 5 must be present in the second half of the array. We will then update our starting value to be one greater than the middle element and start over. In practice, this could be done either iteratively or recursively. We&rsquo;ll see both implementations later in this section. The portion of the array we are ignoring has been given a grey background in the diagram below.</p>
<p><a href="#R-image-1d5a3328316c7eeb3953164eedf11627" class="lightbox-link"><img alt="Binary Search Example 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.22.binary3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1d5a3328316c7eeb3953164eedf11627"><img alt="Binary Search Example 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.22.binary3.png"></a></p>
<p>Once again, we&rsquo;ll start by calculating a new middle index. In this case, it will be 8.</p>
<p><a href="#R-image-7c94aea0c4c7230d829da3cfd14e7d89" class="lightbox-link"><img alt="Binary Search Example 4" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.22.binary4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7c94aea0c4c7230d829da3cfd14e7d89"><img alt="Binary Search Example 4" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.22.binary4.png"></a></p>
<p>The value at index 8 is 7, which is greater than our desired value 5. So we know that 5 should be in the first half of the array from index 6 through 10. We need to update the end variable to be one less than middle and try once again.</p>
<p><a href="#R-image-7c6f747a5eb895211b06dec2d35e4f39" class="lightbox-link"><img alt="Binary Search Example 5" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.22.binary5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7c6f747a5eb895211b06dec2d35e4f39"><img alt="Binary Search Example 5" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.22.binary5.png"></a></p>
<p>We&rsquo;ll first calculate the middle index, which will be 6. This is because (6 + 7) / 2 is 6.5, but when we convert it to an integer it will be truncated, resulting in just 6.</p>
<p><a href="#R-image-e28e9bc4a84ef85d52c61f1b2a7a4094" class="lightbox-link"><img alt="Binary Search Example 6" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.22.binary6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e28e9bc4a84ef85d52c61f1b2a7a4094"><img alt="Binary Search Example 6" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.22.binary6.png"></a></p>
<p>Since the value at index 6 is 4, which is less than our desired value 5, we know that we should be looking at the portion of the array which comes after our middle element. Once again, we&rsquo;ll update our start index to be one greater than the middle and start over.</p>
<p><a href="#R-image-6bc857115f5a138a30bdb368ff6b9244" class="lightbox-link"><img alt="Binary Search Example 7" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.22.binary7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6bc857115f5a138a30bdb368ff6b9244"><img alt="Binary Search Example 7" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.22.binary7.png"></a></p>
<p>In this case, since both <code>start</code> and <code>end</code> are the same, we know that the middle index will also be 7.  We can compare the value at index 7 to our desired value. As it turns out, they are a match, so we&rsquo;ve found our value! We can just return <code>middle</code> as the index for this value. Of course, if we want to make sure it is the first instance of our desired value, we can quickly check the elements before it until we find one that isn&rsquo;t our desired value. We won&rsquo;t worry about that for now, but it is something that can easily be added to our code later.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="iterative-binary-search">Iterative Binary Search</h1>

<p>The binary search algorithm is easily implemented in both an iterative and recursive function. We&rsquo;ll look at both versions and see how they compare.</p>
<p>The pseudocode for an iterative version of binary search is shown below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">BINARYSEARCH</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">VALUE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">START</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">END</span> <span class="o">=</span> <span class="n">size</span> <span class="n">of</span> <span class="n">ARRAY</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">loop</span> <span class="k">while</span> <span class="n">START</span> <span class="o">&lt;=</span> <span class="n">END</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">MIDDLE</span> <span class="o">=</span> <span class="n">INT</span><span class="p">((</span><span class="n">START</span> <span class="o">+</span> <span class="n">END</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">MIDDLE</span><span class="p">]</span> <span class="o">==</span> <span class="n">VALUE</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="k">return</span> <span class="n">MIDDLE</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">MIDDLE</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">VALUE</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="n">END</span> <span class="o">=</span> <span class="n">MIDDLE</span> <span class="err">â€“</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">MIDDLE</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">VALUE</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="n">START</span> <span class="o">=</span> <span class="n">MIDDLE</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">end</span> <span class="n">loop</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>This function starts by setting the initial values of <code>start</code> and <code>end</code> on lines 2 and 3 to the first and last indexes in the array, respectively. Then, the loop starting on line 4 will repeat while the <code>start</code> index is less than or equal to the <code>end</code> index. If we reach an instance where <code>start</code> is greater than <code>end</code>, then we have searched the entire array and haven&rsquo;t found our desired value. At that point the loop will end and we will return -1 on line 14.</p>
<p>Inside of the loop, we first calculate the <code>middle</code> index on line 5. Then on line 6 we check to see if the middle element is our desired value. If so, we should just return the <code>middle</code> index and stop. It is important to note that this function will return the index to an instance of <code>value</code> in the array, but it may not be the first instance. If we wanted to find the first instance, we&rsquo;d add a loop at line 7 to move forward in the array until we were sure we were at the first instance of <code>value</code> before returning.</p>
<p>If we didn&rsquo;t find our element, then the if statements on lines 8 and 10 determine which half of the array we should look at. Those statements update either <code>end</code> or <code>start</code> as needed, and then the loop repeats.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="recursive-binary-search">Recursive Binary Search</h1>

<p>The recursive implementation of binary search is very similar to the iterative approach. However, this time we also include both <code>start</code> and <code>end</code> as parameters, which we update at each recursive call. The pseudocode for a recursive binary search is shown below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">function</span> <span class="n">BINARYSEARCHRECURSE</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">VALUE</span><span class="p">,</span> <span class="n">START</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="c1"># base case</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="n">START</span> <span class="o">&gt;</span> <span class="n">END</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">MIDDLE</span> <span class="o">=</span> <span class="n">INT</span><span class="p">((</span><span class="n">START</span> <span class="o">+</span> <span class="n">END</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">MIDDLE</span><span class="p">]</span> <span class="o">==</span> <span class="n">VALUE</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="k">return</span> <span class="n">MIDDLE</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">MIDDLE</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">VALUE</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="k">return</span> <span class="n">BINARYSEARCHRECURSE</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">VALUE</span><span class="p">,</span> <span class="n">START</span><span class="p">,</span> <span class="n">MIDDLE</span> <span class="err">â€“</span> <span class="mi">1</span><span class="p">)</span>	
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">MIDDLE</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">VALUE</span> <span class="n">then</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="k">return</span> <span class="n">BINARYSEARCHRECURSE</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">VALUE</span><span class="p">,</span> <span class="n">MIDDLE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">end</span> <span class="k">if</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">end</span> <span class="n">function</span></span></span></code></pre></div>
<p>The recursive version moves the loop&rsquo;s termination condition to the base case, ensuring that it returns -1 if the <code>start</code> index is greater than the <code>end</code> index. Otherwise, it performs the same process of calculating the <code>middle</code> index and checking to see if it contains the desired <code>value</code>. If not, it uses the recursive calls on lines 10 and 12 to search the first half or second half of the array, whichever is appropriate.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="binary-search-time-complexity">Binary Search Time Complexity</h1>

<p>Analyzing the time complexity of binary search is similar to the analysis done with merge sort. In essence, we must determine how many times it must check the middle element of the array.</p>
<p>In the worst case, it will continue to do this until it has determined that the <code>value</code> is not present in the array at all. Any time that our array doesn&rsquo;t contain our desired value would be our worst-case input.</p>
<p>In that instance, how many times do we look at the middle element in the array? That is hard to measure. However, it might be easier to measure how many elements are in the array each time and go from there.</p>
<p>Consider the situation where we start with 15 elements in the array. How many times can we divide the array in half before we are down to just a single element? The diagram below shows what this might look like.</p>
<p><a href="#R-image-2880fc3962f6fbb104ea212b9ffaf8cd" class="lightbox-link"><img alt="Binary Search Time Complexity" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.25.binarytime.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2880fc3962f6fbb104ea212b9ffaf8cd"><img alt="Binary Search Time Complexity" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.25.binarytime.png"></a></p>
<p>As it turns out, this is similar to the analysis we did on merge sort and quick sort. If we divide the array in half each time, we will do this $\text{lg}(N)$ times. The only difference is that we are only looking at a single element, the shaded element, at each level. So the overall time complexity of binary search is on the order of $\text{lg}(N)$. That&rsquo;s pretty fast!</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="the-importance-of-sorting">The Importance of Sorting</h1>


<a href="https://www.youtube.com/watch?v=09ziwYSD1vc">YouTube Video</a>

<p>Let&rsquo;s go back and look at the performance of our sorting algorithms, now that we know how quickly binary search can find a particular value in an array. Let&rsquo;s add the function $\text{lg}(N)$ to our graph from earlier, shown below.</p>
<p><a href="#R-image-023b1e4d81a0e97722d4fc984a2958a0" class="lightbox-link"><img alt="Graph 2" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.26.graph2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-023b1e4d81a0e97722d4fc984a2958a0"><img alt="Graph 2" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.26.graph2.png"></a></p>
<p>As we can see, the function $\text{lg}(N)$ is even smaller than $N$. So performing a binary search is much faster than a linear search, which we already know runs in the order of $N$ time.</p>
<p>However, performing a single linear search is still faster than any of the sorting algorithms we&rsquo;ve reviewed. So when does it become advantageous to sort our data?</p>
<p>This is a difficult question to answer since it depends on many factors. However, a good rule of thumb is to remember that the larger the data set, or the more times we need to search for a value, the better off we are to sort the data before we search.</p>
<p>In the graph below, the topmost line colored in red shows the approximate running time of $10$ linear search operations, while the bottom line in black shows the running time of performing a merge sort before $10$ binary search operations.</p>
<p><a href="#R-image-acdaa347e047646f8608b7c3cba20d6d" class="lightbox-link"><img alt="Graph 3" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/7/7.26.graph3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-acdaa347e047646f8608b7c3cba20d6d"><img alt="Graph 3" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/7/7.26.graph3.png"></a></p>
<p>As we can see, it is more efficient to perform a merge sort, which runs in $N * \text{lg}(N)$ time, then perform $10$ binary searches running in $\text{lg}(N)$ time, than it is to perform $10$ linear searches running in $N$ time. The savings become more pronounced as the size of the input gets larger, as indicated by the X axis on the graph.</p>
<p>In fact, this analysis suggests that it may only take as few as 7 searches to see this benefit, even on smaller data sets. So, if we are writing a program that needs to search for a specific value in an array more than about 7 times, it is probably a good idea to sort the array before doing our searches, at least from a performance standpoint.</p>

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Faster Sorting</div>
  <div class="box-content">

<p>So far we&rsquo;ve looked at sorting algorithms that run in $N * \text{lg}(N)$ time. However, what if we try to sort the data as we add it to the array? In a later course, we&rsquo;ll learn how we can use an advanced data structure known as a <em>heap</em> to create a sorted array in nearly linear time (with some important caveats, of course)!</p>
</div>
</div>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="searching--sorting-summary">Searching &amp; Sorting Summary</h1>

<p>In this chapter, we learned how to search for values in an array using a linear search method. Then, we explored four different sorting algorithms, and compared them based on their time complexity. Finally, we learned how we can use a sorted array to perform a faster binary search and saw how we can increase our performance by sorting our array before searching in certain situations.</p>
<p>Searching and sorting are two of the most common operations performed in computer programs, and it is very important to have a deep understanding of how they work. Many times the performance of a program can be improved simply by using the correct searching and sorting algorithms to fit the program&rsquo;s needs, and understanding when you might run into a particularly bad worst-case input.</p>
<p>The project in this module will involve implementing several of these algorithms in the language of your choice. As we learn about more data structures, we&rsquo;ll revisit these algorithms again to discuss how they can be improved or adapted to take advantage of different structures.</p>
<h2 id="references">References</h2>
<p>Mergesort iterative without a stack</p>
<ul>
<li><a href="https://www.geeksforgeeks.org/iterative-merge-sort/" rel="external" target="_blank">https://www.geeksforgeeks.org/iterative-merge-sort/</a></li>
<li><a href="https://www.techiedelight.com/iterative-merge-sort-algorithm-bottom-up/" rel="external" target="_blank">https://www.techiedelight.com/iterative-merge-sort-algorithm-bottom-up/</a></li>
</ul>
<p>Quicksort iterative with a stack</p>
<ul>
<li><a href="https://www.geeksforgeeks.org/iterative-quick-sort/" rel="external" target="_blank">https://www.geeksforgeeks.org/iterative-quick-sort/</a></li>
</ul>
<p>Bubble sort recursive</p>
<ul>
<li>Giordano, D., &amp; Maiorana, F. (2015, March). Teaching algorithms: Visual language vs flowchart vs textual language. In 2015 IEEE Global Engineering Education Conference (EDUCON) (pp. 499-504). IEEE.</li>
</ul>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc310/commit/b806b39e06b3286e793d1e17e7c90e68a994e4ce">Jul 3, 2024</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc310/js/clipboard.min.js?1720021866" defer></script>
    <script src="/cc310/js/perfect-scrollbar.min.js?1720021866" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cc310/js/mathjax/tex-mml-chtml.js?1720021866"></script>
    <script src="/cc310/js/theme.js?1720021866" defer></script>
  </body>
</html>
