




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="Old Content">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Old Conetnt :: CC 310 Textbook">
    <meta name="twitter:description" content="Old Content">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/09-trees/old/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Old Conetnt :: CC 310 Textbook">
    <meta property="og:description" content="Old Content">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Old Conetnt :: CC 310 Textbook">
    <meta itemprop="description" content="Old Content">
    <meta itemprop="dateModified" content="2024-07-01T16:38:34-05:00">
    <meta itemprop="wordCount" content="2">
    <title>Old Conetnt :: CC 310 Textbook</title>
    <link href="/cc310/css/fontawesome-all.min.css?1719877281" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1719877281" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1719877281" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1719877281" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1719877281" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1719877281" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1719877281" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1719877281" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1719877281" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1719877281" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1719877281" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1719877281" rel="stylesheet">
    <link href="/cc310/css/print.css?1719877281" rel="stylesheet" media="print">
    <link href="/cc310/css/format-print.css?1719877281" rel="stylesheet">
    <script src="/cc310/js/variant.js?1719877281"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1719877281" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc310/09-trees/old/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="/cc310/09-trees/"><span itemprop="name">Trees</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Old Conetnt</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/09-trees/13-summary/" title="Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/09-trees/old/1-tries/" title="Tries (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="old-conetnt">Old Conetnt</h1>

<p>Old Content</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Old Conetnt</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="tries">Tries</h1>


<a href="https://www.youtube.com/watch?v=BNA3tbURiZk">YouTube Video</a>

<p>Recall that in the beginning of our discussions about trees, we looked at a small tree which contained seven strings as motivation for trees. This was a small example of a trie (pronounced &rsquo;try&rsquo;) which is a type of tree that can represent sets of words.
<a href="#R-image-a71aba3e192444835233a9e78626600b" class="lightbox-link"><img alt="Trie Small Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/2Tree_SmallWords.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a71aba3e192444835233a9e78626600b"><img alt="Trie Small Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/2Tree_SmallWords.png"></a></p>
<p>Tries can be used for a variety of tasks ranging from leisurely games to accessibility applications. One example is &lsquo;Boggle&rsquo; where players have a set of random letters and try to make as many words as possible. To code this game, we could create a vocabulary with a trie then traverse it to determine if players have played legal words. We can also use tries to provide better typing accessibility. Users could type a few letters of a word and our code could traverse the trie and suggest what letters or words they may be trying to enter.</p>
<p>A trie is a type of tree with some special characteristics. First it must follow the guidelines of being a tree:</p>
<ul>
<li>There must be a single root,</li>
<li>Each child node has a single parent node,</li>
<li>It must be fully connected (no disjoint parts), and</li>
<li>There can be no cycles (no loops).</li>
</ul>
<p>The special characteristics for tries are:</p>
<ul>
<li>By starting at the root and traversing parent to children relationships we can build user-defined words, and</li>
<li>Each node has a boolean property to indicate if it is the end of a word.</li>
</ul>
<p>In this course, we will display nodes with two circles as a convention to show which nodes are the end of words. Looking at this small trie as an example, we can determine which words are contained in our trie.
<a href="#R-image-3e8727827d3fbee1c6a1245030570031" class="lightbox-link"><img alt="Trie Small Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/2Tree_SmallWords.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3e8727827d3fbee1c6a1245030570031"><img alt="Trie Small Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/2Tree_SmallWords.png"></a>
We start at the root, which will typically be an empty string, and traverse to a double lined node. <code>&quot;&quot; -&gt; a -&gt; l -&gt; l</code>. Thus, the word &lsquo;all&rsquo; is contained in our trie. Words within our tries do not have to end at leaves. For example, we can traverse <code>&quot;&quot; -&gt; a</code> for the word &lsquo;a&rsquo;. We say this trie &lsquo;contains&rsquo; seven words: &lsquo;a&rsquo;, &lsquo;an&rsquo;, &lsquo;and&rsquo;, &lsquo;ant&rsquo;, &lsquo;any&rsquo;, &lsquo;all&rsquo;, and &lsquo;alp&rsquo;.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="trie-example">Trie Example</h1>

<p>Let&rsquo;s look at another example of a trie. Here we have a larger trie. Think about how many words are captured by the tree; click the tree to see how many!

<div class="expand">
    <input type="checkbox" id="R-expand-763c794dca3e5e56d1dcfed8565a97e9" aria-controls="R-expandcontent-763c794dca3e5e56d1dcfed8565a97e9" >
    <label class="expand-label" for="R-expand-763c794dca3e5e56d1dcfed8565a97e9" >
        <i class="fa-fw fas fa-chevron-down"></i>
        <i class="fa-fw fas fa-chevron-right"></i>
        <a href="#R-image-5daf5c5cdd22e46fc9eeab0f31a42273" class="lightbox-link"><img alt="Trie Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/4Trie_Example.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5daf5c5cdd22e46fc9eeab0f31a42273"><img alt="Trie Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/4Trie_Example.png"></a>
    </label>
    <div id="R-expandcontent-763c794dca3e5e56d1dcfed8565a97e9" class="expand-content">
<p>
This tree contains <strong>12</strong> words: &lsquo;ate&rsquo;, &lsquo;an&rsquo;, &lsquo;and&rsquo;, &lsquo;ant&rsquo;, &lsquo;app&rsquo;, &lsquo;apple&rsquo;, &lsquo;cat&rsquo;, &lsquo;can&rsquo;, &lsquo;cup&rsquo;, &lsquo;by&rsquo;, &lsquo;be&rsquo;, and &lsquo;been&rsquo;.</div>
</div></p>
<p>While the &lsquo;a&rsquo;, &lsquo;at&rsquo;, and &lsquo;bee&rsquo; are words in the English language, they are not recognized by our trie. Depending on what the user intended, this could be by design. When we build our tries, users will input words that are valid for their vocabulary. Tries are not limited to the English language and can be created for any vocabulary.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytrie-i">MyTrie I</h1>

<p>To implement our own trie, we will build off of MyTree that we built recursively. We will add an attribute to our tree to reinforce which nodes are words and which ones are not.</p>
<p><a href="#R-image-4465b68441def7d8f61486eac1d2cc4f" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/trie_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4465b68441def7d8f61486eac1d2cc4f"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/trie_uml.png"></a></p>
<h3 id="attributes">Attributes</h3>
<p>We have the existing attributes of MyTree: parent, children, and item. For MyTrie, we introduce the boolean attribute <code>is_word</code> to delineate if our trie is a word.</p>
<h3 id="adding-a-word">Adding a Word</h3>

<a href="https://www.youtube.com/watch?v=kasaXiMbj9A">YouTube Video</a>

<p>To add a word to our trie, we traverse through the trie letter by letter. We can define this recursively.</p>
<ul>
<li>Base Case: length of the word is zero and it was already a word in our trie, return false (because we did not add the word) OR length of the word is zero and it is not already a word in our trie, set the boolean for the node at the end of the word to true and return true</li>
<li>Recursive case: split the string into the first character and the rest. Get the node of the first letter of the string; if it does not exist create it, then run the add word function on the remainder of the string.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDWORD(WORD)
</span></span><span class="line"><span class="cl">    if WORD length is 0
</span></span><span class="line"><span class="cl">        if already a word
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            set is<span class="nb">_</span>word to true
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">        if CHILD is NONE
</span></span><span class="line"><span class="cl">            NODE = new MyTrie with item equal FIRST
</span></span><span class="line"><span class="cl">            insert NODE into our existing trie 
</span></span><span class="line"><span class="cl">            CHILD = NODE
</span></span><span class="line"><span class="cl">        return CHILD.ADDWORD(REMAIN)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h3 id="removing-a-word">Removing a Word</h3>

<a href="https://www.youtube.com/watch?v=ZcrqD8nlLjc">YouTube Video</a>

<p>Similar to adding a word, we traverse our trie letter by letter. Once we get to the end of the word set <code>is_word</code> to false. If the word ends at a leaf, we will remove the leaf (then if the second to last character is a leaf, we remove the leaf and so on). If the word does not end in a leaf, meaning another word uses that node, we will not remove the node.</p>
<ul>
<li>Base Case: length of the word is zero and it was not a word in our trie, return false (because we did not remove the word) OR length of the word is zero and it is  already a word in our trie, set the boolean for the node at the end of the word to false and return true</li>
<li>Recursive case: split the string into the first character and the rest. Get the node of the first letter of the string, if that node does not exist, return false (because we did not remove the word). If the node does exist run remove word on the child for the remainder of the word. After that, if the node&rsquo;s <code>is_word</code> is false and it is a leaf, remove the node.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEWORD(WORD)
</span></span><span class="line"><span class="cl">    if WORD length is 0
</span></span><span class="line"><span class="cl">        if already not a word
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            set is<span class="nb">_</span>word to false
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">        if CHILD is NONE
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            RET = CHILD.REMOVEWORD(REMAIN)
</span></span><span class="line"><span class="cl">            if CHILD is not a word AND CHILD is a leaf
</span></span><span class="line"><span class="cl">                REMOVECHILD(CHILD)
</span></span><span class="line"><span class="cl">            return RET
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h3 id="check-if-trie-contains-word">Check if trie contains word</h3>

<a href="https://www.youtube.com/watch?v=zG1aSR1iivI">YouTube Video</a>

<p>Again, we will traverse the trie letter by letter. Once we get to the last letter, we can return that nodes <code>is_word</code> attribute. There is a chance that somewhere in our word, the letter is not a child of the previous node. If that is the case, then we return false.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function CONTAINSWORD(WORD)
</span></span><span class="line"><span class="cl">    if WORD length is 0
</span></span><span class="line"><span class="cl">        return `is<span class="nb">_</span>word`
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">        if CHILD is NONE
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return CHILD.CONTAINSWORD(REMAIN)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="recursion-refresh">Recursion Refresh</h1>


<a href="https://www.youtube.com/watch?v=7ee0C0v2L1w">YouTube Video</a>

<p><a href="#R-image-733c7ffb785d6803ba916cb4b193ee9d" class="lightbox-link"><img alt="Subtrees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/2Tree_SubTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-733c7ffb785d6803ba916cb4b193ee9d"><img alt="Subtrees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/2Tree_SubTree.png"></a></p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>A recursive program is broken into two parts:</p>
<ul>
<li>A <strong>base case</strong>&mdash;a simple version of the problem that can be solved directly, and</li>
<li>A <strong>recursive case</strong>&mdash;a general solution to the problem that uses smaller versions of the problem to compute the solution to the larger problem.</li>
</ul>
</div>
</div>
<p>In principle, the recursive case breaks the problem down into smaller portions until we reach the base case. Recursion presents itself in many ways when dealing with trees.</p>
<p>Trees are defined recursively with the base case being a single node. Then we recursively build the tree up. With this basis for our trees, we can define many properties using recursion rather effectively.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytrie-ii">MyTrie II</h1>

<h3 id="getters">Getters</h3>

<a href="https://www.youtube.com/watch?v=su-hJ1CDY3M">YouTube Video</a>

<h4 id="getting-word-count">Getting word count</h4>
<p>For this function, we want to get the total number of words that are contained within our trie. We will fan out through all of the children and count all of the nodes that have their <code>is_word</code> attribute equal to true.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function WORDCOUNT()
</span></span><span class="line"><span class="cl">    COUNT = 0
</span></span><span class="line"><span class="cl">    if is<span class="nb">_</span>word
</span></span><span class="line"><span class="cl">        COUNT = 1
</span></span><span class="line"><span class="cl">    for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">        COUNT += CHILD.WORDCOUNT()
</span></span><span class="line"><span class="cl">    return COUNT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h4 id="get-max-word-length">Get max word length</h4>
<p>Next, we want to get the longest word contained in our trie. To do this, we will recurse each child and find the maximum length of the child.</p>
<ul>
<li>Base Case: we are at a leaf and it is a word, return 0</li>
<li>Recursive Case: declare a maximum of -1 for a tracker and then for each child run the maximum word length function on it. If the value returned from the child is greater than our maximum tracker, set the tracker equal to the value. Once we have iterated all of the children, return the maximum tracker plus one.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function MAXWORD()
</span></span><span class="line"><span class="cl">    if LEAF and is<span class="nb">_</span>word
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        MAX = -1
</span></span><span class="line"><span class="cl">        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">            COUNT = CHILD.MAXWORD()
</span></span><span class="line"><span class="cl">            if COUNT greater than MAX
</span></span><span class="line"><span class="cl">                MAX = COUNT
</span></span><span class="line"><span class="cl">        return MAX + 1
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h4 id="get-completions">Get completions</h4>

<a href="https://www.youtube.com/watch?v=urFTpJwqRVY">YouTube Video</a>

<p>This function will act as an auto-complete utility of sorts. A user will input a string of characters and we will return all of the possible words that are contained in our trie. This will happen in two phases. First, we traverse the trie to get to the end of the input string (lines 1-12). The second portion then gets all of the words that are contained after that point in our trie (lines 14-21).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function COMPLETIONS(WORD)
</span></span><span class="line"><span class="cl">1.    if WORD length greater than 0
</span></span><span class="line"><span class="cl">2.        FIRST = first character of WORD
</span></span><span class="line"><span class="cl">3.        REMAIN = remainder of WORD
</span></span><span class="line"><span class="cl">4.        CHILD = FINDCHILD(FIRST)
</span></span><span class="line"><span class="cl">5.        if CHILD is none
</span></span><span class="line"><span class="cl">6.            return []
</span></span><span class="line"><span class="cl">7.        else
</span></span><span class="line"><span class="cl">8.            COMPLETES = CHILD.COMPLETIONS(REMAIN)
</span></span><span class="line"><span class="cl">9.            OUTPUT = []
</span></span><span class="line"><span class="cl">10.            for COM in COMPLETES
</span></span><span class="line"><span class="cl">11.                append CHILD.item + COM to OUTPUT
</span></span><span class="line"><span class="cl">12.            return OUTPUT
</span></span><span class="line"><span class="cl">13.    else
</span></span><span class="line"><span class="cl">14.        OUTPUT = []
</span></span><span class="line"><span class="cl">15.        if is<span class="nb">_</span>word
</span></span><span class="line"><span class="cl">16.            append ITEM to OUTPUT
</span></span><span class="line"><span class="cl">17.        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">18.            COMPLETES = CHILD.COMPLETIONS(&#34;&#34;)
</span></span><span class="line"><span class="cl">19.            for COM in COMPLETES
</span></span><span class="line"><span class="cl">20.                append CHILD.item + COM to OUTPUT
</span></span><span class="line"><span class="cl">21.        reutrn OUTPUT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mybinarytree">MyBinaryTree</h1>


<a href="https://www.youtube.com/watch?v=0U5EXtcHcsU">YouTube Video</a>

<p>Our implementation of binary trees will inherit from our MyTree implementation as binary trees are types of trees. Thus, MyBinaryTree will have the functionality of MyTree in addition to the following.</p>
<p><a href="#R-image-f3b0f2c3ed697e99a4786cce18119dea" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/binary_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f3b0f2c3ed697e99a4786cce18119dea"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/binary_uml.png"></a></p>
<h2 id="attributes">Attributes</h2>
<p>The binary tree has two attributes</p>
<ul>
<li>Left Child: an instance of <code>MyBinaryTree</code>, the item should be less than the item of the parent.</li>
<li>Right Child: an instance of <code>MyBinaryTree</code>, the item should be greater than the item of the parent.</li>
</ul>
<h2 id="miscellaneous-functions">Miscellaneous Functions</h2>
<ul>
<li>
<p>Get Size</p>
<ul>
<li>Will override the <code>MyTree</code> size function. If the tree is empty then we return zero. If the tree is not empty then call the <code>MyTree</code> size function.</li>
</ul>
</li>
<li>
<p>Is Empty</p>
<ul>
<li>Will return true if the node we have called the function from is empty and false if otherwise.</li>
</ul>
</li>
<li>
<p>To Sorted List</p>
<ul>
<li>Will get all of the nodes items and sort them</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function TOSORTEDLIST()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    if there`s LEFTCHILD
</span></span><span class="line"><span class="cl">        LIST = LIST + LEFTCHILD.TOSORTEDLIST
</span></span><span class="line"><span class="cl">    LIST = LIST + ITEM
</span></span><span class="line"><span class="cl">    if there`s RIGHTCHILD
</span></span><span class="line"><span class="cl">        LIST = LIST + RIGHTCHILD.TOSORTEDLIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="inserting-children">Inserting Children</h1>


<a href="https://www.youtube.com/watch?v=qFalue24DdE">YouTube Video</a>

<p>When inserting children to a binary tree, we must take some special considerations. All of the node items in the left tree must be less than the parent node item and all of the node items in the right tree must be greater than the parent node item.</p>
<p>The general procedure for adding a child is the following:
<a href="#R-image-664b138a8fce5f68bf2f547797e5de9c" class="lightbox-link"><img alt="Binary Tree Flowchart" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/4Binary_AddFlowChart.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-664b138a8fce5f68bf2f547797e5de9c"><img alt="Binary Tree Flowchart" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/4Binary_AddFlowChart.png"></a></p>
<p>Suppose that we have the following tree and we want to add a node with item &lsquo;85&rsquo;. Click the binary tree to see the resulting tree.</p>

<div class="expand">
    <input type="checkbox" id="R-expand-9350dc9d86fc880fb90c649876c5d45e" aria-controls="R-expandcontent-9350dc9d86fc880fb90c649876c5d45e" >
    <label class="expand-label" for="R-expand-9350dc9d86fc880fb90c649876c5d45e" >
        <i class="fa-fw fas fa-chevron-down"></i>
        <i class="fa-fw fas fa-chevron-right"></i>
        <a href="#R-image-42890f43df59b6579f09f09d10510471" class="lightbox-link"><img alt="Tree To Add To" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/4Binary_Add.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-42890f43df59b6579f09f09d10510471"><img alt="Tree To Add To" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/4Binary_Add.png"></a>
    </label>
    <div id="R-expandcontent-9350dc9d86fc880fb90c649876c5d45e" class="expand-content">

<p><a href="#R-image-83c74d3398bcc0c8403c005b28fbf0aa" class="lightbox-link"><img alt="Tree Adding" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/4Binary_AddChild.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-83c74d3398bcc0c8403c005b28fbf0aa"><img alt="Tree Adding" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/4Binary_AddChild.gif"></a></p>
</div>
</div>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function INSERT(VALUE)
</span></span><span class="line"><span class="cl">    if node is empty:
</span></span><span class="line"><span class="cl">        set nodes item to value
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        if node.ITEM is VALUE
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        else if node.ITEM &gt; VALUE 
</span></span><span class="line"><span class="cl">            LC = node`s left child
</span></span><span class="line"><span class="cl">            if LC is NONE
</span></span><span class="line"><span class="cl">                CHILD = new BINARYTREE with root.ITEM equal VALUE
</span></span><span class="line"><span class="cl">                add CHILD to nodes children
</span></span><span class="line"><span class="cl">                set node.LEFTCHILD equal to CHILD
</span></span><span class="line"><span class="cl">                return true
</span></span><span class="line"><span class="cl">            else
</span></span><span class="line"><span class="cl">                return LC.INSERT(VALUE)
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            RC = node`s right child
</span></span><span class="line"><span class="cl">            if RC is NONE
</span></span><span class="line"><span class="cl">                CHILD = new BINARYTREE with root.ITEM equal VALUE
</span></span><span class="line"><span class="cl">                add CHILD to nodes children
</span></span><span class="line"><span class="cl">                set node.RIGHTCHILD equal to CHILD
</span></span><span class="line"><span class="cl">                return true
</span></span><span class="line"><span class="cl">            else
</span></span><span class="line"><span class="cl">                return RC.INSERT(VALUE)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-recursive-i">MyTree Recursive I</h1>

<p>Again, we want to be able to implement a working version of a tree. From the last module, we had functions to add children, remove children, get attributes, and instantiate MyTree. We will now build upon that implementation to create a true tree.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>A recursive program is broken into two parts:</p>
<ul>
<li>A <strong>base case</strong>&mdash;a simple version of the problem that can be solved directly, and</li>
<li>A <strong>recursive case</strong>&mdash;a general solution to the problem that uses smaller versions of the problem to compute the solution to the larger problem.</li>
</ul>
</div>
</div>
<hr>
<h3 id="mytree-with-recursion">MyTree with recursion</h3>
<p>Recall that in the previous module, we were not yet able to enforce the no cycle rule. We will now enforce this and add other tree functionality.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p><strong>Disclaimer:</strong> In the previous module we had a disclaimer that stated our implementation would not prevent cycles. The following functions and properties will implement recursion. Thus, we can maintain legal tree structures!</p>
</div>
</div>
<p>In the first module, we discussed how we can define trees recursively, meaning a tree consists of trees. We looked at the following example. Each red dashed line represented a distinct tree, thus we had five trees within the largest tree making six trees in total.
<a href="#R-image-2e51ac04d8bd016bb65056bd6723a6cb" class="lightbox-link"><img alt="Subtrees" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/2Tree_SubTree.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2e51ac04d8bd016bb65056bd6723a6cb"><img alt="Subtrees" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/2Tree_SubTree.png"></a></p>
<p>We will use our existing implementation from the first module. Now to make our tree recursive, we will include more getter functions as well as functions for traversals and defining node relationships.</p>
<p><a href="#R-image-fdcc9e4877ceed4008eeaff5da2f9bcd" class="lightbox-link"><img alt="UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/rec_tree_uml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fdcc9e4877ceed4008eeaff5da2f9bcd"><img alt="UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/rec_tree_uml.png"></a></p>
<hr>
<h3 id="get-depth-height-size-and-root">Get depth, height, size, and root</h3>
<p>We can define each of these recursively.</p>

<a href="https://www.youtube.com/watch?v=3mFKHgv6bhk">YouTube Video</a>

<h5 id="get-depth">Get Depth</h5>
<ul>
<li><code>Depth</code> - The depth of a node is its distance to the root. Thus, the root has depth zero.</li>
</ul>
<p>We can define the depth of a node recursively:</p>
<ul>
<li>Base case: we are at the root and the depth is zero</li>
<li>Recursive case: for any other node, the depth is 1 plus the depth of the parent</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETDEPTH()
</span></span><span class="line"><span class="cl">    if ROOT
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        return 1 + PARENT.GETDEPTH()
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="get-height">Get Height</h5>
<ul>
<li><code>Height of a Node</code> - The height of a node is the <strong>longest</strong> path to a leaf descendant. The height of a leaf is zero.</li>
</ul>
<p>We can define the height of a node recursively:</p>
<ul>
<li>Base case: we are at the leaf and the height is zero</li>
<li>Recursive case: for any other node, return 1 plus the maximum height of its children</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETHEIGHT()
</span></span><span class="line"><span class="cl">    if LEAF
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        MAX = 0
</span></span><span class="line"><span class="cl">        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">            CURR<span class="nb">_</span>HEIGHT = CHILD.GETHEIGHT()
</span></span><span class="line"><span class="cl">            if CURR<span class="nb">_</span>HEIGHT &gt; MAX
</span></span><span class="line"><span class="cl">                MAX = CURR<span class="nb">_</span>HEIGHT
</span></span><span class="line"><span class="cl">        return 1 + MAX
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="get-root">Get Root</h5>
<ul>
<li><code>Root</code> - the topmost node of the tree; a node with no parent.</li>
</ul>
<p>We can define returning the root recursively:</p>
<ul>
<li>Base case: we are at the root so return it</li>
<li>Recursive case: for any other node, return the root of the nodes parent</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETROOT()
</span></span><span class="line"><span class="cl">    if ISROOT()
</span></span><span class="line"><span class="cl">        return this tree
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return PARENT.GETROOT()
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="get-size">Get Size</h5>
<p>We define the size of a tree as the total number of children.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETSIZE()
</span></span><span class="line"><span class="cl">    SIZE = 1
</span></span><span class="line"><span class="cl">    for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">        SIZE += CHILD.GETSIZE()
</span></span><span class="line"><span class="cl">    return SIZE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h4 id="find-a-value">Find a Value</h4>
<p>To find a value within our tree, we will traverse down a branch as far as we can until we find the value. This will return the tree that has the value as the root.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function FIND(VALUE)
</span></span><span class="line"><span class="cl">	if ITEM is VALUE
</span></span><span class="line"><span class="cl">		return this node
</span></span><span class="line"><span class="cl">	for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">		FOUND = CHILD.FIND(VALUE)
</span></span><span class="line"><span class="cl">		if FOUND is not NONE
</span></span><span class="line"><span class="cl">			return FOUND
</span></span><span class="line"><span class="cl">	return NONE
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-recursive-ii">MyTree Recursive II</h1>

<h3 id="determine-relationships-ancestor-descendant-sibling">Determine relationships (Ancestor, Descendant, Sibling)</h3>
<p>We can determine many relationships within the tree. For example, given a node is it an ancestor of another node, a descendant, or a sibling?</p>

<a href="https://www.youtube.com/watch?v=hr73fsl8RzM">YouTube Video</a>

<h5 id="is-ancestor">Is Ancestor?</h5>
<p>For this function, we are asking: is this node an ancestor of the current instance? In this implementation, we will start at our instance and <strong>work down</strong> through the tree trying to find the node in question. With that in mind, we can define this process recursively:</p>
<ul>
<li>Base case: we are at the node in question, so return true OR we are at a leaf so return false.</li>
<li>Recursive case: run the method from each of the children of the node.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISANCESTOR(TREE)
</span></span><span class="line"><span class="cl">    if at TREE
</span></span><span class="line"><span class="cl">        return true
</span></span><span class="line"><span class="cl">    else if at LEAF
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        for CHILD in CHILDREN
</span></span><span class="line"><span class="cl">            FOUND = CHILD.ISANCESTOR(TREE)
</span></span><span class="line"><span class="cl">            if FOUND
</span></span><span class="line"><span class="cl">                return true
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="is-descendant">Is Descendant?</h5>
<p>For this function, we are asking: is this node a descendant of the current instance? In this implementation, we will start at our instance and <strong>work up</strong> through the tree trying to find the node in question. With that in mind, we can define this process recursively:</p>
<ul>
<li>Base case: we are at the node in question, so return true OR we are at the root so return false.</li>
<li>Recursive case: run the method from the parent of the node.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISDESCENDANT(TREE)
</span></span><span class="line"><span class="cl">    if at TREE
</span></span><span class="line"><span class="cl">        return true
</span></span><span class="line"><span class="cl">    else if at ROOT
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        return PARENT.ISDESCENDANT(TREE)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="is-sibling">Is Sibling?</h5>
<p>For this function, we are asking: is this node a sibling of the current instance? To determine this, we can get the parent of the current instance and then get the parents children. Finally, we check if the node in question is in that set of children.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ISSIBLING(TREE)
</span></span><span class="line"><span class="cl">    if TREE in PARENT&#39;s CHILDREN
</span></span><span class="line"><span class="cl">        return true
</span></span><span class="line"><span class="cl">    else 
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><hr>
<h3 id="lowest-common-ancestor">Lowest common ancestor</h3>
<p>In any tree, we can say that the root is a common ancestor to all of the nodes. We would like to get more information about the common ancestry of two nodes. For this function, we are asking: which node is the first place where this instance and the input node&rsquo;s ancestries meet? Similar to our ISDESCENDANT, we will work our way up the tree to find the point where they meet</p>
<ul>
<li>Base case: we are at our tree so return the tree OR we are at an ancestor of our tree so return the instance OR we are at the root so return nothing</li>
<li>Recursive case: run the method from the parent.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function LOWESTANCESTOR(TREE)
</span></span><span class="line"><span class="cl">    if at TREE
</span></span><span class="line"><span class="cl">        return TREE
</span></span><span class="line"><span class="cl">    else if ISANCESTOR(TREE)
</span></span><span class="line"><span class="cl">        return instance
</span></span><span class="line"><span class="cl">    else if at ROOT
</span></span><span class="line"><span class="cl">        return NONE
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return PARENT.LOWESTANCESTOR(TREE)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><hr>
<h3 id="path-from-the-root">Path from the root</h3>
<p>This function will generate the path which goes from the root to the current instance.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PATHFROMROOT(PATH)
</span></span><span class="line"><span class="cl">    if NOT ROOT
</span></span><span class="line"><span class="cl">        PARENT.PATHFROMROOT(PATH)
</span></span><span class="line"><span class="cl">    append ITEM to PATH
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="removing-children">Removing Children</h1>


<a href="https://www.youtube.com/watch?v=uyhC6GcyBW4">YouTube Video</a>

<p>Removing children is not as straightforward as inserting them. The general procedure for removing a child is to replace that nodes value with its smallest right descendant. First we will traverse the binary tree until we find the node with the value we are trying to remove (lines 18-32 below). Then we have three separate cases, discussed in detail below.</p>
<h2 id="removing-a-leaf">Removing a Leaf</h2>
<p>Removing a leaf is the most straightforward. We remove the value from the node and then sever the connection between parent and child. (lines 5-7 below)</p>
<p>Suppose we have this binary tree and we want to remove value <code>5</code>. What do you think the resulting binary tree will look like? Click the binary tree to see the result.</p>

<div class="expand">
    <input type="checkbox" id="R-expand-7e1c118b04b0e45be57f590204af5df8" aria-controls="R-expandcontent-7e1c118b04b0e45be57f590204af5df8" >
    <label class="expand-label" for="R-expand-7e1c118b04b0e45be57f590204af5df8" >
        <i class="fa-fw fas fa-chevron-down"></i>
        <i class="fa-fw fas fa-chevron-right"></i>
        <a href="#R-image-ee651bc22bb09fba12c6cb6479fb996e" class="lightbox-link"><img alt="Tree to Remove Leaf" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/4Bin_Remove.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ee651bc22bb09fba12c6cb6479fb996e"><img alt="Tree to Remove Leaf" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/4Bin_Remove.png"></a>
    </label>
    <div id="R-expandcontent-7e1c118b04b0e45be57f590204af5df8" class="expand-content">

<p><a href="#R-image-4d0e1b7e84a366cf61603433dc1dcaff" class="lightbox-link"><img alt="Result of Remove Leaf" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/4Bin_Remove2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4d0e1b7e84a366cf61603433dc1dcaff"><img alt="Result of Remove Leaf" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/4Bin_Remove2.png"></a></p>
</div>
</div>
<h2 id="removing-a-node-without-right-child">Removing a Node without Right Child</h2>
<p>When we remove a value from a node that does not have a right child, we cannot replace the value with the smallest right child. In this instance we will instead replace the value with the smallest left child then prune the tree to clean it up. Once we replace the value, we must switch the node&rsquo;s left child to be the right child in order to maintain proper binary tree structure. (lines 8-13 below)</p>
<p>Suppose we have this binary tree and we want to remove value <code>4</code>. What do you think the resulting binary tree will look like? Click the binary tree to see the result.</p>

<div class="expand">
    <input type="checkbox" id="R-expand-88323d42a3da3d5258fdef52f8d7d24d" aria-controls="R-expandcontent-88323d42a3da3d5258fdef52f8d7d24d" >
    <label class="expand-label" for="R-expand-88323d42a3da3d5258fdef52f8d7d24d" >
        <i class="fa-fw fas fa-chevron-down"></i>
        <i class="fa-fw fas fa-chevron-right"></i>
        <a href="#R-image-0ceb04466d3de8171293db8d63abbfe6" class="lightbox-link"><img alt="Tree to Remove w/o RightChild" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/4Bin_Remove2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0ceb04466d3de8171293db8d63abbfe6"><img alt="Tree to Remove w/o RightChild" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/4Bin_Remove2.png"></a>
    </label>
    <div id="R-expandcontent-88323d42a3da3d5258fdef52f8d7d24d" class="expand-content">

<p><a href="#R-image-b592958b5f6b160b93e56a7640ab2e7d" class="lightbox-link"><img alt="Result of Remove w/o RightChild" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/4Bin_Remove3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b592958b5f6b160b93e56a7640ab2e7d"><img alt="Result of Remove w/o RightChild" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/4Bin_Remove3.png"></a></p>
</div>
</div>
<h2 id="removing-a-node-with-right-child">Removing a Node with Right Child</h2>
<p>When we remove a value from a node that has a right child, we can replace the value with the nodes smallest right child. (Lines 14-17 Below)</p>
<p>Suppose we have this binary tree and we want to remove value <code>10</code>. What do you think the resulting binary tree will look like? Click the binary tree to see the result.</p>

<div class="expand">
    <input type="checkbox" id="R-expand-e05ec77e366eaffb9e9b97b48deb27d1" aria-controls="R-expandcontent-e05ec77e366eaffb9e9b97b48deb27d1" >
    <label class="expand-label" for="R-expand-e05ec77e366eaffb9e9b97b48deb27d1" >
        <i class="fa-fw fas fa-chevron-down"></i>
        <i class="fa-fw fas fa-chevron-right"></i>
        <a href="#R-image-c0c831b98a66c24d56b7b64d46aee12e" class="lightbox-link"><img alt="Tree to Remove with RightChild" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/4Bin_Remove.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c0c831b98a66c24d56b7b64d46aee12e"><img alt="Tree to Remove with RightChild" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/4Bin_Remove.png"></a>
    </label>
    <div id="R-expandcontent-e05ec77e366eaffb9e9b97b48deb27d1" class="expand-content">

<p><a href="#R-image-0e8e4061e2ee5f31f29ed9c3cdedacd0" class="lightbox-link"><img alt="Result of Remove with RightChild" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/14/4Bin_Remove1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0e8e4061e2ee5f31f29ed9c3cdedacd0"><img alt="Result of Remove with RightChild" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/14/4Bin_Remove1.png"></a></p>
</div>
</div>
<h2 id="complete-pseudocode">Complete Pseudocode</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">1. function REMOVE(VALUE)
</span></span><span class="line"><span class="cl">2.    if node is empty:
</span></span><span class="line"><span class="cl">3.        error
</span></span><span class="line"><span class="cl">4.    if node.ITEM is VALUE
</span></span><span class="line"><span class="cl">5.        if node is a leaf
</span></span><span class="line"><span class="cl">6.            set node.ITEM to none
</span></span><span class="line"><span class="cl">7.            return TRUE
</span></span><span class="line"><span class="cl">8.        else if node has no right child
</span></span><span class="line"><span class="cl">9.            node.ITEM = LEFTCHILD.REMOVESMALLEST()
</span></span><span class="line"><span class="cl">10.           prune left-side
</span></span><span class="line"><span class="cl">11.           store left child in right child
</span></span><span class="line"><span class="cl">12.           set left child to none    
</span></span><span class="line"><span class="cl">13.           return TRUE
</span></span><span class="line"><span class="cl">14.        else
</span></span><span class="line"><span class="cl">15.            node.ITEM = RIGHTCHILD.REMOVESMALLEST()
</span></span><span class="line"><span class="cl">16.            prune right-side
</span></span><span class="line"><span class="cl">17.            return TRUE
</span></span><span class="line"><span class="cl">18.    else
</span></span><span class="line"><span class="cl">19.        if node.ITEM &gt; VALUE
</span></span><span class="line"><span class="cl">20.            if node has LEFTCHILD
</span></span><span class="line"><span class="cl">21.                SUCCESS = LEFTCHILD.REMOVE(VALUE)
</span></span><span class="line"><span class="cl">22.                prune left-side
</span></span><span class="line"><span class="cl">23.                return SUCCESS
</span></span><span class="line"><span class="cl">24.            else
</span></span><span class="line"><span class="cl">25.                return FALSE
</span></span><span class="line"><span class="cl">26.        else
</span></span><span class="line"><span class="cl">27.            if node has RIGHTCHILD
</span></span><span class="line"><span class="cl">28.                SUCCESS = RIGHTCHILD.REMOVE(VALUE)
</span></span><span class="line"><span class="cl">29.                prune right-side
</span></span><span class="line"><span class="cl">30.                return SUCCESS
</span></span><span class="line"><span class="cl">31.            else
</span></span><span class="line"><span class="cl">32.                return FALSE
</span></span><span class="line"><span class="cl">33. end function</span></span></code></pre></div><h2 id="extras-for-removal">Extras for Removal</h2>
<p>We use the pruning functions to severe the tie between parent and child nodes.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRUNERIGHT()
</span></span><span class="line"><span class="cl">    if RIGHTCHILD has no value
</span></span><span class="line"><span class="cl">        REMOVECHILD(RIGHTCHILD)
</span></span><span class="line"><span class="cl">        set this nodes RIGHTCHILD former RIGHTCHILDs RIGHTCHILD
</span></span><span class="line"><span class="cl">        if RIGHTCHLID is not none
</span></span><span class="line"><span class="cl">            ADDCHILD(RIGHTCHILD)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PRUNELEFT()
</span></span><span class="line"><span class="cl">    if LEFTCHILD has no value
</span></span><span class="line"><span class="cl">        REMOVECHILD(LEFTCHILD)
</span></span><span class="line"><span class="cl">        set this nodes LEFTCHILD former LEFTCHILDs RIGHTCHILD
</span></span><span class="line"><span class="cl">        if LEFTCHILD is not none
</span></span><span class="line"><span class="cl">            ADDCHILD(LEFTCHILD)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>We use the remove smallest function to retrieve the smallest value in the binary tree which will replace our value.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVESMALLEST()
</span></span><span class="line"><span class="cl">    if node has left child
</span></span><span class="line"><span class="cl">        REPLACEMENT = LEFTCHILD.REMOVESMALLEST
</span></span><span class="line"><span class="cl">        prune left-side
</span></span><span class="line"><span class="cl">        return REPLACEMENT
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        REPLACEMENT = node.ITEM
</span></span><span class="line"><span class="cl">        if node has right child
</span></span><span class="line"><span class="cl">            node.ITEM = RIGHTCHILD.REMOVESMALLEST()
</span></span><span class="line"><span class="cl">            prune right-side
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            node.ITEM = NONE
</span></span><span class="line"><span class="cl">        return REPLACEMENT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mytree-recursive-iii">MyTree Recursive III</h1>

<h3 id="traversals">Traversals</h3>
<p>In this module we have talked about two traversals: preorder and postorder. Both of these are defined recursively and the prefix refers to the order of the root.</p>
<h5 id="preorder">Preorder</h5>
<p>In a preorder traversal, first we access the root and then run the preorder traversal on the children.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function PREORDER(RESULT)
</span></span><span class="line"><span class="cl">    append ITEM to RESULT
</span></span><span class="line"><span class="cl">    FOR CHILD in CHILDREN
</span></span><span class="line"><span class="cl">           CHILD.PREORDER(RESULT)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h5 id="postorder">Postorder</h5>
<p>In a postorder traversal, first we run the postorder traversal on the children then we access the root.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function POSTORDER(RESULT)
</span></span><span class="line"><span class="cl">   FOR CHILD in CHILDREN
</span></span><span class="line"><span class="cl">           CHILD.POSTORDER(RESULT)
</span></span><span class="line"><span class="cl">   append ITEM to RESULT
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc310/commit/3b7bf15b5591d8a42ba00c1c6e0018f1dc31112e">Jul 1, 2024</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc310/js/clipboard.min.js?1719877281" defer></script>
    <script src="/cc310/js/perfect-scrollbar.min.js?1719877281" defer></script>
    <script src="/cc310/js/theme.js?1719877281" defer></script>
  </body>
</html>
