




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Old Conetnt :: CC 310 Textbook</title>
    <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/</link>
    <description>Old Content</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://textbooks.cs.ksu.edu/cc310/09-trees/old/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tries</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/1-tries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/1-tries/</guid>
      <description>YouTube Video Recall that in the beginning of our discussions about trees, we looked at a small tree which contained seven strings as motivation for trees. This was a small example of a trie (pronounced ’try’) which is a type of tree that can represent sets of words. Tries can be used for a variety of tasks ranging from leisurely games to accessibility applications. One example is ‘Boggle’ where players have a set of random letters and try to make as many words as possible.</description>
    </item>
    <item>
      <title>Trie Example</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/2-trie-example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/2-trie-example/</guid>
      <description>Let’s look at another example of a trie. Here we have a larger trie. Think about how many words are captured by the tree; click the tree to see how many! This tree contains 12 words: ‘ate’, ‘an’, ‘and’, ‘ant’, ‘app’, ‘apple’, ‘cat’, ‘can’, ‘cup’, ‘by’, ‘be’, and ‘been’. While the ‘a’, ‘at’, and ‘bee’ are words in the English language, they are not recognized by our trie. Depending on what the user intended, this could be by design.</description>
    </item>
    <item>
      <title>MyTrie I</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/3-mytrie-i/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/3-mytrie-i/</guid>
      <description>To implement our own trie, we will build off of MyTree that we built recursively. We will add an attribute to our tree to reinforce which nodes are words and which ones are not.&#xA;Attributes We have the existing attributes of MyTree: parent, children, and item. For MyTrie, we introduce the boolean attribute is_word to delineate if our trie is a word.&#xA;Adding a Word YouTube Video To add a word to our trie, we traverse through the trie letter by letter.</description>
    </item>
    <item>
      <title>Recursion Refresh</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/3-recursion-refresh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/3-recursion-refresh/</guid>
      <description>YouTube Video Info A recursive program is broken into two parts:&#xA;A base case—a simple version of the problem that can be solved directly, and A recursive case—a general solution to the problem that uses smaller versions of the problem to compute the solution to the larger problem. In principle, the recursive case breaks the problem down into smaller portions until we reach the base case. Recursion presents itself in many ways when dealing with trees.</description>
    </item>
    <item>
      <title>MyTrie II</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/4-mytrie-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/4-mytrie-ii/</guid>
      <description>Getters YouTube Video Getting word count For this function, we want to get the total number of words that are contained within our trie. We will fan out through all of the children and count all of the nodes that have their is_word attribute equal to true.&#xA;function WORDCOUNT() COUNT = 0 if is_word COUNT = 1 for CHILD in CHILDREN COUNT += CHILD.WORDCOUNT() return COUNT end function Get max word length Next, we want to get the longest word contained in our trie.</description>
    </item>
    <item>
      <title>MyBinaryTree</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/5-mybinarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/5-mybinarytree/</guid>
      <description>YouTube Video Our implementation of binary trees will inherit from our MyTree implementation as binary trees are types of trees. Thus, MyBinaryTree will have the functionality of MyTree in addition to the following.&#xA;Attributes The binary tree has two attributes&#xA;Left Child: an instance of MyBinaryTree, the item should be less than the item of the parent. Right Child: an instance of MyBinaryTree, the item should be greater than the item of the parent.</description>
    </item>
    <item>
      <title>Inserting Children</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/6-inserting-children/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/6-inserting-children/</guid>
      <description>YouTube Video When inserting children to a binary tree, we must take some special considerations. All of the node items in the left tree must be less than the parent node item and all of the node items in the right tree must be greater than the parent node item.&#xA;The general procedure for adding a child is the following: Suppose that we have the following tree and we want to add a node with item ‘85’.</description>
    </item>
    <item>
      <title>MyTree Recursive I</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/6-mytree-recursive-i/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/6-mytree-recursive-i/</guid>
      <description>Again, we want to be able to implement a working version of a tree. From the last module, we had functions to add children, remove children, get attributes, and instantiate MyTree. We will now build upon that implementation to create a true tree.&#xA;Info A recursive program is broken into two parts:&#xA;A base case—a simple version of the problem that can be solved directly, and A recursive case—a general solution to the problem that uses smaller versions of the problem to compute the solution to the larger problem.</description>
    </item>
    <item>
      <title>MyTree Recursive II</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/7-mytree-recursive-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/7-mytree-recursive-ii/</guid>
      <description>Determine relationships (Ancestor, Descendant, Sibling) We can determine many relationships within the tree. For example, given a node is it an ancestor of another node, a descendant, or a sibling?&#xA;YouTube Video Is Ancestor? For this function, we are asking: is this node an ancestor of the current instance? In this implementation, we will start at our instance and work down through the tree trying to find the node in question.</description>
    </item>
    <item>
      <title>Removing Children</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/7-removing-children/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/7-removing-children/</guid>
      <description>YouTube Video Removing children is not as straightforward as inserting them. The general procedure for removing a child is to replace that nodes value with its smallest right descendant. First we will traverse the binary tree until we find the node with the value we are trying to remove (lines 18-32 below). Then we have three separate cases, discussed in detail below.&#xA;Removing a Leaf Removing a leaf is the most straightforward.</description>
    </item>
    <item>
      <title>MyTree Recursive III</title>
      <link>https://textbooks.cs.ksu.edu/cc310/09-trees/old/8-mytree-recursive-iii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc310/09-trees/old/8-mytree-recursive-iii/</guid>
      <description>Traversals In this module we have talked about two traversals: preorder and postorder. Both of these are defined recursively and the prefix refers to the order of the root.&#xA;Preorder In a preorder traversal, first we access the root and then run the preorder traversal on the children.&#xA;function PREORDER(RESULT) append ITEM to RESULT FOR CHILD in CHILDREN CHILD.PREORDER(RESULT) end functionPostorder In a postorder traversal, first we run the postorder traversal on the children then we access the root.</description>
    </item>
  </channel>
</rss>