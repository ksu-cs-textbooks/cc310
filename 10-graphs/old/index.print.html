




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
		
		
		
	  

  
	
	  

  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="Old Content">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Old Conetnt :: CC 310 Textbook">
    <meta name="twitter:description" content="Old Content">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/10-graphs/old/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Old Conetnt :: CC 310 Textbook">
    <meta property="og:description" content="Old Content">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Old Conetnt :: CC 310 Textbook">
    <meta itemprop="description" content="Old Content">
    <meta itemprop="dateModified" content="2024-07-03T10:50:03-05:00">
    <meta itemprop="wordCount" content="2">
    <title>Old Conetnt :: CC 310 Textbook</title>
    <link href="/cc310/css/fontawesome-all.min.css?1737134929" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1737134929" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1737134929" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1737134929" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1737134929" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1737134929" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1737134929" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1737134929" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1737134929" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1737134929" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1737134929" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1737134929" rel="stylesheet">
    <link href="/cc310/css/print.css?1737134929" rel="stylesheet" media="print">
    <link href="/cc310/css/format-print.css?1737134929" rel="stylesheet">
    <script src="/cc310/js/variant.js?1737134929"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1737134929" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc310/10-graphs/old/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="/cc310/10-graphs/"><span itemprop="name">Graphs</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Old Conetnt</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/10-graphs/12-summary/" title="Summary (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/10-graphs/old/4-uml---graph-node/" title="UML - Graph Node (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="old-conetnt">Old Conetnt</h1>

<p>Old Content</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Old Conetnt</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="uml---graph-node">UML - Graph Node</h1>


<a href="https://www.youtube.com/watch?v=BVgbAW7NZY8">YouTube Video</a>

<p>In this representation, we will have an array of graph node objects. We will first cover the UML for the graph node objects and then discuss the graph functions and attributes.</p>
<p><a href="#R-image-b20799c58ae4b397021354a6aa9c715f" class="lightbox-link"><img alt="List Graph UML for Nodes" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/15/graphs_listUML_node.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b20799c58ae4b397021354a6aa9c715f"><img alt="List Graph UML for Nodes" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/15/graphs_listUML_node.svg"></a></p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>item</code>: the value that the node contains.</li>
<li><code>index</code>: the index of the node.</li>
<li><code>edges</code>: ordered pairs <code>(e, w)</code> where this node is the source, <code>e</code> is the target node index, and <code>w</code> is the weight of the edge as a double.</li>
</ul>
<p>We will initialize a graph node with the given item and the given index. We initialize the <code>edges</code> attribute to be an empty list.</p>
<h2 id="getters">Getters</h2>
<ul>
<li>
<p><code>get item</code>: Returns the graph node&rsquo;s item.</p>
</li>
<li>
<p><code>get index</code>: Returns the graph node&rsquo;s index.</p>
</li>
<li>
<p><code>get edges</code>: Returns the graph node&rsquo;s edges.</p>
</li>
<li>
<p><code>get edge</code>: From the source node, we will call the get edge function with the index of the target node as input. This will return the edge weight.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGE(TARINDEX)
</span></span><span class="line"><span class="cl">    for EDGE in nodes EDGES
</span></span><span class="line"><span class="cl">        if the first element in EDGE is TARINDEX
</span></span><span class="line"><span class="cl">            return the second element in EDGE
</span></span><span class="line"><span class="cl">    return infinity </span></span></code></pre></div><h2 id="edge-functions">Edge Functions</h2>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>Working with the edges in our graph becomes slightly more complicated in the list representation. Previously, we were able to go right to the entry in our adjacency matrix and update it. Since each node keeps track of its own edges in no particular order, we must loop through each entry of the edges attribute to find a potential edge.</p>
</div>
</div>
<ul>
<li><code>add edge</code>: From the source node, we will call the add edge function with the target node as input as well as the weight. First, we will attempt to remove the edge. We need to do this as we do not want duplicate edges in our graph. Then we will add the ordered pair to the edges attribute.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(TARINDEX, WEIGHT)
</span></span><span class="line"><span class="cl">    call REMOVEEDGE(TARINDEX) on this node
</span></span><span class="line"><span class="cl">    append (TARINDEX, WEIGHT) to this nodes EDGES </span></span></code></pre></div><ul>
<li><code>remove edge</code>: From the source node, we will call the remove edge function with the target node as input. This will return true if it was successful and false if not.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(TARINDEX)
</span></span><span class="line"><span class="cl">    for EDGE in nodes EDGES
</span></span><span class="line"><span class="cl">        if the first element in EDGE is TARINDEX
</span></span><span class="line"><span class="cl">            remove EDGE from EDGES
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">    return false </span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="node-and-edge-functions">Node and Edge Functions</h1>

<ul>
<li><code>add node</code>: will add a node to the graph with the given value if our graph still has room. Finding a location for the node will be the same procedure as the matrix graph. If we find an open spot to add the node, we will instantiate a new graph node and insert it into the <code>nodes</code> attribute.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDNODE(VALUE)
</span></span><span class="line"><span class="cl">    IDX = -1
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is VALUE 
</span></span><span class="line"><span class="cl">            return NODE&#39;s index
</span></span><span class="line"><span class="cl">        if NODE has no entry and IDX is -1
</span></span><span class="line"><span class="cl">            IDX = NODE&#39;s index
</span></span><span class="line"><span class="cl">    if IDX is not -1
</span></span><span class="line"><span class="cl">        NEWNODE = graph node with VALUE and IDX for input
</span></span><span class="line"><span class="cl">        add NEWNODE to NODES at position IDX
</span></span><span class="line"><span class="cl">        increment SIZE
</span></span><span class="line"><span class="cl">    return IDX</span></span></code></pre></div><ul>
<li><code>remove node</code>: will remove a node to the graph with the given value if our graph has the node. We will set the node to be empty. When we set the node to be empty, we clear all of the outgoing edges, so we just need to loop through the other nodes removing any possible incoming edges.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVENODE(IDX)
</span></span><span class="line"><span class="cl">    if IDX is in the range of our indexes 
</span></span><span class="line"><span class="cl">        if NODES at position IDX is not empty
</span></span><span class="line"><span class="cl">            set NODES at IDX to be empty
</span></span><span class="line"><span class="cl">            decrement SIZE by one
</span></span><span class="line"><span class="cl">            for NODE in NODES
</span></span><span class="line"><span class="cl">                if NODE has no entry
</span></span><span class="line"><span class="cl">                    from NODE call the graph node REMOVEEDGE function on IDX
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false </span></span></code></pre></div><ul>
<li><code>add edge</code>: will add an edge with the given weight which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(SRC, TAR, WEIGHT)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        if SRCNODE is not empty
</span></span><span class="line"><span class="cl">            from SRCNODE call the graph node ADDEDGE with TAR and WEIGHT as input
</span></span><span class="line"><span class="cl">            return true 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>remove edge</code>: will remove the edge which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(SOURCE, TARGET)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        SRCNODE = the node at index SRC of the NODES attribute
</span></span><span class="line"><span class="cl">        if SRCNODE has no entry
</span></span><span class="line"><span class="cl">            RET = SRCNODE call the graph node REMOVEEDGE with TAR as input
</span></span><span class="line"><span class="cl">            return RET 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>add undirected edge</code>: will add two edges with the given weight between the two given nodes</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDUNDIRECTEDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = ADDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = RES and ADDEDGE(NODE2, NODE1, WEIGHT)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div><ul>
<li><code>remove undirected edge</code>: will remove two edges between the two given nodes.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEUNDIRECTEDEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = REMOVEEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = RES and REMOVEEDGE(NODE2, NODE1)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p><a href="#R-image-b3e311ca1de0d4470f47a6a2c8e7cb74" class="lightbox-link"><img alt="Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/15/graphA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b3e311ca1de0d4470f47a6a2c8e7cb74"><img alt="Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/15/graphA.svg"></a></p>
<p>In this module, we introduced a new way to store the graph data structure. Thus, we now have two ways to work with graphs, in lists and in matrices:</p>
<h2 id="list-representation">List Representation</h2>
<p><a href="#R-image-edff00d1ffbd575d64481565b4e1c323" class="lightbox-link"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/15/graphA_list_rep.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-edff00d1ffbd575d64481565b4e1c323"><img alt="List Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/15/graphA_list_rep.svg"></a></p>
<h2 id="matrix-representation">Matrix Representation</h2>
<p><a href="#R-image-b778f0a675949963af3cda37a74200da" class="lightbox-link"><img alt="Matrix Representation for Example 1" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/15/matrixA.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b778f0a675949963af3cda37a74200da"><img alt="Matrix Representation for Example 1" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/15/matrixA.svg"></a></p>
<p>While these methods show the same information, there are cases when one way may be more desirable than the other.</p>
<p>We discussed how a sparse graph is better suited for a list representation and a dense graph is better suited for a matrix representation. We also touched on how working with the edges in a list representation can add complexity to our edge functions. If we are needing to access edge weights or update edges frequently, a matrix representation would be a good choice &ndash; especially if we have a lot of nodes.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="uml">UML</h1>


<a href="https://www.youtube.com/watch?v=Alyg8IEC0Os">YouTube Video</a>

<p><a href="#R-image-aeda6a8014304dbbdacd0744a6646141" class="lightbox-link"><img alt="Matrix Graph UML" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/15/graphmatUML.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-aeda6a8014304dbbdacd0744a6646141"><img alt="Matrix Graph UML" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/15/graphmatUML.svg"></a></p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>nodes</code>: This will keep track of the nodes which are in our graph as well as the node values. The nodes can have any type of value such as numbers, characters, and even other data structures.</li>
<li><code>edges</code>: This will keep track of the edges which are in our graph.</li>
<li><code>size</code>: This will keep track of the number of nodes that are active in our graph.</li>
</ul>
<p>Upon initialization, we will initialize <code>nodes</code> to be an empty array of size <code>capacity</code>, <code>edges</code> to be an empty two-dimensional array with dimensions <code>capacity</code> by <code>capacity</code> and <code>size</code> to be zero as we start with no actual nodes.</p>
<h2 id="getters">Getters</h2>
<ul>
<li><code>get nodes</code>: returns a list of the nodes with their respective indexes</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNODES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE has a VALUE
</span></span><span class="line"><span class="cl">            append (VALUE, INDEX) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li><code>get edges</code>: returns a list of the edges in the format (source, target, weight)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETEDGES()
</span></span><span class="line"><span class="cl">    LIST = []
</span></span><span class="line"><span class="cl">    for ROW in EDGES
</span></span><span class="line"><span class="cl">        for COL in ROW
</span></span><span class="line"><span class="cl">            VALUE = entry at (ROW,COL)
</span></span><span class="line"><span class="cl">            if VALUE is not infinity
</span></span><span class="line"><span class="cl">                    append (ROW,COL,VALUE) to LIST
</span></span><span class="line"><span class="cl">    return LIST</span></span></code></pre></div><ul>
<li>
<p><code>get node</code>: returns the node with the given index. If the index is within the possible range, then we return the value of that node.</p>
</li>
<li>
<p><code>find node</code>: returns the index of the given node. We iterate through our nodes and if we find that value, then we return the index. Otherwise, return <code>-1</code>.</p>
</li>
<li>
<p><code>get edge</code>: returns the weight of the edge between the given indexes of the source node and target node. If one or both of the indexes are out of range, then we should return infinity.</p>
</li>
<li>
<p><code>get capacity</code>: returns the maximum number of nodes we are allowed to have. Upon initialization, we will have a fixed number of possible nodes in our node array. We can simply return the size of this array.</p>
</li>
<li>
<p><code>get size</code>: returns the size attribute.</p>
</li>
<li>
<p><code>get number of edges</code>: returns the number of edges currently in the graph. We will iterate through our edges and return the number of entries that were not infinity.</p>
</li>
<li>
<p><code>get neighbors</code>: returns the neighbors of the given node. We will access our row adjacency matrix that corresponds to the node and return the indexes and values of those entries which are not infinity.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function GETNEIGHBORS(IDX)
</span></span><span class="line"><span class="cl">    if IDX in range of NODES length
</span></span><span class="line"><span class="cl">        LIST = []
</span></span><span class="line"><span class="cl">        ROW = the IDX-th row of EDGES
</span></span><span class="line"><span class="cl">        for J in range  0 to ROW length
</span></span><span class="line"><span class="cl">            VALUE = J-th entry of ROW
</span></span><span class="line"><span class="cl">            if VALUE is not infinity
</span></span><span class="line"><span class="cl">                    append (J,VALUE) to LIST
</span></span><span class="line"><span class="cl">        return LIST</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="node-and-edge-functions">Node and Edge Functions</h1>


<a href="https://www.youtube.com/watch?v=MNoJEn_EvBk">YouTube Video</a>

<ul>
<li><code>add node</code>: will add a node to the graph with the given value if our graph still has room. Procedurally, we will try to put the node in the first empty place we find. To do this, we start with <code>IDX</code> equal to negative one then loop through all of the indexes of the graphs <code>nodes</code> attribute. At each index, we check if that entry is equal to the value we are trying to add. This will check if the value is already in our graph. If there is nothing in that entry and the <code>IDX</code> variable is still negative one, then we will set <code>IDX</code> equal to that index. We continue looping through the <code>nodes</code> attribute until we reach the end. It is possible that there is more than one open space in the <code>nodes</code> attribute. Thus, by checking if <code>IDX</code> is still negative one we can make sure to put <code>value</code> in the first empty spot. Once we finish going through <code>nodes</code> we check to see if we ever found an open spot. If <code>IDX</code> is still negative one, this would indicate that there was no room. Otherwise, we put <code>value</code> into <code>nodes</code> at spot <code>IDX</code> and increment the size.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDNODE(VALUE)
</span></span><span class="line"><span class="cl">    IDX = -1
</span></span><span class="line"><span class="cl">    for NODE in NODES
</span></span><span class="line"><span class="cl">        if NODE is VALUE 
</span></span><span class="line"><span class="cl">            return NODE&#39;s index
</span></span><span class="line"><span class="cl">        if NODE has no entry and IDX is -1
</span></span><span class="line"><span class="cl">            IDX = NODE&#39;s index
</span></span><span class="line"><span class="cl">    if IDX is not -1
</span></span><span class="line"><span class="cl">        add VALUE to NODES at position IDX
</span></span><span class="line"><span class="cl">        increment SIZE
</span></span><span class="line"><span class="cl">    return IDX</span></span></code></pre></div><ul>
<li><code>remove node</code>: will remove a node to the graph with the given value if our graph has the node. We will set the node to be empty and remove any edges that may be attached to it.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVENODE(IDX)
</span></span><span class="line"><span class="cl">    if IDX is in the range of our indexes 
</span></span><span class="line"><span class="cl">        if NODES at position IDX is not empty
</span></span><span class="line"><span class="cl">            set NODES at IDX to be empty
</span></span><span class="line"><span class="cl">            decrement SIZE by one
</span></span><span class="line"><span class="cl">            for J in node indexes 
</span></span><span class="line"><span class="cl">                set EDGES (J,IDX) equal to infinity 
</span></span><span class="line"><span class="cl">                set EDGES (IDX,J) equal to infinity
</span></span><span class="line"><span class="cl">            return true
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false </span></span></code></pre></div><ul>
<li><code>add edge</code>: will add an edge with the given weight which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDEDGE(SOURCE, TARGET, WEIGHT)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        set EDGES(SOURCE, TARGET) equal to WEIGHT
</span></span><span class="line"><span class="cl">        return true 
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>remove edge</code>: will remove the edge which goes from the source node to the target node</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEEDGE(SOURCE, TARGET)
</span></span><span class="line"><span class="cl">    if SOURCE and TARGET are both in the range of our node indexes
</span></span><span class="line"><span class="cl">        if EDGES(SOURCE, TARGET) is not equal to infinity
</span></span><span class="line"><span class="cl">            set EDGES(SOURCE, TARGET) equal to infinity
</span></span><span class="line"><span class="cl">            return true 
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        return false</span></span></code></pre></div><ul>
<li><code>add undirected edge</code>: will add two edges with the given weight between the two given nodes</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function ADDUNDIRECTEDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = ADDEDGE(NODE1, NODE2, WEIGHT)
</span></span><span class="line"><span class="cl">    RES = RES and ADDEDGE(NODE2, NODE1, WEIGHT)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div><ul>
<li><code>remove undirected edge</code>: will remove two edges between the two given nodes. We can utilize the remove edge function on &lsquo;NODE1&rsquo; to &lsquo;NODE2&rsquo; and then on &lsquo;NODE2&rsquo; to &lsquo;NODE1&rsquo;.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function REMOVEUNDIRECTEDEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = REMOVEEDGE(NODE1, NODE2)
</span></span><span class="line"><span class="cl">    RES = RES and REMOVEEDGE(NODE2, NODE1)
</span></span><span class="line"><span class="cl">    return RES</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc310/commit/b806b39e06b3286e793d1e17e7c90e68a994e4ce">Jul 3, 2024</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc310/js/clipboard.min.js?1737134929" defer></script>
    <script src="/cc310/js/perfect-scrollbar.min.js?1737134929" defer></script>
    <script src="/cc310/js/theme.js?1737134929" defer></script>
  </body>
</html>
