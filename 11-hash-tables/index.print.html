




  
	
	  

  
	
	  

  
	
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
		
	  

  
	
		
		
	  

  
	
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Welcome! This page is the main page for Hash Tables">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Hash Tables :: CC 310 Textbook">
    <meta name="twitter:description" content="Welcome! This page is the main page for Hash Tables">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc310/11-hash-tables/">
    <meta property="og:site_name" content="CC 310 Textbook">
    <meta property="og:title" content="Hash Tables :: CC 310 Textbook">
    <meta property="og:description" content="Welcome! This page is the main page for Hash Tables">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Hash Tables :: CC 310 Textbook">
    <meta itemprop="description" content="Welcome! This page is the main page for Hash Tables">
    <meta itemprop="datePublished" content="2021-08-17T00:00:00+00:00">
    <meta itemprop="dateModified" content="2021-08-17T10:22:02-05:00">
    <meta itemprop="wordCount" content="10">
    <title>Hash Tables :: CC 310 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc310/11-hash-tables/" rel="canonical" type="text/html" title="Hash Tables :: CC 310 Textbook">
    <link href="/cc310/11-hash-tables/index.xml" rel="alternate" type="application/rss+xml" title="Hash Tables :: CC 310 Textbook">
    <link href="/cc310/11-hash-tables/tele.html" rel="alternate" type="text/html" title="Hash Tables :: CC 310 Textbook">
    <link href="/cc310/11-hash-tables/embed.html" rel="alternate" type="text/html" title="Hash Tables :: CC 310 Textbook">
    <link href="/cc310/css/fontawesome-all.min.css?1719608379" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fontawesome-all.min.css?1719608379" rel="stylesheet"></noscript>
    <link href="/cc310/css/nucleus.css?1719608379" rel="stylesheet">
    <link href="/cc310/css/auto-complete.css?1719608379" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/auto-complete.css?1719608379" rel="stylesheet"></noscript>
    <link href="/cc310/css/perfect-scrollbar.min.css?1719608379" rel="stylesheet">
    <link href="/cc310/css/fonts.css?1719608379" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc310/css/fonts.css?1719608379" rel="stylesheet"></noscript>
    <link href="/cc310/css/theme.css?1719608379" rel="stylesheet">
    <link href="/cc310/css/theme-auto.css?1719608379" rel="stylesheet" id="R-variant-style">
    <link href="/cc310/css/chroma-auto.css?1719608379" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cc310/css/variant.css?1719608379" rel="stylesheet">
    <link href="/cc310/css/print.css?1719608379" rel="stylesheet" media="print">
    <link href="/cc310/css/format-print.css?1719608379" rel="stylesheet">
    <script src="/cc310/js/variant.js?1719608379"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc310';
      window.index_js_url="/cc310/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cc310/css/custom.css?1719608379" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cc310/11-hash-tables/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Hash Tables</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/10-sets/6-sets-summary/" title="Sets Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cc310/11-hash-tables/1-what-are-hash-tables-/" title="What are Hash Tables? (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 55</div>

<h1 id="hash-tables">Hash Tables</h1>

<h3 id="welcome">Welcome!</h3>
<p>This page is the main page for Hash Tables</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Hash Tables</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="what-are-hash-tables">What are Hash Tables?</h1>


<a href="https://www.youtube.com/watch?v=2o6LDaTDdt4">YouTube Video</a>

<p>A hash table is an unordered collection of key-value pairs, where each key is unique. The great thing about hash tables is that they provide efficient insertion, removal and lookup operations that arrays and linked lists cannot match, such as:</p>
<ul>
<li>Retrieval operations in an unsorted array run in order $N$ time,</li>
<li>Retrieval operations in a sorted array using binary search run in constant time, but insertion operations run in order $N$ time, and</li>
<li>Insertion operations run in constant time in linked lists, but retrieval operations run in order $N$ time.</li>
</ul>
<p>A hash table consists of three components:</p>
<ol>
<li>An array that holds buckets where key-value pairs are stored,</li>
<li>A hash function that maps a key to a specific array index, and</li>
<li>A set of buckets that allow the hash table to store multiple key-value pairs whose keys map to the same index in the array; we implement our buckets using linked lists.</li>
</ol>
<p>A user basically stores a key-value pair in the hash table where the key is used to identify the key-value pair as well as compute where it will be stored. For instance, if we consider all the students in a university, we can store student information (name, address, phone, major, GPA, courses, etc.) in the hash table using their name as the key.
Storing a key-value pair in a hash table uses the following procedure.</p>
<ol>
<li>The user presents a key-value pair to be stored in the hash table.</li>
<li>The key is run through a hash function, which generates an index into the hash table&rsquo;s array.</li>
<li>The key-value pair is stored in the bucket (linked list) referenced at that index.</li>
</ol>
<p><a href="#R-image-f73a84f0df59ce9ffda3fa5d87033348" class="lightbox-link"><img alt="Hash Table Linked List" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/11/11.1.list.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f73a84f0df59ce9ffda3fa5d87033348"><img alt="Hash Table Linked List" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/11/11.1.list.svg"></a></p>
<p>Retrieving a key-value pair from the hash table follows a similar procedure.</p>
<ol>
<li>The user presents the key to the key-value pair to be retrieved.</li>
<li>The key is run through a hash function, which generates an index into the hash table&rsquo;s array.</li>
<li>The bucket referenced at that index in the array is then searched for the appropriate key.</li>
<li>If found, the key-value pair is returned to the user.</li>
</ol>
<p>Ideally, it would be nice if there was only a single key-value pair stored in each bucket. However, we cannot guarantee this so we use a linked list to allow us to store multiple items whose key produces the same index.</p>
<h2 id="dictionaries">Dictionaries</h2>
<p>Another data type that is similar to hash tables and is built into many modern programming languages, is the <em>dictionary</em> or an <em>associative array</em>. A dictionary is a collection of key-value pairs that is directly indexed by a key instead of an integer. These keys can be an integer, a string, or other data types. Dictionaries typically support the following operations:</p>
<ol>
<li>Add a key-value pair to the collection,</li>
<li>Remove a key-value pair from the collection,</li>
<li>Modify an existing key-value pair in the collection, and</li>
<li>Lookup a value associated with a given key.</li>
</ol>
<p>As you can see dictionaries and hash tables are very similar in their basic operation. However, an important difference is that hash tables tend to allow any type of objects as the value in the key-value pairs, while dictionaries typically require a specific type of object to be the value. A dictionary can be implemented using a variety of data structures including linked lists and hash tables.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="hash-tables-in-code">Hash Tables in Code</h1>

<p>As stated previously, a hash table has three main components: an array, a hash function, and a set of buckets that store key-value pairs. We discuss the implementation of these below.</p>
<h2 id="array">Array</h2>
<p>We use an array to hold pointers to the buckets where the key-value pairs are stored. While the array itself is a common data type found in almost every language, there are some important aspects to the arrays used in hash tables.</p>
<p>First, the array must be large enough to store our key-value pairs without too many collisions. A collision occurs when two key-value pairs map to the same array index. Although we cannot keep this from happening, the fewer collisions, the faster the hash table. Thus, the larger the array, the lower the chance for collisions. We capture the size of the array as its <em>capacity</em>.</p>
<p>In the example below, both hash tables are storing the same number of key-value pairs. However, the capacity of the array on the right is more than twice as large as the one on the left. To retrieve a random key-value pair from each of these arrays requires a search of one of the linked list buckets. For the array on the left, the average number of nodes searched is $1.8$, while for the array on the right it is only $1.2$. Thus, in this example doubling the capacity of our array provides a $33\%$ reduction in the time required to retrieve a key-value pair. (Note that these statistics were computed based on these particular array capacities and the number of key-value pairs in the example.)</p>
<p><a href="#R-image-b55629681531863a1700ed8e54c9d4ec" class="lightbox-link"><img alt="Hash Table Capacity Examples" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/11/11.2.capacity.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b55629681531863a1700ed8e54c9d4ec"><img alt="Hash Table Capacity Examples" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/11/11.2.capacity.svg"></a></p>
<p>Second, the array should be re-sizable. Since we generally do not know in advance how many key-value pairs we have to store in our hash table, we need to be able to resize our array when the number of key-value pairs reaches a predefined threshold. This threshold is based on the loading factor, which we define next.</p>
<h2 id="load-factor">Load Factor</h2>
<p>As we store more key-value pairs in a hash table, the number of collisions will increase. The more collisions we have, the less efficient our hash table will become. Thus, at some point, it makes sense to increase the capacity of the array and <em>rehash</em> our table, which means we compute new indexes for all key-value pairs and add them into the new array. The question is, when is the appropriate time to do this?</p>
<p>Traditionally, we answer this question using a ratio of the capacity of the hash table array to the number of key-value pairs stored in the table. There are three key properties of hash tables that come into play here:</p>
<ul>
<li>The <em>capacity</em> of the array,</li>
<li>The <em>size</em> of the hash tables in terms of the number of key-value pairs stored in the table,</li>
<li>The <em>load factor</em> (or ratio) between the size of the hash table and its capacity, $\text{size} / \text{capacity}$.</li>
</ul>
<p>Typically, when the load factor reaches a specified threshold, we double the capacity of the array and then rehash the table using the new array. The load factor threshold we choose is a tradeoff between space and time. The larger the array, the more memory you use, but with fewer collisions. Obviously, using a smaller array increases the number of collisions as well as the time it takes to retrieve key-value pairs from the table. For our examples below, we use the standard default load factor of $0.75$.</p>
<h2 id="buckets">Buckets</h2>
<p>If our array was large enough to ensure our hash function would compute a unique index for each key (i.e., there would be absolutely no collisions), we could store the key-value pairs directly in the array. Unfortunately, this is almost never the case and collisions do occur. Therefore, we store the key-value pairs in buckets associated with each array index. <em>Buckets</em> are the general term we use to describe the mechanism we use to store key-value pairs and handle any collisions that occur. As shown in the figure below, we use linked lists to implement our buckets, which is a fairly standard approach.</p>
<p><a href="#R-image-9f30942c1c3899733daced3c3182c489" class="lightbox-link"><img alt="Hash Table Buckets" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/11/11.2.buckets.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9f30942c1c3899733daced3c3182c489"><img alt="Hash Table Buckets" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/11/11.2.buckets.svg"></a></p>
<p>As we recall, linked lists provide constant time operations for adding key-value pairs to the list and linear time operations for retrieving key-value pairs from the list. While linear time seems slow for adding a key-value pair to the list, we need to remember that we are talking only about the number of key-value pairs in a specific list, not the total number of key-value pairs in the entire hash table. Thus, as shown in the figure above, the maximum number of key-value pairs in any linked list is $2$, even though the size of the entire table is $9$. With a load factor of $0.75$ and a good quality hash function that distributes key-value pairs uniformly across the array, our linked lists generally have a small number of items ($2$ or $3$ maximum) in each list. So, even though retrieving is not technically constant time, because it is very close to it in practice, we say that it is.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="hash-functions">Hash Functions</h1>

<p>A <em>hash function</em> converts a key into a hash code, which is an integer value that can be used to index our hash table array.  Obviously, there are some hash functions that are better than others. Specifically, a good hash function is both easy to compute and should uniformly distribute the keys across our hash table array. Both of these are important factors in how fast our hash table operates, since we compute a hash code each time we insert or get a key-value pair from the hash table. If it takes too long to compute the hash code, we lose the benefits of having constant time insertion and retrieval operations. Likewise, if the function does not distribute the keys evenly across the table, we end up with several keys in the same bucket, which causes longer times to retrieve key-value pairs.</p>
<p>A good hash function should have three important properties.</p>
<ul>
<li>Uniform: the input values should uniformly map to the output range.</li>
<li>Efficient: the hash function should be fast to compute.</li>
<li>Deterministic: the hash function should always compute the same value for a given input.</li>
</ul>
<p>Luckily, many modern programming languages provide native support for hash functions. Both Java and Python provide built-in hashing functions. These functions take any object and produce an integer, which we then use with the modulo operator to reduce it to the appropriate size for our array capacity. An example of how to use the Java <code>hashCode</code> function is shown below. More information on the Java <code>hashCode</code> function can be found <a href="https://www.baeldung.com/java-hashcode" rel="external" target="_blank">here</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">computeIndex</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">key</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">key</span><span class="p">.</span><span class="na">hashCode</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getCapacity</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></div><p>An example of using Python&rsquo;s <code>hash</code> function is shown below. More information on hashing in Python and the <code>hash</code> function can be found <a href="https://www.programiz.com/python-programming/methods/built-in/hash" rel="external" target="_blank">here</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">compute_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span></span></span></code></pre></div>
  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<h1 id="hashing-passwords">Hashing Passwords</h1>
<p>Another interesting use of hash functions deals with storing and verifying passwords. When we sign up for an account on a website, it asks us for a password that we&rsquo;d like to use. Obviously, if that website just stored the password directly in their database, it could be a huge security problem if someone was able to gain access to that information. So, how can the website store a password in a way that prevents a hacker from learning our password, but the website can verify that we&rsquo;ve entered the correct password?</p>
<p>In many cases, we can use a hash function to do just that. When we first enter our password, the website calculates the hash code for the password and then stores the result in the database.</p>
<p>Then, when we try to log in to the website in the future, we provide the same password, and the website is able to calculate the hash again and verify that they match. As long as the hash function is properly designed, it is very unlikely for two passwords to result in the same hash, even if they are very similar.</p>
<p><a href="#R-image-f9a7a04677820035d5b27738fce3cfde" class="lightbox-link"><img alt="Hash Function" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cc310/images/11/11.3.hash.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f9a7a04677820035d5b27738fce3cfde"><img alt="Hash Function" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cc310/images/11/11.3.hash.png"></a></p>
<p>In practice, most websites add additional random data to the password before hashing it, just to decrease the chances of two passwords hashing to the same value. This is referred to as &ldquo;salting&rdquo; the password.</p>
</div>
</div>
<h2 id="keys">Keys</h2>
<p>Keys allow us to easily differentiate between data items that have different values. For example, if we wanted to store student data such as first name, last name, date of birth, and identification number, it would be convenient to have one piece of data that could differentiate between all the students. However, some data are better suited to be keys than others. In general, the student&rsquo;s last name tends to be more selective than the first name. However, the student identification number is even better since it is guaranteed to be unique. When a key is guaranteed to be unique, we call them primary keys. The efficiency of a key is also important. Numeric keys are more efficient than alphanumeric keys since computing hash codes with numbers is faster than computing them with characters.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="tuples">Tuples</h1>

<p>Before we can start describing the basic hash table functions, we first need to create a way to handle key-value pairs. We generally refer to any piece of data that has two parts as a <code>tuple</code>. In the case of key-value pairs, our tuple would look like <code>(key, value)</code>. Some languages, such as Python, provide built-in support for creating tuples, while others such as Java and C# require us to create our own tuple class, which is easy to do. All we really need our <code>tuple</code> class to do is to allow us to:</p>
<ol>
<li>create a tuple consisting of two objects,</li>
<li>access either of the two parts of the tuple,</li>
<li>check two tuples for equality, and</li>
<li>convert the tuple to a string.</li>
</ol>
<p>The pseudocode for the <code>Tuple</code> class is given below. Each of the operations is simple and thus we do not discuss them individually. However, notice that the class has two attributes, <code>key</code> and <code>value,</code> that are created in the constructor. The <code>getKey</code> and <code>getValue</code> operations are used often in the code below to provide access to the internals of the tuples.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">class Tuple	
</span></span><span class="line"><span class="cl">    object key = null
</span></span><span class="line"><span class="cl">    object value = null
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    function Tuple(object k, object v)
</span></span><span class="line"><span class="cl">        key = k
</span></span><span class="line"><span class="cl">        value = v
</span></span><span class="line"><span class="cl">    end function
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    function getKey() returns string
</span></span><span class="line"><span class="cl">        return key
</span></span><span class="line"><span class="cl">    end function
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    function getValue() returns object
</span></span><span class="line"><span class="cl">        return value
</span></span><span class="line"><span class="cl">    end function
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    function toString() returns string
</span></span><span class="line"><span class="cl">        return &#34;(&#34; + key.toString() + &#34;,&#34; + value.toString() + &#34;)&#34;
</span></span><span class="line"><span class="cl">    end function
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    function equals(Object o) returns boolean
</span></span><span class="line"><span class="cl">        if o is not an instance of Tuple:
</span></span><span class="line"><span class="cl">            return false
</span></span><span class="line"><span class="cl">        end if
</span></span><span class="line"><span class="cl">        Tuple t = (Tuple)o
</span></span><span class="line"><span class="cl">        return (o.key == key) AND (o.value == value)
</span></span><span class="line"><span class="cl">    end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="hash-table-operations">Hash Table Operations</h1>


<a href="https://www.youtube.com/watch?v=tpEPdUwW4M8">YouTube Video</a>

<p>The <code>HashTable</code> class has three attributes that provide the basic data structure and parameters we need to efficiently manage our table.</p>
<ol>
<li><code>size</code> - captures the number of tuples stored in the table. It is initialized to <code>0</code> in line 7 of the constructor.</li>
<li><code>loadFactor</code> - is the load factor used to determine when to increase the capacity of the array. It is initialized to <code>0.75</code> in line 8 of the constructor.</li>
<li><code>hashTable</code> - is an array of doubly linked lists. The array is actually created in line 4 of the constructor and the doubly linked lists for each location in the array are created in the loop in lines 5 and 6 of the constructor.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">class HashTable
</span></span><span class="line"><span class="cl">    int size	                                    (1)
</span></span><span class="line"><span class="cl">    double loadFactor = 0.75	                    (2)
</span></span><span class="line"><span class="cl">    doubleLinkedList[] hashTable	                (3)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    function HashTable()
</span></span><span class="line"><span class="cl">        hashTable = new doubleLinkedList[16]	    (4)
</span></span><span class="line"><span class="cl">        for i = 0 to hashTable.length	            (5)
</span></span><span class="line"><span class="cl">            hashTable[i] = new doubleLinkedList()	(6)
</span></span><span class="line"><span class="cl">        end for
</span></span><span class="line"><span class="cl">        size = 0	                                (7)
</span></span><span class="line"><span class="cl">        loadFactor = 0.75	                        (8)
</span></span><span class="line"><span class="cl">    end function</span></span></code></pre></div><h2 id="compute-index">Compute Index</h2>
<p>We assume we are using the language-specific hash code function to actually generate our hash code. However, we need to convert that number (typically a very large integer) to an index for our array, which has a limited capacity. Therefore, we use the modulo function in line 1 to convert the hash code into the range of <code>0</code> to the capacity of the array. The <code>computeIndex</code> operation runs in constant time.</p>
<div class="highlight"><pre tabindex="0"><code>function computeIndex(object key) returns integer
    return hashCode(key) % getCapacity() 	(1)
end function</code></pre></div><h2 id="put">Put</h2>
<p>The <code>put</code> operation is an important hash table operation, whose goal is to place a key-value pair into the right linked list. We start by calling <code>computeIndex</code> to find which linked list we should store the key-value pair in, which we can access using <code>hashTable[index]</code>. Next, we check to see if the <code>key</code> has already been stored in the table by iterating through the list found at that location in the table. If the <code>key</code> has already been stored, we should update the value in that tuple to be the new value in line 6 and return on line 7. If the <code>key</code> isn&rsquo;t found, then we actually store the key-value pair in the table by calling the <code>append</code> operation for the <code>hashTable[index]</code> linked list on line 9. Notice, we create a new <code>Tuple</code> using the <code>key</code> and <code>value</code> input parameters before we call append. Since we successfully added the new tuple, we increment the <code>size</code> attribute to keep track of the number of tuples stored in the table.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function put(object key, object value)
</span></span><span class="line"><span class="cl">    index = computeIndex(key)	                    (1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    hashTable[index].reset()	                    (2)
</span></span><span class="line"><span class="cl">    current = hashTable[index].getNext()	        (3)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while current != null	                        (4)
</span></span><span class="line"><span class="cl">        if current.key ==  key 	                    (5)
</span></span><span class="line"><span class="cl">            current.value = value	                (6)
</span></span><span class="line"><span class="cl">            return                                  (7)
</span></span><span class="line"><span class="cl">        end if
</span></span><span class="line"><span class="cl">        current = hashTable[index].getNext()	    (8)
</span></span><span class="line"><span class="cl">    end while
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    hashTable[index].append(new Tuple(key, value))	(9)
</span></span><span class="line"><span class="cl">    size = size + 1 	                            (10)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if size/capacity &gt; loadFactor	                (11)
</span></span><span class="line"><span class="cl">        doubleCapacity()	                        (12)
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Since we have added a new tuple to the table, we need to check to see if the size of the table exceeds our load factor. Therefore, in line 11, we check to see if the value of <code>size/capacity</code> exceeds our <code>loadFactor</code>. If it does, we call the <code>doubleCapacity</code> operation to double the capacity of our array and rehash the table. The <code>doubleCapacity</code> operation is defined below.</p>
<p>Since we are looping through a list of elements in the hash table, it can be difficult to analyze the running time of this method. So, we have to look at both the best case and worst case scenario. In the best case, the linked list is empty, so the entire operation runs in constant time. As long as we have a good hash function and the keys are equally distributed across the hash table, this should be the case.</p>
<p>However, if the hash function is poor, it could cause all of the elements in the hash table to be placed in the same list. In that case, the operation would run on the order of $N$ time, since it would have to iterate across all elements in the list.</p>
<h2 id="get">Get</h2>
<p>The <code>get</code> operation is another important hash table operation, whose goal is to retrieve (without deleting) a key-value pair from the table. Like the <code>put</code> operation, the first thing we need to do is to compute the index of the <code>key</code> we are looking for in line 1. Once we know the <code>index</code>, we call the <code>reset</code> operation on the <code>hashTable[index]</code> linked list so we can call the <code>getNext</code> iterator function in line 3. Lines 4 -7 are a loop that walks through each key-value pair in the linked list. If we find the <code>key</code> we are looking for in line 5, we return <code>true</code> and the operation ends. If we do not find the <code>key</code>, we call the <code>getNext</code> function to get the next element in the linked list. If we end up going through the entire loop until <code>current != null</code> becomes false, we fall out of the loop and return null in line 8, indicating that we did not find <code>key</code> in the table.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function get(object key) returns object
</span></span><span class="line"><span class="cl">    index = computeIndex(key)	                (1)
</span></span><span class="line"><span class="cl">    hashTable[index].reset()	                (2)
</span></span><span class="line"><span class="cl">    current = hashTable[index].getNext()	    (3)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while current != null	                    (4)
</span></span><span class="line"><span class="cl">        if current.key ==  key 	                (5)
</span></span><span class="line"><span class="cl">            return current.value	            (6)
</span></span><span class="line"><span class="cl">        end if
</span></span><span class="line"><span class="cl">        current = hashTable[index].getNext()	(7)
</span></span><span class="line"><span class="cl">    end while
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return null	                                (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>As discussed above, although we do end up looping through one of the linked lists in the hash table, these lists are much, much smaller than the overall size of the hash table under most normal circumstances. Thus, we say that the <code>get</code> operation runs in constant time in the best case.</p>
<h2 id="remove">Remove</h2>
<p>The <code>remove</code> operation is much like the <code>get</code> operation above, except that when we find the <code>key</code> we are searching for, we remove the key-value pair from the appropriate linked-list and return the <code>value</code> to the calling function. The only real difference in the operations lies in the loop intervals in lines 6 and 7. Here, when we find the <code>key</code> in the list, we call the <code>removeCurrent</code> operation to remove the key-value pair from the linked list and then decrement size by 1. Line 8 then returns <code>current.value</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function remove(object key) returns object
</span></span><span class="line"><span class="cl">    index = computeIndex(key)	                (1)
</span></span><span class="line"><span class="cl">    hashTable[index].reset()	                (2)
</span></span><span class="line"><span class="cl">    current = hashTable[index].getNext()	    (3)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while current != null	                    (4)
</span></span><span class="line"><span class="cl">        if current.key == key		            (5)
</span></span><span class="line"><span class="cl">            hashTable[index].removeCurrent()	(6)
</span></span><span class="line"><span class="cl">            size = size â€“ 1	                    (7)
</span></span><span class="line"><span class="cl">            return current.value	            (8)
</span></span><span class="line"><span class="cl">        end if
</span></span><span class="line"><span class="cl">        current = hashTable[index].getNext()	(9)
</span></span><span class="line"><span class="cl">    end while
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return null	                                (10)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Like the <code>get</code> operation above, we loop through one of the linked lists in the hash table. However, given the relatively small size of the list, we assume the <code>remove</code> operation runs in constant time in the best case.</p>
<h2 id="contains-key">Contains Key</h2>
<p>The <code>containsKey</code> operation returns a Boolean value based on whether we find the requested <code>key</code> in the table. Since the <code>get</code> operation already finds the key-value pair associated with a given <code>key</code>, we simply call <code>get</code> and then compute whether the key-value pair returned from <code>get</code> exists to compute the <code>containsKey</code> return value. The <code>containsKey</code> operation runs in constant time in the best case.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function containsKey(object key) returns boolean
</span></span><span class="line"><span class="cl">    return get(key) != null       (1)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="contains-value">Contains Value</h2>
<p>The <code>containsValue</code> operation is not as simple as <code>containsKey</code> since we don&rsquo;t already have an operation to use  to search for a value in our hash table. Since we are not given a <code>key</code> to search for, we cannot use the <code>computeIndex</code> to tell us which linked list to search for our <code>value</code>. Therefore, we need to start at the beginning of our array and loop through each element, searching each of the linked lists stored there for our <code>value</code>.</p>
<p>Line 1 is our outside loop that walks through each linked list stored in our array. Within that  loop, we follow the same search process we used in the <code>get</code> operation to search through <code>hashTable[i]</code>. We set up the iterator in lines 2 and 3 and then walk through the linked list in the loop in lines 4-7. The only difference in this search process is what we are searching for. In line 5, instead of checking if the keys are equal, we check to see if the values are equal. If they are, we return true. However, if we do not find the value somewhere in the table, we must search through every key-value pair in the table, thus the time complexity for <code>containsValue</code> is order $N$.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function containsValue(object value) returns boolean 
</span></span><span class="line"><span class="cl">    for i = 0 to getCapacity()	                (1)
</span></span><span class="line"><span class="cl">        hashTable[i].reset()	                (2)
</span></span><span class="line"><span class="cl">        current = hashTable[i].getNext()	    (3)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        while current != null	                (4)
</span></span><span class="line"><span class="cl">            if current.value == value	        (5)
</span></span><span class="line"><span class="cl">                return true	                    (6)
</span></span><span class="line"><span class="cl">            current = hashTable[i].getNext()	(7)
</span></span><span class="line"><span class="cl">        end while
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return false	                            (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="get-size">Get Size</h2>
<p>The <code>getSize</code> function is very simple. It simply returns the HashTable class&rsquo; <code>size</code> attribute.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function getSize() returns integer
</span></span><span class="line"><span class="cl">    return size          (1)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="get-capacity">Get Capacity</h2>
<p>Like the <code>getSize</code> function, <code>getCapacity</code> simply returns the length of the <code>hashTable</code> array.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function getCapacity() returns integer
</span></span><span class="line"><span class="cl">    return length of the hashTable array      (1)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="is-empty">Is Empty</h2>
<p>The <code>isEmpty</code> operation simply returns the Boolean value of whether or not the <code>size</code> attribute is 0.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function isEmpty() returns boolean
</span></span><span class="line"><span class="cl">    return size == 0              (1)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="copy">Copy</h2>
<p>The <code>copy</code> operation is similar to the <code>containsValue</code> operation in that it must walk through the entire hash table to get all the key-value pairs in the table and <code>put</code> them into the new hash table. Line 1 creates the new empty hash table, which we call <code>copy</code>.</p>
<p>The <code>for</code> loop in line 2 walks through the <code>hashTable</code> array, allowing us to access each linked list using <code>hashTable[i]</code>. Within the loop we use the linked list iterator functions (lines 3, 4, and 7) to walk through each key-value pair in the linked lists. For each key-value pair, we call <code>copy.put</code> to insert that key-value pair into the <code>copy</code> hash table. Once we have completed both loops, we return the copy in line 8. Like the <code>containsValue</code> operation, since we walk through each key-value pair in the hash table, the <code>copy</code> operation runs in order $N$ time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function copy() returns HashTable
</span></span><span class="line"><span class="cl">    HashTable copy = new HashTable()	               (1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for i = 0 to getCapacity()	                       (2)
</span></span><span class="line"><span class="cl">        hashTable[i].reset()	                       (3)
</span></span><span class="line"><span class="cl">        current = hashTable[i].getNext()	           (4)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        while current != null	                       (5)
</span></span><span class="line"><span class="cl">            copy.put(current.key, current.value)	   (6)
</span></span><span class="line"><span class="cl">            current = hashTable[i].getNext()	       (7)
</span></span><span class="line"><span class="cl">        end while
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return copy	                                       (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="to-string">To String</h2>
<p>The <code>toString</code> operation is almost identical to the <code>copy</code> operation above, except that instead of inserting each key-value pair into a second hash table, we append the string representation of each key-value pair to an <code>output</code> string. In fact, the only differences to the pseudocode come in lines 1, 6, and 7. Line 1 creates a new empty string and line 8 returns that string after walking through the hash table. Finally, line 6 is where we append the current key-value pair&rsquo;s string representation to the <code>output</code> string. We also append a comma to separate the key-value pairs in <code>output</code>. Like the <code>copy</code> operation, the <code>toString</code> operation runs in order $N$ time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function toString() returns string
</span></span><span class="line"><span class="cl">    string output = null	                        (1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for i = 0 to getCapacity()	                    (2)
</span></span><span class="line"><span class="cl">        hashTable[i].reset()	                    (3)
</span></span><span class="line"><span class="cl">        current =  hashTable[i].getNext()	        (4)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        while current != null	                    (5)
</span></span><span class="line"><span class="cl">            output += current.toString() + &#34;, &#34;	    (6)
</span></span><span class="line"><span class="cl">            current =  hashTable[i].getNext()	    (7)
</span></span><span class="line"><span class="cl">        end while
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">    return output	                                (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="double-capacity">Double Capacity</h2>
<p>The <code>doubleCapacity</code> operation is similar to the same operations for the array-based stack and queue implementations that we covered earlier. First, we create a new array with twice the capacity of the existing <code>hashTable</code>. Next, we &ldquo;rehash&rdquo; each of the key-value pairs in <code>hashTable</code> into the new table. Finally, we point the <code>hashTable</code> attribute at the new table.</p>
<p>The implementation of this process is captured in the following pseudocode. In line 1, we double the size of <code>capacity</code>. It is important to update <code>capacity</code> first so we can use the new value when creating the new hash table array. It is especially important to use this new capacity when calculating the indexes for key-value pairs in the new table.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function doubleCapacity()
</span></span><span class="line"><span class="cl">    capacity = capacity * 2                                               (1)
</span></span><span class="line"><span class="cl">    doubleLinkedList[] newTable = new doubleLinkedList[getCapacity()]	  (2)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for i = 0 to getCapacity()	                                          (3)
</span></span><span class="line"><span class="cl">        newTable[i] = new doubleLinkedList()	                          (4)
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for i = 0 to getCapacity() / 2	                                      (5)
</span></span><span class="line"><span class="cl">        hashTable[i].reset()	                                          (6)
</span></span><span class="line"><span class="cl">        current = hashTable[i].getNext()	                              (7)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        while current != null	                                          (8)
</span></span><span class="line"><span class="cl">            index = computeIndex(current.key)	                          (9)
</span></span><span class="line"><span class="cl">            newTable[index].append(current)	                              (10)
</span></span><span class="line"><span class="cl">            current = hashTable[i].getNext()	                          (11)
</span></span><span class="line"><span class="cl">        end while
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    hashTable = newTable	                                              (12)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Line 2 creates a new array called <code>newTable</code> with twice the capacity of the existing table. In lines 3 and 4, we create a new doubly linked list for each element of <code>newTable</code>.  Then, in lines 5 â€“ 11 we employ the same looping structure used above in <code>copy</code> and <code>toString</code> to walk through each key-value pair in <code>hashTable</code>. Then for each key-value pair, we compute its new <code>index</code> and then append the key-value pair to the linked list at <code>hashTable[index]</code>.  Once we have completed the copying process, we fall out of the loop. Our final action is to point the <code>hashTable</code> attribute at <code>newTable</code>. Like the <code>copy</code> and <code>toString</code> operations, the run time of <code>doubleCapacity</code> is order $N$.</p>
<h2 id="iterator-operations">Iterator Operations</h2>
<p>While we do not present the iterator operations here, they are useful operations for hash tables. They are implemented similarly to the other iterator functions we have studied, except that in order to walk through the entire hash table we need to use nested loops where the outside loop walks through the array and the internal loop walks through each linked list. This is very similar to the looping structure in <code>doubleCapacity</code> above.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="hash-table-based-sets">Hash Table Based Sets</h1>


<a href="https://www.youtube.com/watch?v=j5TWEWJgJkk">YouTube Video</a>

<p>In this section, we walk through the pseudocode for some basic set operations built on our hash table class above. In this new version of the set class, we declare <code>mySet</code> as a hash table and use that throughout our operations.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">mySet = new HashTable()</span></span></code></pre></div><p>When using a hash table to implement sets, one of the most important choices we must make is what to use for a key. This is really difficult in the case of sets since we do not know exactly what types of objects may be put into the set. Our only real option at this point is just to use the entire object as our key. Our choice to use a default hash function in our hash table turns out to be a good one (at least in modern languages such as Python, Java, and C#), since most default hash functions work on any type of objects.</p>
<p>Next, we discuss the implementation of the important set operations using hash tables.</p>
<h2 id="contains">Contains</h2>
<p>The <code>contains</code> operation is straightforward since we are using the entire object as the key. We simply return the value from the hash table <code>containsKey</code> operation, which performs the exact function we need.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function contains(object o) returns boolean
</span></span><span class="line"><span class="cl">    return mySet.containsKey(o)         (1)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="add">Add</h2>
<p>The <code>add</code> operation maps almost exactly to the hash table <code>put</code> operation except that the <code>put</code> operation does not return a boolean value. So, we first check to see if the key is already contained in the hash table. If so, we just return <code>false</code>, since we don&rsquo;t need to add the value to the set. Otherwise, we add a new tuple to the hash table, and then return <code>true</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function add(object o) returns boolean
</span></span><span class="line"><span class="cl">    if mySet.containsKey(o)
</span></span><span class="line"><span class="cl">        return false
</span></span><span class="line"><span class="cl">    end if
</span></span><span class="line"><span class="cl">    mySet.put(o, o)
</span></span><span class="line"><span class="cl">    return true
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="remove">Remove</h2>
<p>The set <code>remove</code> operation maps almost exactly to the hash table <code>remove</code> operation, so we just call it and then check to see if the result is not null. If it is null, we will return <code>false</code> since the element was not in the set; otherwise we return <code>true</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function remove(object o) returns boolean
</span></span><span class="line"><span class="cl">    return mySet.remove(o) != null
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="intersection">Intersection</h2>
<p>The <code>intersection</code> operation creates a new set that has only elements which exist in both sets under consideration. In code, we basically accomplish this by looping through the elements in one set and then checking to see if they exist in the other set. If they do, then we include them in the intersection.</p>
<p>The pseudocode follows that basic algorithm using the hash table iterator to loop through and look at each element in <code>set1</code>.  We start by creating a new set, <code>result,</code> to hold the intersection of <code>set1</code> and <code>set2</code> in line 1. Then we get the first element pair from <code>set1</code> by calling the hash table <code>reset</code> operation in line 2 and the <code>getNext</code> operation in line 3.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function intersection(set1, set2) returns set
</span></span><span class="line"><span class="cl">    result = new Set()	                    (1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    set1.reset()	                        (2)
</span></span><span class="line"><span class="cl">    current = set1.getNext()	            (3)
</span></span><span class="line"><span class="cl">    while current != null	                (4)
</span></span><span class="line"><span class="cl">        if set2.contains(current.getKey())	(5)
</span></span><span class="line"><span class="cl">            result.add(current.getKey())	(6)
</span></span><span class="line"><span class="cl">        end if
</span></span><span class="line"><span class="cl">        current = set1.getNext()	        (7)
</span></span><span class="line"><span class="cl">    end while
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return result	                        (8)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><p>Lines 4 â€“ 7 implement the loop that walks through each element in <code>set1</code>. If the current element is contained in <code>set2</code> (line 5), the operation calls the <code>add</code> operation to insert the key of the <code>current</code> element into the <code>result</code> set. Line 7 gets the next element from <code>set1</code> and loops back to the top.
Eventually, we look at each element in <code>set1</code> and fall out of the loop. When that happens, the intersection operation is complete, and it returns the <code>result</code> set in line 8.</p>
<h2 id="union">Union</h2>
<p>The <code>union</code> operation is similar to the <code>intersection</code> operation in that we need to use the hash table iterator operations to walk through our sets. The difference lies in what we include in the new <code>result</code> set. While we only walked through <code>set1</code> in the <code>intersection</code> operation, picking only those objects that existed in <code>set2</code>, here we start by copying all elements from <code>set2</code> into the <code>result</code> set and then walk through <code>set1</code> adding each of its elements to the <code>result</code> set as well. (Here we don&rsquo;t need to worry about adding duplicates since the <code>add</code> operation takes care of that for us.)</p>
<p>The code starts in line 1 by making a <code>copy</code> of <code>set2</code> and assigning it to our new <code>result</code> set. Then, lines 2 and 3 reset the <code>set1</code> iterator and get the first item from <code>set1</code>. Lines 4 â€“ 6 form the <code>while</code> loop that we use to walk through each element in <code>set1</code>. This time, however, we simply add every element we find in line 5 before getting the next object in line 6. Once the loop exists we are done and we return the <code>result</code> set in line 7.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function union(set1, set2) returns set
</span></span><span class="line"><span class="cl">    result = set2.copy()	            (1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    set1.reset()	                    (2)
</span></span><span class="line"><span class="cl">    current = set1.getNext()	        (3)
</span></span><span class="line"><span class="cl">    while current != null	            (4)
</span></span><span class="line"><span class="cl">        result.add(current.getKey())	(5)
</span></span><span class="line"><span class="cl">        current = set1.getNext()	    (6)
</span></span><span class="line"><span class="cl">    end while
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return result	                    (7)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div><h2 id="issubset">isSubset</h2>
<p>The <code>isSubset</code> operation below is very much like the <code>intersection</code> operation above as we have a loop in lines 3 - 6 that checks each element of <code>set1</code> and checks to see if it is in <code>set2</code>. The difference between the two operations is that in the <code>isSubset</code> operation, we do not build a third <code>result</code> set. Instead, if any element in <code>set1</code> is not found in <code>set2</code>, then we return <code>false</code> since not all elements of <code>set1</code> are contained in <code>set2</code>. If we get all the way through the loop, we have checked that each element in <code>set1</code> was found in <code>set2</code> and we can return <code>true</code>; <code>set1</code> is a subset of <code>set2</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">function isSubset (set1, set2) returns boolean
</span></span><span class="line"><span class="cl">    set1.reset()	                          (1)
</span></span><span class="line"><span class="cl">    current = set1.getNext()	              (2)
</span></span><span class="line"><span class="cl">    while current != null	                  (3)
</span></span><span class="line"><span class="cl">        if set2.contains(current.getKey())	  (4)
</span></span><span class="line"><span class="cl">            return false	                  (5)
</span></span><span class="line"><span class="cl">        end if
</span></span><span class="line"><span class="cl">        current = set1.getNext()	          (6)
</span></span><span class="line"><span class="cl">    end while
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return true	                              (7)
</span></span><span class="line"><span class="cl">end function</span></span></code></pre></div>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="hash-tables-summary">Hash Tables Summary</h1>

<p>In this module, we introduced the concept of a hash table, which is a data structure that provides efficient insertion and retrieval operations. We introduced the three essential elements of hash tables:</p>
<ol>
<li>An array that holds buckets where key-value pairs are stored,</li>
<li>A hash function that maps a key to a specific array index, and</li>
<li>A set of buckets that allow the hash table to store multiple key-value pairs whose keys map to the same index in the array.</li>
</ol>
<p>We then discussed how to implement a hash table class. In our implementation, we chose to use built-in, language-specific hash code functions to generate the indexes into our array. We also used doubly linked lists to implement our buckets as linked lists are very flexible and provide constant time insertion operations.
To demonstrate the effectiveness of hash tables, we re-implemented our set class using hash tables instead of linked lists. In many ways, the re-implementation was almost identical to the linked list implementation since many of the operations found in hash tables are almost identical to those found in linked lists. We also noted that the biggest advantage of implementing sets with hash tables is the (almost!) constant time retrieval operations provided by hash tables.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cc310/commit/301ec8aaa3405c30b07aa146ef1fa7f85a5af97c">Aug 17, 2021</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cc310/js/clipboard.min.js?1719608379" defer></script>
    <script src="/cc310/js/perfect-scrollbar.min.js?1719608379" defer></script>
    <script src="/cc310/js/theme.js?1719608379" defer></script>
  </body>
</html>
